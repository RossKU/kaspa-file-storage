<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kaspa P2P File Storage v2.0 - Complete Edition</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
        }
        .header {
            background: linear-gradient(135deg, #16213e 0%, #0f3460 100%);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        h1 {
            margin: 0;
            color: #e94560;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .container {
            background: #0f3460;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        .tab-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .tab-btn {
            flex: 1;
            background: #16213e;
            color: #e94560;
            border: 2px solid #e94560;
            padding: 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        .tab-btn:hover {
            background: #1a2540;
            transform: translateY(-2px);
        }
        .tab-btn.active {
            background: #e94560;
            color: white;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        button {
            background: #e94560;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: all 0.3s;
        }
        button:hover {
            background: #c13651;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(233, 69, 96, 0.3);
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        input[type="text"], input[type="password"], input[type="number"], select, textarea {
            width: 100%;
            background: #16213e;
            color: #eee;
            border: 1px solid #e94560;
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
            font-family: 'Consolas', monospace;
        }
        input[type="file"] {
            display: none;
        }
        .file-input-label {
            display: inline-block;
            background: #16213e;
            color: #e94560;
            border: 2px dashed #e94560;
            padding: 30px;
            border-radius: 5px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s;
            width: 100%;
            box-sizing: border-box;
            margin: 10px 0;
        }
        .file-input-label:hover {
            background: #1a2540;
            border-color: #ff5c7c;
        }
        .metric-box {
            background: rgba(233, 69, 96, 0.1);
            border: 1px solid #e94560;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .success { color: #4CAF50; }
        .error { color: #ff5252; }
        .warning { color: #ffc107; }
        .info { color: #2196F3; }
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #16213e;
            border-radius: 15px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #e94560, #ff5c7c);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }
        .status-online { background: #4CAF50; }
        .status-offline { background: #ff5252; }
        .status-connecting { background: #ffc107; animation: pulse 1s infinite; }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        .log-container {
            background: #0a0a0a;
            color: #0f0;
            font-family: 'Consolas', monospace;
            font-size: 12px;
            padding: 10px;
            height: 200px;
            overflow-y: auto;
            border-radius: 5px;
            margin: 10px 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .log-entry {
            margin: 2px 0;
        }
        .log-time {
            color: #888;
        }
        .log-error {
            color: #ff5252;
        }
        .log-success {
            color: #4CAF50;
        }
        .log-info {
            color: #2196F3;
        }
        .log-warning {
            color: #ffc107;
        }
        .chunk-item {
            background: #16213e;
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid rgba(233, 69, 96, 0.3);
        }
        .chunk-status {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .chunk-status.pending { color: #888; }
        .chunk-status.uploading { color: #ffc107; }
        .chunk-status.success { color: #4CAF50; }
        .chunk-status.error { color: #ff5252; }
        .json-view {
            background: #0a0a0a;
            color: #4CAF50;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.5;
            max-height: 400px;
            overflow-y: auto;
        }
        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        .checkbox-label input[type="checkbox"] {
            width: auto;
        }
        .kaspa-file-drop {
            background: #16213e;
            border: 2px dashed #e94560;
            padding: 40px;
            text-align: center;
            border-radius: 10px;
            transition: all 0.3s;
        }
        .kaspa-file-drop:hover {
            background: #1a2540;
            border-color: #ff5c7c;
        }
        .kaspa-file-drop.dragover {
            background: #1a2540;
            border-color: #4CAF50;
        }
        .copy-btn {
            background: #16213e;
            color: #e94560;
            border: 1px solid #e94560;
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
        }
        .copy-btn:hover {
            background: #e94560;
            color: white;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        th {
            background: rgba(233, 69, 96, 0.2);
            color: #e94560;
        }
        .section-divider {
            border-top: 2px solid #e94560;
            margin: 20px 0;
            padding-top: 20px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸš€ Kaspa P2P File Storage v2.0 - Complete Edition</h1>
        <p>å®Ÿãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã«ã‚ˆã‚‹å®Œå…¨ãªP2Pãƒ•ã‚¡ã‚¤ãƒ«å…±æœ‰ã‚·ã‚¹ãƒ†ãƒ </p>
        <div id="networkStatus" style="margin-top: 10px;">
            <span class="status-indicator status-offline"></span>
            <span id="statusText">æœªæ¥ç¶š</span>
        </div>
    </div>

    <!-- Tab Navigation -->
    <div class="tab-buttons">
        <button class="tab-btn active" onclick="switchTab('upload')">ğŸ“¤ Upload</button>
        <button class="tab-btn" onclick="switchTab('download')">ğŸ“¥ Download</button>
        <button class="tab-btn" onclick="switchTab('monitor')">ğŸ“¡ Monitor</button>
        <button class="tab-btn" onclick="switchTab('settings')">âš™ï¸ Settings</button>
    </div>

    <!-- Upload Tab -->
    <div id="upload-tab" class="tab-content active">
        <!-- WASM Initialization -->
        <div class="container">
            <h2>ğŸ”§ ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–</h2>
            <div class="grid-2">
                <button onclick="initializeSystem()" id="initBtn">ã‚·ã‚¹ãƒ†ãƒ ã‚’åˆæœŸåŒ–</button>
                <button onclick="testConnection()" id="testBtn" disabled>æ¥ç¶šãƒ†ã‚¹ãƒˆ</button>
            </div>
            <div id="initStatus" class="metric-box" style="display: none;"></div>
        </div>

        <!-- File Upload -->
        <div class="container">
            <h2>ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰</h2>
            
            <label for="fileInput" class="file-input-label">
                ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ<br>
                <small>ã¾ãŸã¯ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—</small>
            </label>
            <input type="file" id="fileInput" onchange="handleFileSelect(event)">
            
            <div class="grid-2">
                <div>
                    <label>ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ (8æ–‡å­—ä»¥ä¸Š)</label>
                    <input type="password" id="uploadPassword" placeholder="å¼·åŠ›ãªãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›">
                </div>
                <div>
                    <label>ãƒãƒ£ãƒ³ã‚¯ã‚µã‚¤ã‚º</label>
                    <select id="chunkSize">
                        <option value="10">10KB chunks (å®‰å…¨)</option>
                        <option value="12" selected>12KB chunks (æ¨å¥¨)</option>
                        <option value="15">15KB chunks (ãƒªã‚¹ã‚¯ã‚ã‚Š)</option>
                    </select>
                </div>
            </div>
            
            <div class="checkbox-label">
                <input type="checkbox" id="includePassword">
                <label for="includePassword">ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’.kaspaãƒ•ã‚¡ã‚¤ãƒ«ã«å«ã‚ã‚‹ï¼ˆâš ï¸ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒªã‚¹ã‚¯ï¼‰</label>
            </div>
            
            <div class="checkbox-label">
                <input type="checkbox" id="useMetaTx">
                <label for="useMetaTx">ãƒ¡ã‚¿TxIDã‚’ä½¿ç”¨ï¼ˆ.kaspaãƒ•ã‚¡ã‚¤ãƒ«ä¸è¦ã§å…±æœ‰å¯èƒ½ï¼‰</label>
            </div>
            
            <button onclick="processAndUpload()" id="uploadBtn" disabled>
                ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‡¦ç†ã—ã¦ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
            </button>
            
            <!-- Upload Progress -->
            <div id="uploadProgress" style="display: none;">
                <div class="progress-bar">
                    <div class="progress-fill" id="uploadProgressBar">0%</div>
                </div>
                <div id="chunksList"></div>
            </div>
            
            <!-- Generate .kaspa -->
            <div id="generateKaspaSection" style="display: none;" class="section-divider">
                <h3>ğŸ“„ .kaspaãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆ</h3>
                <button onclick="generateKaspaFile()" id="generateBtn">
                    .kaspa P2Pãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆ
                </button>
                <div id="kaspaResult"></div>
            </div>
        </div>
    </div>

    <!-- Download Tab -->
    <div id="download-tab" class="tab-content">
        <div class="container">
            <h2>ğŸ“¥ ãƒ•ã‚¡ã‚¤ãƒ«ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</h2>
            
            <!-- Meta-TxID input option -->
            <div class="section-divider">
                <h3>ğŸ”— ãƒ¡ã‚¿TxIDã‹ã‚‰å¾©å…ƒ</h3>
                <input type="text" id="metaTxIdInput" placeholder="ãƒ¡ã‚¿TxID ã¾ãŸã¯ TxID:BlockID ã‚’å…¥åŠ›" style="width: 100%;">
                <input type="password" id="metaTxPassword" placeholder="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰" style="width: 100%; margin-top: 10px;">
                <button onclick="loadFromMetaTxId()" style="margin-top: 10px;">ãƒ¡ã‚¿TxIDã‹ã‚‰å¾©å…ƒ</button>
                <div class="info" style="margin-top: 10px; font-size: 12px;">
                    <p>ğŸ“Œ å¯¾å¿œãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ:</p>
                    <ul style="margin: 5px 0; padding-left: 20px;">
                        <li>TxID:BlockIDå½¢å¼ï¼ˆæ¨å¥¨ã€REST APIä¸è¦ï¼‰</li>
                        <li>TxIDã®ã¿ï¼ˆREST APIå¿…è¦ï¼‰</li>
                    </ul>
                </div>
            </div>
            
            <div class="section-divider" style="margin-top: 20px;">
                <h3>ğŸ“ ã¾ãŸã¯.kaspaãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å¾©å…ƒ</h3>
                <div class="kaspa-file-drop" onclick="document.getElementById('kaspaFileInput').click()" 
                     ondrop="handleKaspaDrop(event)" 
                     ondragover="handleDragOver(event)" 
                     ondragleave="handleDragLeave(event)">
                    <p>ğŸ“ .kaspaãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦é¸æŠ<br>ã¾ãŸã¯ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—</p>
                </div>
                <input type="file" id="kaspaFileInput" accept=".kaspa" style="display:none" onchange="loadKaspaFile(event)">
            </div>
            
            <div id="downloadSection" style="display: none;">
                <div class="metric-box">
                    <h3>ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±</h3>
                    <pre id="fileInfo"></pre>
                </div>
                
                <div id="passwordSection">
                    <label>ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰</label>
                    <input type="password" id="downloadPassword" placeholder="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›">
                </div>
                
                <button onclick="downloadFile()">ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
                
                <div id="downloadProgress" style="display: none;">
                    <div class="progress-bar">
                        <div class="progress-fill" id="downloadProgressBar">0%</div>
                    </div>
                    <div id="downloadStatus"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Monitor Tab -->
    <div id="monitor-tab" class="tab-content">
        <div class="container">
            <h2>ğŸ“¡ WebSocketç›£è¦–</h2>
            <div class="grid-2">
                <button onclick="startMonitoring()">ç›£è¦–é–‹å§‹</button>
                <button onclick="stopMonitoring()">ç›£è¦–åœæ­¢</button>
            </div>
            
            <div class="metric-box">
                <table>
                    <tr>
                        <th>ç›£è¦–ä¸­ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³</th>
                        <td id="monitoringCount">0</td>
                    </tr>
                    <tr>
                        <th>æ¤œå‡ºã•ã‚ŒãŸBlockID</th>
                        <td id="detectedCount">0</td>
                    </tr>
                    <tr>
                        <th>ç›£è¦–é–‹å§‹æ™‚åˆ»</th>
                        <td id="monitorStartTime">-</td>
                    </tr>
                </table>
            </div>
            
            <h3>ç›£è¦–ãƒ­ã‚°</h3>
            <div class="log-container" id="monitorLog"></div>
        </div>
    </div>

    <!-- Settings Tab -->
    <div id="settings-tab" class="tab-content">
        <div class="container">
            <h2>âš™ï¸ è¨­å®š</h2>
            
            <div class="metric-box">
                <h3>ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯è¨­å®š</h3>
                <label>ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯</label>
                <select id="networkSelect">
                    <option value="testnet-10" selected>Testnet-10 (ãƒ†ã‚¹ãƒˆç”¨)</option>
                    <option value="mainnet">Mainnet (æœ¬ç•ª)</option>
                </select>
                
                <label>ãƒªãƒˆãƒ©ã‚¤å›æ•°</label>
                <input type="number" id="retryCount" value="3" min="0" max="10">
                
                <label>ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ (ç§’)</label>
                <input type="number" id="timeout" value="30" min="10" max="120">
            </div>
            
            <div class="metric-box">
                <h3>ãƒ­ã‚°ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</h3>
                <button onclick="exportLogs()">ãƒ­ã‚°ã‚’JSONå½¢å¼ã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
                <button onclick="clearLogs()">ãƒ­ã‚°ã‚’ã‚¯ãƒªã‚¢</button>
            </div>
            
            <div class="metric-box">
                <h3>ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å±¥æ­´</h3>
                <div id="uploadHistory"></div>
            </div>
        </div>
    </div>

    <!-- System Log -->
    <div class="container">
        <h3>ğŸ“ ã‚·ã‚¹ãƒ†ãƒ ãƒ­ã‚°</h3>
        <div class="log-container" id="systemLog"></div>
        <button class="copy-btn" onclick="copyLog()">ãƒ­ã‚°ã‚’ã‚³ãƒ”ãƒ¼</button>
    </div>

    <script type="module">
        // Global state
        let kaspa = null;
        let rpcClient = null;
        let currentFile = null;
        let currentPassword = null;
        let processedChunks = [];
        let kaspaMetadata = null;
        let wsMonitorActive = false;
        let monitoredTransactions = new Map();
        let uploadHistory = [];
        let systemLogs = [];
        let privateKey = null;
        let address = null;
        
        // Configuration
        const config = {
            network: 'testnet-10',
            retryCount: 3,
            timeout: 30000,
            testPrivateKey: 'b7e151628aed2a6abf7158809cf4f3c762e7160f38b4da56a784d9045190cfef'
        };

        // Logging system
        function log(message, type = 'info') {
            const timestamp = new Date();
            const logEntry = {
                timestamp: timestamp.toISOString(),
                time: timestamp.toLocaleTimeString(),
                type: type,
                message: message
            };
            
            systemLogs.push(logEntry);
            
            const logContainer = document.getElementById('systemLog');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<span class="log-time">[${logEntry.time}]</span> <span class="log-${type}">${message}</span>`;
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function monitorLog(message, type = 'info') {
            const logContainer = document.getElementById('monitorLog');
            const time = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<span class="log-time">[${time}]</span> <span class="log-${type}">${message}</span>`;
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // Network status
        function updateNetworkStatus(status, text) {
            const indicator = document.querySelector('.status-indicator');
            const statusText = document.getElementById('statusText');
            
            indicator.className = 'status-indicator';
            switch(status) {
                case 'online':
                    indicator.classList.add('status-online');
                    break;
                case 'offline':
                    indicator.classList.add('status-offline');
                    break;
                case 'connecting':
                    indicator.classList.add('status-connecting');
                    break;
            }
            statusText.textContent = text;
        }

        // Tab switching
        window.switchTab = function(tab) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            const tabIndex = ['upload', 'download', 'monitor', 'settings'].indexOf(tab);
            document.querySelectorAll('.tab-btn')[tabIndex].classList.add('active');
            document.getElementById(`${tab}-tab`).classList.add('active');
        };

        // System initialization
        window.initializeSystem = async function() {
            try {
                log('ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–ã‚’é–‹å§‹...');
                updateNetworkStatus('connecting', 'åˆæœŸåŒ–ä¸­...');
                
                // Import WASM SDK
                kaspa = await import('./kaspa-core.js');
                log('kaspa-core.jsã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ');
                
                // Initialize WASM binary
                await kaspa.default('./kaspa-core_bg.wasm');
                log('WASMãƒã‚¤ãƒŠãƒªã‚’åˆæœŸåŒ–ã—ã¾ã—ãŸ');
                
                // Verify functions
                const requiredFunctions = ['RpcClient', 'Resolver', 'createTransactions', 
                    'PrivateKey', 'addressFromScriptPublicKey', 'Address'];
                for (const func of requiredFunctions) {
                    if (typeof kaspa[func] !== 'function') {
                        throw new Error(`å¿…è¦ãªé–¢æ•°ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${func}`);
                    }
                }
                log('ã™ã¹ã¦ã®å¿…è¦ãªé–¢æ•°ã‚’ç¢ºèªã—ã¾ã—ãŸ', 'success');
                
                // Initialize wallet
                privateKey = new kaspa.PrivateKey(config.testPrivateKey);
                const publicKey = privateKey.toPublicKey();
                address = publicKey.toAddress(config.network);
                
                log(`ã‚¦ã‚©ãƒ¬ãƒƒãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹: ${address.toString()}`, 'success');
                
                // Create RPC client
                rpcClient = new kaspa.RpcClient({
                    resolver: new kaspa.Resolver(),
                    networkId: config.network
                });
                
                log('RPCæ¥ç¶šã‚’è©¦è¡Œä¸­...');
                await rpcClient.connect();
                
                // Test connection
                const info = await rpcClient.getServerInfo();
                log(`æ¥ç¶šæˆåŠŸ! ã‚µãƒ¼ãƒãƒ¼: ${info.serverVersion}`, 'success');
                
                // Get balance
                const { entries } = await rpcClient.getUtxosByAddresses([address.toString()]);
                const balance = entries.reduce((sum, utxo) => sum + Number(utxo.amount), 0) / 1e8;
                log(`æ®‹é«˜: ${balance} KAS`, 'info');
                
                // Update UI
                window.kaspa = kaspa;
                document.getElementById('initStatus').style.display = 'block';
                document.getElementById('initStatus').innerHTML = `
                    <p class="success">âœ… ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº†</p>
                    <p>ã‚¢ãƒ‰ãƒ¬ã‚¹: ${address.toString()}</p>
                    <p>æ®‹é«˜: ${balance} KAS</p>
                `;
                document.getElementById('testBtn').disabled = false;
                document.getElementById('uploadBtn').disabled = false;
                
                updateNetworkStatus('online', 'ã‚ªãƒ³ãƒ©ã‚¤ãƒ³');
                
            } catch (error) {
                log(`åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                updateNetworkStatus('offline', 'ã‚¨ãƒ©ãƒ¼');
            }
        };

        // Connection test
        window.testConnection = async function() {
            try {
                log('æ¥ç¶šãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œä¸­...');
                const startTime = Date.now();
                
                // Test RPC
                const info = await rpcClient.getServerInfo();
                const rpcTime = Date.now() - startTime;
                log(`RPCå¿œç­”æ™‚é–“: ${rpcTime}ms`, 'success');
                
                // Test Explorer API
                const apiStart = Date.now();
                const response = await fetch('https://api-tn10.kaspa.org/info/health');
                const apiTime = Date.now() - apiStart;
                log(`Explorer APIå¿œç­”æ™‚é–“: ${apiTime}ms`, 'success');
                
                alert(`æ¥ç¶šãƒ†ã‚¹ãƒˆæˆåŠŸ!\nRPC: ${rpcTime}ms\nAPI: ${apiTime}ms`);
                
            } catch (error) {
                log(`æ¥ç¶šãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        // File handling
        window.handleFileSelect = function(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            currentFile = file;
            log(`ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ: ${file.name} (${(file.size/1024).toFixed(1)}KB)`);
            
            // Update UI
            const label = document.querySelector('.file-input-label');
            label.innerHTML = `
                <strong>${file.name}</strong><br>
                ${(file.size/1024/1024).toFixed(2)}MB
            `;
        };

        // Compression logic
        const COMPRESS_SKIP = new Set(['jpg','jpeg','png','gif','webp','mp4','avi','mov','mp3','wav','zip','rar','pdf']);
        
        function shouldCompress(filename) {
            const ext = filename.split('.').pop()?.toLowerCase() || '';
            return !COMPRESS_SKIP.has(ext);
        }

        // LZ compression
        function lzCompress(data) {
            const result = [];
            let i = 0;
            while (i < data.length) {
                let bestLen = 0, bestOff = 0;
                const start = Math.max(0, i - 255);
                for (let j = start; j < i; j++) {
                    let len = 0;
                    while (i + len < data.length && data[j + len] === data[i + len] && len < 255) len++;
                    if (len > bestLen) {
                        bestLen = len;
                        bestOff = i - j;
                    }
                }
                if (bestLen > 3) {
                    result.push(255, bestOff, bestLen);
                    i += bestLen;
                } else {
                    result.push(data[i]);
                    i++;
                }
            }
            return new Uint8Array(result);
        }

        function lzDecompress(data) {
            const result = [];
            let i = 0;
            while (i < data.length) {
                if (data[i] === 255 && i + 2 < data.length) {
                    const off = data[i + 1];
                    const len = data[i + 2];
                    const start = result.length - off;
                    for (let j = 0; j < len; j++) {
                        result.push(result[start + j]);
                    }
                    i += 3;
                } else {
                    result.push(data[i]);
                    i++;
                }
            }
            return new Uint8Array(result);
        }

        // Encryption
        async function deriveKey(password, salt) {
            const encoder = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                'raw',
                encoder.encode(password),
                'PBKDF2',
                false,
                ['deriveKey']
            );
            
            return crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: 10000,
                    hash: 'SHA-256'
                },
                keyMaterial,
                { name: 'AES-GCM', length: 256 },
                false,
                ['encrypt', 'decrypt']
            );
        }

        async function encryptChunk(data, key, chunkIndex) {
            const iv = new Uint8Array(12);
            
            // Special handling for meta-tx (chunkIndex = -1)
            if (chunkIndex === -1) {
                // Use a special pattern for meta-tx
                iv[0] = 0xFF;
                iv[1] = 0xFF;
                for (let i = 2; i < 12; i++) {
                    iv[i] = 0xFF - i;
                }
            } else {
                iv[0] = (chunkIndex >> 8) & 0xFF;
                iv[1] = chunkIndex & 0xFF;
                for (let i = 2; i < 12; i++) {
                    iv[i] = i * 17;
                }
            }
            
            const encrypted = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                data
            );
            
            return new Uint8Array(encrypted);
        }

        async function decryptChunk(data, key, chunkIndex) {
            const iv = new Uint8Array(12);
            
            // Special handling for meta-tx (chunkIndex = -1)
            if (chunkIndex === -1) {
                // Use a special pattern for meta-tx
                iv[0] = 0xFF;
                iv[1] = 0xFF;
                for (let i = 2; i < 12; i++) {
                    iv[i] = 0xFF - i;
                }
            } else {
                iv[0] = (chunkIndex >> 8) & 0xFF;
                iv[1] = chunkIndex & 0xFF;
                for (let i = 2; i < 12; i++) {
                    iv[i] = i * 17;
                }
            }
            
            const decrypted = await crypto.subtle.decrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                data
            );
            
            return new Uint8Array(decrypted);
        }

        // Base64
        function toBase64(data) {
            return btoa(String.fromCharCode(...data));
        }

        function fromBase64(str) {
            return new Uint8Array(atob(str).split('').map(c => c.charCodeAt(0)));
        }

        // SHA256
        async function sha256(data) {
            const hash = await crypto.subtle.digest('SHA-256', data);
            return Array.from(new Uint8Array(hash))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }

        // Calculate safe payload size based on storage mass limit
        function calculateSafePayloadSize(rawChunkSize) {
            // Storage mass limit is 100,000
            // After compression, encryption, and Base64 encoding:
            // - Base64 expands by ~33%
            // - Encryption adds ~16 bytes
            // - UTF-8 encoding of Base64 string
            // Safe limit is around 12KB for raw data
            return Math.min(rawChunkSize, 12288); // 12KB max
        }
        
        // Process and upload file
        window.processAndUpload = async function() {
            if (!currentFile) {
                log('ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“', 'error');
                return;
            }
            
            const password = document.getElementById('uploadPassword').value;
            if (password.length < 8) {
                log('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯8æ–‡å­—ä»¥ä¸Šå¿…è¦ã§ã™', 'error');
                return;
            }
            
            if (!rpcClient) {
                log('å…ˆã«ã‚·ã‚¹ãƒ†ãƒ ã‚’åˆæœŸåŒ–ã—ã¦ãã ã•ã„', 'error');
                return;
            }
            
            currentPassword = password;
            processedChunks = [];
            
            document.getElementById('uploadBtn').disabled = true;
            document.getElementById('uploadProgress').style.display = 'block';
            
            try {
                log(`å‡¦ç†é–‹å§‹: ${currentFile.name}`);
                
                const data = new Uint8Array(await currentFile.arrayBuffer());
                const fileHash = await sha256(data);
                
                // Compression strategy
                const useCompression = shouldCompress(currentFile.name);
                log(`åœ§ç¸®: ${useCompression ? 'æœ‰åŠ¹' : 'ç„¡åŠ¹'}`);
                
                // Generate salt
                const saltBase = fileHash + currentFile.name;
                const saltHash = await sha256(new TextEncoder().encode(saltBase));
                // Take first 16 bytes of hash (32 hex chars = 16 bytes)
                const salt = new Uint8Array(saltHash.substring(0, 32).match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
                
                const key = await deriveKey(password, salt);
                
                // Get chunk size and apply safety limit
                const requestedChunkSize = parseInt(document.getElementById('chunkSize').value) * 1024;
                const chunkSize = calculateSafePayloadSize(requestedChunkSize);
                
                if (chunkSize < requestedChunkSize) {
                    log(`ãƒãƒ£ãƒ³ã‚¯ã‚µã‚¤ã‚ºã‚’å®‰å…¨ãªå€¤ã«èª¿æ•´: ${(chunkSize/1024).toFixed(1)}KB`, 'warning');
                }
                const chunks = Math.ceil(data.length / chunkSize);
                log(`ãƒãƒ£ãƒ³ã‚¯æ•°: ${chunks}`);
                
                // Initial UTXO fetch
                let currentUtxos = null;
                
                // Start WebSocket monitoring
                if (!wsMonitorActive) {
                    await startMonitoring();
                }
                
                // Process chunks
                const chunksList = document.getElementById('chunksList');
                chunksList.innerHTML = '';
                
                for (let i = 0; i < chunks; i++) {
                    // Get fresh UTXOs for each chunk
                    const { entries } = await rpcClient.getUtxosByAddresses([address.toString()]);
                    if (!entries || entries.length === 0) {
                        throw new Error('åˆ©ç”¨å¯èƒ½ãªUTXOãŒã‚ã‚Šã¾ã›ã‚“');
                    }
                    log(`Chunk ${i + 1}: ${entries.length} UTXOs available`);
                    const start = i * chunkSize;
                    const end = Math.min(start + chunkSize, data.length);
                    const chunk = data.slice(start, end);
                    
                    // Create chunk UI
                    const chunkDiv = document.createElement('div');
                    chunkDiv.className = 'chunk-item';
                    chunkDiv.innerHTML = `
                        <div>Chunk ${i + 1}/${chunks} (${(chunk.length/1024).toFixed(1)}KB)</div>
                        <div class="chunk-status pending" id="chunk-status-${i}">
                            <span>å¾…æ©Ÿä¸­</span>
                        </div>
                    `;
                    chunksList.appendChild(chunkDiv);
                    
                    // Process chunk
                    const compressed = useCompression ? lzCompress(chunk) : chunk;
                    const encrypted = await encryptChunk(compressed, key, i);
                    // No Base64 encoding - use raw binary
                    const payloadBytes = encrypted; // Direct binary payload
                    
                    // Update status
                    document.getElementById(`chunk-status-${i}`).innerHTML = '<span class="uploading">ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ä¸­...</span>';
                    
                    // Upload to blockchain with retry
                    let txid = null;
                    let blockId = null;
                    let retries = 0;
                    
                    while (retries < config.retryCount && !txid) {
                        try {
                            // Create transaction with raw binary payload
                            
                            // Check payload size before sending
                            if (payloadBytes.length > 24000) {
                                throw new Error(`Payload too large: ${payloadBytes.length} bytes (max 24000)`);
                            }
                            
                            log(`Chunk ${i + 1} payload size: ${payloadBytes.length} bytes`);

                            
                            // Format current UTXOs
                            const formattedUtxos = entries.map(utxo => ({
                                address: address.toString(),
                                outpoint: {
                                    transactionId: utxo.outpoint.transactionId,
                                    index: utxo.outpoint.index
                                },
                                scriptPublicKey: utxo.scriptPublicKey,
                                amount: BigInt(utxo.amount),
                                isCoinbase: utxo.isCoinbase || false,
                                blockDaaScore: BigInt(utxo.blockDaaScore)
                            }));
                            
                            const result = await kaspa.createTransactions({
                                entries: formattedUtxos,
                                outputs: [{
                                    address: address.toString(),
                                    amount: 100000000n // 1 KAS
                                }],
                                changeAddress: address.toString(),
                                priorityFee: 10000n,
                                networkId: config.network,
                                payload: payloadBytes
                            });
                            
                            // Sign and submit transaction
                            if (!result.transactions || result.transactions.length === 0) {
                                throw new Error('No transactions generated');
                            }
                            
                            const pendingTx = result.transactions[0];
                            
                            // Sign the transaction
                            await pendingTx.sign([privateKey]);
                            
                            // Submit to network
                            txid = await pendingTx.submit(rpcClient);
                            
                            // Wait for transaction to be accepted
                            log(`Waiting for transaction confirmation...`);
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            
                            log(`Chunk ${i + 1} TxID: ${txid}`, 'success');
                            
                            // Wait for BlockID from monitor with shorter timeout
                            let waitTime = 0;
                            while (!blockId && waitTime < 10000) {
                                if (monitoredTransactions.has(txid)) {
                                    blockId = monitoredTransactions.get(txid).blockId;
                                    break;
                                }
                                await new Promise(resolve => setTimeout(resolve, 500));
                                waitTime += 500;
                            }
                            
                            // Fallback to Explorer API
                            if (!blockId) {
                                log(`WebSocketå¾…æ©Ÿã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã€Explorer APIã‚’ä½¿ç”¨`);
                                const apiUrl = `https://api-tn10.kaspa.org/transactions/${txid}`;
                                const response = await fetch(apiUrl);
                                if (response.ok) {
                                    const data = await response.json();
                                    blockId = data.block_hash?.[0] || data.accepting_block_hash;
                                }
                            }
                            
                            if (!blockId) {
                                throw new Error('BlockIDå–å¾—å¤±æ•—');
                            }
                            
                            // Update status
                            document.getElementById(`chunk-status-${i}`).innerHTML = '<span class="success">âœ… å®Œäº†</span>';
                            
                            // Store chunk info
                            processedChunks.push({
                                index: i,
                                txid: txid,
                                blockId: blockId,
                                originalSize: chunk.length,
                                compressedSize: compressed.length,
                                payloadSize: payloadBytes.length,
                                uploadedAt: Date.now()
                            });
                            
                            break;
                            
                        } catch (error) {
                            retries++;
                            log(`Chunk ${i + 1} ã‚¨ãƒ©ãƒ¼ (è©¦è¡Œ ${retries}/${config.retryCount}): ${error.message || error}`, 'error');
                            console.error('Full error:', error);
                            if (retries >= config.retryCount) {
                                document.getElementById(`chunk-status-${i}`).innerHTML = '<span class="error">âŒ å¤±æ•—</span>';
                                throw error;
                            }
                            await new Promise(resolve => setTimeout(resolve, 2000));
                        }
                    }
                    
                    // Update progress
                    const progress = ((i + 1) / chunks * 100).toFixed(0);
                    document.getElementById('uploadProgressBar').style.width = progress + '%';
                    document.getElementById('uploadProgressBar').textContent = progress + '%';
                }
                
                // Calculate cost
                const totalPayloadKB = processedChunks.reduce((sum, c) => sum + c.payloadSize, 0) / 1024;
                const totalCost = chunks * 0.00005 + totalPayloadKB * 0.00001;
                
                // Prepare metadata
                kaspaMetadata = {
                    version: "2.0",
                    kaspa: {
                        network: config.network,
                        sdkVersion: "1.0.0"
                    },
                    file: {
                        name: currentFile.name,
                        size: currentFile.size,
                        mimeType: currentFile.type || 'application/octet-stream',
                        sha256: fileHash
                    },
                    encryption: {
                        algorithm: "AES-256-GCM",
                        pbkdf2: {
                            iterations: 10000,
                            salt: toBase64(salt)
                        }
                    },
                    compression: {
                        algorithm: useCompression ? "LZ77" : "none",
                        enabled: useCompression
                    },
                    chunks: processedChunks.map(c => ({
                        index: c.index,
                        txid: c.txid,
                        blockId: c.blockId,
                        originalSize: c.originalSize,
                        compressedSize: c.compressedSize,
                        payloadSize: c.payloadSize,
                        uploadedAt: c.uploadedAt
                    })),
                    metadata: {
                        createdAt: Date.now(),
                        totalChunks: chunks,
                        totalKAS: totalCost,
                        uploadedBy: address.toString()
                    }
                };
                
                // Save to history
                uploadHistory.push({
                    filename: currentFile.name,
                    timestamp: Date.now(),
                    metadata: kaspaMetadata
                });
                
                log(`ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å®Œäº†! ç·ã‚³ã‚¹ãƒˆ: ${totalCost.toFixed(5)} KAS`, 'success');
                
                // Check if meta-tx option is enabled
                const useMetaTx = document.getElementById('useMetaTx').checked;
                if (useMetaTx) {
                    await createAndUploadMetaTx();
                } else {
                    document.getElementById('generateKaspaSection').style.display = 'block';
                }
                
            } catch (error) {
                log(`ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            } finally {
                document.getElementById('uploadBtn').disabled = false;
            }
        };

        // Generate .kaspa file
        window.generateKaspaFile = function() {
            if (!kaspaMetadata) {
                log('.kaspaãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“', 'error');
                return;
            }
            
            try {
                const includePassword = document.getElementById('includePassword').checked;
                const kaspaData = JSON.parse(JSON.stringify(kaspaMetadata));
                
                if (includePassword && currentPassword) {
                    kaspaData.auth = {
                        passwordIncluded: true,
                        password: currentPassword,
                        warning: "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯å¹³æ–‡ã§ä¿å­˜ã•ã‚Œã¦ã„ã¾ã™ã€‚ä¿¡é ¼ã§ãã‚‹ç›¸æ‰‹ã¨ã®ã¿å…±æœ‰ã—ã¦ãã ã•ã„ã€‚"
                    };
                    log('âš ï¸ ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒ.kaspaãƒ•ã‚¡ã‚¤ãƒ«ã«å«ã¾ã‚Œã¦ã„ã¾ã™', 'warning');
                }
                
                const kaspaFileContent = JSON.stringify(kaspaData, null, 2);
                const blob = new Blob([kaspaFileContent], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = currentFile.name + '.kaspa';
                a.click();
                
                URL.revokeObjectURL(url);
                
                document.getElementById('kaspaResult').innerHTML = `
                    <div class="metric-box">
                        <h4 class="success">âœ… .kaspaãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆå®Œäº†</h4>
                        <p>ãƒ•ã‚¡ã‚¤ãƒ«å: ${currentFile.name}.kaspa</p>
                        <p>ã‚µã‚¤ã‚º: ${(kaspaFileContent.length/1024).toFixed(1)}KB</p>
                        ${includePassword ? '<p class="warning">âš ï¸ ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒå«ã¾ã‚Œã¦ã„ã¾ã™</p>' : ''}
                    </div>
                `;
                
                log('.kaspaãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸ', 'success');
                
            } catch (error) {
                log(`.kaspaãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        // Create and upload meta transaction
        window.createAndUploadMetaTx = async function() {
            try {
                log('ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ä½œæˆã‚’é–‹å§‹ã—ã¾ã™...', 'info');
                
                // Prepare meta-tx data (similar to .kaspa file but with version 2.1)
                const metaTxData = {
                    version: "2.1",
                    type: "kaspa-meta-tx",
                    kaspa: kaspaMetadata.kaspa,
                    file: kaspaMetadata.file,
                    encryption: kaspaMetadata.encryption,
                    compression: kaspaMetadata.compression,
                    chunks: kaspaMetadata.chunks,
                    metadata: kaspaMetadata.metadata
                };
                
                // Encrypt meta-tx data with the same password
                const metaDataString = JSON.stringify(metaTxData);
                const metaDataBytes = new TextEncoder().encode(metaDataString);
                
                // Use the same salt and key from file encryption
                const salt = fromBase64(kaspaMetadata.encryption.pbkdf2.salt);
                const key = await deriveKey(currentPassword, salt);
                
                // Encrypt with chunk index -1 to indicate meta-tx
                const encryptedMetaData = await encryptChunk(metaDataBytes, key, -1);
                
                // Prepend salt to encrypted data for self-contained decryption
                const metaPayload = new Uint8Array(salt.length + encryptedMetaData.length);
                metaPayload.set(salt, 0);
                metaPayload.set(encryptedMetaData, salt.length);
                
                log(`ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚º: ${metaDataBytes.length} bytes â†’ æš—å·åŒ–å¾Œ: ${metaPayload.length} bytes (saltå«ã‚€)`);
                
                // Upload meta-tx to blockchain
                const utxoResponse = await rpcClient.getUtxosByAddresses([address.toString()]);
                const entries = utxoResponse.entries || [];
                
                log(`${entries.length} UTXOs available for meta-tx`);
                
                const formattedUtxos = entries.map(utxo => {
                    try {
                        return {
                            address: address.toString(),
                            outpoint: {
                                transactionId: utxo.outpoint.transactionId,
                                index: utxo.outpoint.index
                            },
                            scriptPublicKey: utxo.scriptPublicKey,
                            amount: BigInt(utxo.amount),
                            isCoinbase: utxo.isCoinbase || false,
                            blockDaaScore: BigInt(utxo.blockDaaScore)
                        };
                    } catch (e) {
                        log(`UTXO formatting error: ${e.message}`, 'error');
                        console.error('UTXO:', utxo);
                        throw e;
                    }
                });
                
                log(`Creating meta-tx with ${formattedUtxos.length} UTXOs, payload size: ${metaPayload.length} bytes`);
                
                let result;
                try {
                    // Use same amount as regular chunks (1 KAS)
                    const amount = 100000000n; // 1 KAS
                    
                    result = await kaspa.createTransactions({
                        entries: formattedUtxos,
                        outputs: [{
                            address: address.toString(),
                            amount: amount
                        }],
                        changeAddress: address.toString(),
                        priorityFee: 10000n,
                        networkId: config.network,
                        payload: metaPayload
                    });
                } catch (e) {
                    log(`createTransactions error: ${e.message || e}`, 'error');
                    throw e;
                }
                
                if (!result) {
                    throw new Error('createTransactions returned null/undefined');
                }
                
                if (!result.transactions || result.transactions.length === 0) {
                    throw new Error('ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ç”Ÿæˆå¤±æ•— - no transactions in result');
                }
                
                const pendingTx = result.transactions[0];
                await pendingTx.sign([privateKey]);
                const metaTxId = await pendingTx.submit(rpcClient);
                
                log(`ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’é€ä¿¡ã—ã¾ã—ãŸ: ${metaTxId}`, 'success');
                
                // Wait for BlockID from WebSocket monitor
                log(`ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®BlockIDã‚’å¾…æ©Ÿä¸­...`);
                let metaBlockId = null;
                let waitTime = 0;
                const maxWaitTime = 30000; // 30 seconds max
                
                while (!metaBlockId && waitTime < maxWaitTime) {
                    if (monitoredTransactions.has(metaTxId)) {
                        metaBlockId = monitoredTransactions.get(metaTxId).blockId;
                        break;
                    }
                    await new Promise(resolve => setTimeout(resolve, 500));
                    waitTime += 500;
                }
                
                let metaTxReference = metaTxId;
                if (metaBlockId) {
                    log(`BlockIDå–å¾—æˆåŠŸ: ${metaBlockId}`, 'success');
                    metaTxReference = `${metaTxId}:${metaBlockId}`;
                } else {
                    log(`BlockIDå–å¾—ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ - ãƒ¡ã‚¿TxIDã®ã¿ã§ä¿å­˜`, 'warning');
                }
                
                // Show meta-tx result
                document.getElementById('generateKaspaSection').innerHTML = `
                    <div class="container" style="background: #1a3d2e; border: 2px solid #49EACB;">
                        <h3>ğŸ‰ ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ä½œæˆå®Œäº†ï¼</h3>
                        <div class="metric-box">
                            <p><strong>${metaBlockId ? 'ãƒ¡ã‚¿TxID + BlockID:' : 'ãƒ¡ã‚¿TxID:'}</strong></p>
                            <p style="word-break: break-all; font-family: monospace; color: #49EACB; font-size: 12px;">${metaTxReference}</p>
                            <button onclick="navigator.clipboard.writeText('${metaTxReference}').then(() => log('ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ', 'success'))">
                                ğŸ“‹ ã‚³ãƒ”ãƒ¼
                            </button>
                        </div>
                        <div class="info">
                            <p>ã“ã®${metaBlockId ? 'TxID:BlockID' : 'ãƒ¡ã‚¿TxID'}ã¨ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã ã‘ã§ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å¾©å…ƒã§ãã¾ã™ã€‚</p>
                            <p>.kaspaãƒ•ã‚¡ã‚¤ãƒ«ã¯ä¸è¦ã§ã™ï¼</p>
                            ${metaBlockId ? '<p class="success">âœ… REST APIä¸è¦ã§å¾©å…ƒå¯èƒ½</p>' : '<p class="warning">âš ï¸ REST APIãŒå¿…è¦ã§ã™</p>'}
                        </div>
                        <button onclick="generateKaspaFile()" style="margin-top: 10px;">
                            ğŸ“„ å¿µã®ãŸã‚.kaspaãƒ•ã‚¡ã‚¤ãƒ«ã‚‚ç”Ÿæˆ
                        </button>
                    </div>
                `;
                document.getElementById('generateKaspaSection').style.display = 'block';
                
                // Add meta-tx to metadata for .kaspa file generation
                kaspaMetadata.metaTx = {
                    txid: metaTxId,
                    blockId: metaBlockId,
                    reference: metaTxReference,
                    createdAt: Date.now()
                };
                
            } catch (error) {
                log(`ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ä½œæˆã‚¨ãƒ©ãƒ¼: ${error.message || error}`, 'error');
                console.error('Meta-tx creation error:', error);
                
                // Try to log more details
                if (error.stack) {
                    console.error('Error stack:', error.stack);
                }
                
                // Fallback to normal .kaspa generation
                document.getElementById('generateKaspaSection').style.display = 'block';
            }
        };

        // Load .kaspa file
        window.loadKaspaFile = async function(event) {
            log('=== loadKaspaFile é–‹å§‹ ===', 'info');
            log(`event: ${event}`, 'info');
            log(`event.target: ${event?.target}`, 'info');
            log(`event.target.files: ${event?.target?.files}`, 'info');
            log(`files.length: ${event?.target?.files?.length || 0}`, 'info');
            
            const file = event?.target?.files?.[0];
            log(`file: ${file}`, 'info');
            
            if (file) {
                log(`file.name: ${file.name}`, 'info');
                log(`file.type: ${file.type}`, 'info');
                log(`file.size: ${file.size} bytes`, 'info');
                log(`endsWith('.kaspa'): ${file.name.endsWith('.kaspa')}`, 'info');
                log(`toLowerCase().endsWith('.kaspa'): ${file.name.toLowerCase().endsWith('.kaspa')}`, 'info');
            }
            
            if (!file || !file.name.endsWith('.kaspa')) {
                log('æœ‰åŠ¹ãª.kaspaãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„', 'error');
                log(`ç†ç”±: file=${!!file}, name=${file?.name}, endsWith=${file?.name?.endsWith('.kaspa')}`, 'error');
                return;
            }
            
            try {
                log('ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã‚’èª­ã¿è¾¼ã¿ä¸­...', 'info');
                const content = await file.text();
                log(`ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã®é•·ã•: ${content.length} æ–‡å­—`, 'info');
                log(`æœ€åˆã®100æ–‡å­—: ${content.substring(0, 100)}...`, 'info');
                
                kaspaMetadata = JSON.parse(content);
                log('JSON parseæˆåŠŸ', 'info');
                log(`kaspaMetadata.version: ${kaspaMetadata.version}`, 'info');
                log(`kaspaMetadata.chunks: ${kaspaMetadata.chunks?.length || 0} chunks`, 'info');
                
                if (!kaspaMetadata.version || !kaspaMetadata.chunks) {
                    throw new Error('ç„¡åŠ¹ãª.kaspaãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼');
                }
                
                document.getElementById('fileInfo').textContent = 
                    `ãƒ•ã‚¡ã‚¤ãƒ«: ${kaspaMetadata.file.name}\n` +
                    `ã‚µã‚¤ã‚º: ${(kaspaMetadata.file.size/1024/1024).toFixed(2)}MB\n` +
                    `ãƒãƒ£ãƒ³ã‚¯: ${kaspaMetadata.chunks.length}\n` +
                    `ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯: ${kaspaMetadata.kaspa.network}\n` +
                    `ä½œæˆæ—¥æ™‚: ${new Date(kaspaMetadata.metadata.createdAt).toLocaleString()}\n` +
                    `ã‚³ã‚¹ãƒˆ: ${kaspaMetadata.metadata.totalKAS.toFixed(5)} KAS`;
                
                // Handle password
                const passwordSection = document.getElementById('passwordSection');
                if (kaspaMetadata.auth?.passwordIncluded) {
                    // Keep the password input field but hide it
                    document.getElementById('downloadPassword').style.display = 'none';
                    document.getElementById('downloadPassword').value = kaspaMetadata.auth.password;
                    
                    // Show info message
                    const infoDiv = document.createElement('div');
                    infoDiv.className = 'metric-box';
                    infoDiv.innerHTML = '<p class="success">âœ… ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯.kaspaãƒ•ã‚¡ã‚¤ãƒ«ã«å«ã¾ã‚Œã¦ã„ã¾ã™</p>';
                    passwordSection.insertBefore(infoDiv, passwordSection.firstChild);
                } else {
                    // Show password input
                    document.getElementById('downloadPassword').style.display = 'block';
                }
                
                document.getElementById('downloadSection').style.display = 'block';
                log('.kaspaãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ', 'success');
                
            } catch (error) {
                log(`.kaspaãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        // Load from Meta-TxID
        window.loadFromMetaTxId = async function() {
            const metaTxIdInput = document.getElementById('metaTxIdInput').value.trim();
            const password = document.getElementById('metaTxPassword').value;
            
            // Check if input contains BlockID (format: txid:blockid)
            let metaTxId, blockId;
            if (metaTxIdInput.includes(':')) {
                const parts = metaTxIdInput.split(':');
                metaTxId = parts[0];
                blockId = parts[1];
                log(`TxID:BlockIDå½¢å¼ã§å¾©å…ƒ: ${metaTxId.substring(0, 16)}...:${blockId.substring(0, 16)}...`, 'info');
            } else {
                metaTxId = metaTxIdInput;
                blockId = null;
                log(`ãƒ¡ã‚¿TxIDã®ã¿ã§å¾©å…ƒï¼ˆREST APIä½¿ç”¨ï¼‰: ${metaTxId.substring(0, 16)}...`, 'info');
            }
            
            if (!metaTxId || metaTxId.length !== 64) {
                log('æœ‰åŠ¹ãªãƒ¡ã‚¿TxIDï¼ˆ64æ–‡å­—ï¼‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', 'error');
                return;
            }
            
            if (blockId && blockId.length !== 64) {
                log('æœ‰åŠ¹ãªBlockIDï¼ˆ64æ–‡å­—ï¼‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', 'error');
                return;
            }
            
            if (!password) {
                log('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', 'error');
                return;
            }
            
            if (!rpcClient) {
                log('å…ˆã«ã‚·ã‚¹ãƒ†ãƒ ã‚’åˆæœŸåŒ–ã—ã¦ãã ã•ã„', 'error');
                return;
            }
            
            try {
                // Get transaction from blockchain
                let payload = null;
                
                // If we have BlockID, use RPC directly (no REST API needed)
                if (blockId) {
                    log(`BlockIDã‚’ä½¿ç”¨ã—ã¦RPCçµŒç”±ã§å–å¾—ä¸­...`, 'info');
                    try {
                        const blockResponse = await rpcClient.getBlock({
                            hash: blockId,
                            includeTransactions: true
                        });
                        
                        const block = blockResponse?.block?.block || blockResponse?.block;
                        if (!block) {
                            throw new Error(`ãƒ–ãƒ­ãƒƒã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${blockId}`);
                        }
                        
                        // Find the meta transaction in the block
                        for (const tx of block.transactions || []) {
                            const txId = tx.verboseData?.transactionId || tx.id || tx.transactionId;
                            if (txId === metaTxId) {
                                if (tx.payload && tx.payload !== '') {
                                    const hexPayload = tx.payload;
                                    payload = new Uint8Array(hexPayload.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
                                    log(`ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã‹ã‚‰å–å¾—: ${payload.length} bytes`, 'success');
                                    break;
                                }
                            }
                        }
                        
                        if (!payload) {
                            throw new Error(`ãƒ–ãƒ­ãƒƒã‚¯å†…ã«ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
                        }
                    } catch (rpcError) {
                        log(`RPCã‚¨ãƒ©ãƒ¼: ${rpcError.message}`, 'error');
                        throw rpcError;
                    }
                } else {
                    // Fall back to REST API if no BlockID provided
                    log(`ãƒ¡ã‚¿TxID ${metaTxId.substring(0, 16)}... ã‹ã‚‰REST APIçµŒç”±ã§å¾©å…ƒã‚’é–‹å§‹`, 'info');
                    
                    try {
                    // First try to get via Explorer API (more reliable)
                    log('Explorer APIçµŒç”±ã§ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’å–å¾—ä¸­...', 'info');
                    const apiUrl = `https://api-tn10.kaspa.org/transactions/${metaTxId}`;
                    const response = await fetch(apiUrl);
                    
                    if (response.ok) {
                        const data = await response.json();
                        
                        log(`Transaction data received, checking for payload...`, 'info');
                        
                        // First, check if there's a direct payload field
                        if (data.payload) {
                            log(`Found direct payload field, length: ${data.payload.length} chars`, 'info');
                            log(`Payload preview: ${data.payload.substring(0, 100)}...`, 'info');
                            
                            // The payload is a hex string, convert it to bytes
                            const hexString = data.payload;
                            
                            // Check if it's valid hex
                            if (!/^[0-9a-fA-F]+$/.test(hexString)) {
                                log('Warning: Payload contains non-hex characters', 'warning');
                            }
                            
                            // The blockchain returns the payload as hex, decode it directly
                            // Same as chunk download (line 1746)
                            payload = new Uint8Array(hexString.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
                            log(`Decoded payload: ${payload.length} bytes`, 'info');
                            
                        } else if (data.outputs && data.outputs.length > 0) {
                            // Extract payload from transaction outputs
                            log(`Checking ${data.outputs.length} outputs for payload...`, 'info');
                            
                            for (let i = 0; i < data.outputs.length; i++) {
                                const output = data.outputs[i];
                                log(`Output ${i}: type=${output.script_public_key_type}, script length=${output.script_public_key?.length || 0}`, 'info');
                                
                                if (output.script_public_key_type === 'pubkey' && output.script_public_key) {
                                    const scriptHex = output.script_public_key;
                                    
                                    // In Kaspa, payload transactions have a different script structure
                                    // The script should contain the payload data embedded
                                    if (scriptHex.length > 140) {
                                        log(`Found long script (${scriptHex.length} chars), attempting to extract payload...`, 'info');
                                        log(`Script preview: ${scriptHex.substring(0, 100)}...`, 'info');
                                        
                                        // Try different extraction methods
                                        // Method 1: Skip first 4 chars and last 68 chars
                                        const payloadHex = scriptHex.substring(4, scriptHex.length - 68);
                                        payload = new Uint8Array(payloadHex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
                                        log(`Extracted payload size: ${payload.length} bytes`, 'info');
                                        break;
                                    }
                                }
                            }
                        }
                        
                        // Check if we have transaction with payload in a different format
                        if (!payload && data.subnetwork_id === "0000000000000000000000000000000000000000") {
                            log(`Checking for payload in transaction data...`, 'info');
                            console.log('Full transaction data:', data);
                        }
                    }
                } catch (apiError) {
                    log(`Explorer APIã‚¨ãƒ©ãƒ¼: ${apiError.message}`, 'warning');
                }
                
                // If Explorer API failed or payload is incomplete, try RPC
                if (!payload || payload.length < 100) {
                    log('Explorer APIã®ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ãŒä¸å®Œå…¨ã€RPCçµŒç”±ã§å†è©¦è¡Œ...', 'warning');
                    
                    try {
                        // Get transaction via RPC
                        const txResponse = await rpcClient.getTransaction({
                            transactionId: metaTxId,
                            includeBlockInfo: true
                        });
                        
                        if (txResponse && txResponse.transaction) {
                            log('RPCçµŒç”±ã§ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å–å¾—æˆåŠŸ', 'info');
                            
                            // Extract payload from transaction
                            const tx = txResponse.transaction;
                            if (tx.payload) {
                                // RPC might return hex or base64 encoded payload
                                // Check if it's hex
                                if (/^[0-9a-fA-F]+$/.test(tx.payload)) {
                                    payload = new Uint8Array(tx.payload.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
                                    log(`RPC hex payload: ${payload.length} bytes`, 'info');
                                } else {
                                    // Assume base64
                                    payload = fromBase64(tx.payload);
                                    log(`RPC base64 payload: ${payload.length} bytes`, 'info');
                                }
                            } else if (tx.verboseData && tx.verboseData.payload) {
                                if (/^[0-9a-fA-F]+$/.test(tx.verboseData.payload)) {
                                    payload = new Uint8Array(tx.verboseData.payload.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
                                    log(`RPC verbose hex payload: ${payload.length} bytes`, 'info');
                                } else {
                                    payload = fromBase64(tx.verboseData.payload);
                                    log(`RPC verbose base64 payload: ${payload.length} bytes`, 'info');
                                }
                            }
                        }
                    } catch (rpcError) {
                        log(`RPCå–å¾—ã‚¨ãƒ©ãƒ¼: ${rpcError.message}`, 'error');
                    }
                }
                }
                
                if (!payload) {
                    throw new Error('ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                }
                
                log(`ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰å–å¾—æˆåŠŸ: ${payload.length} bytes`, 'info');
                
                // Try to decrypt the payload
                try {
                    // First, try to derive key with a temporary salt (we'll get the real salt from decrypted data)
                    // Use the metaTxId as a deterministic salt source for the first attempt
                    const tempSalt = new Uint8Array(16);
                    for (let i = 0; i < 16; i++) {
                        tempSalt[i] = parseInt(metaTxId.substr(i * 2, 2), 16);
                    }
                    
                    // Try decrypting with chunk index -1 (meta-tx indicator)
                    let decrypted;
                    let metaData;
                    
                    // We need to try different approaches since we don't have the salt yet
                    // The actual implementation would need to extract salt from the encrypted data
                    // or use a standardized approach
                    
                    // For now, let's try to extract the salt from the beginning of the payload
                    if (payload.length > 16) {
                        const salt = payload.slice(0, 16);
                        const encryptedData = payload.slice(16);
                        
                        const key = await deriveKey(password, salt);
                        
                        try {
                            log(`Attempting to decrypt with salt (${salt.length} bytes) and encrypted data (${encryptedData.length} bytes)`, 'info');
                            decrypted = await decryptChunk(encryptedData, key, -1);
                            const metaDataString = new TextDecoder().decode(decrypted);
                            log(`Decrypted string preview: ${metaDataString.substring(0, 50)}...`, 'info');
                            metaData = JSON.parse(metaDataString);
                        } catch (e) {
                            log('å¾©å·åŒ–å¤±æ•— - ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒé–“é•ã£ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™', 'error');
                            log(`Decryption error details: ${e.message || e}`, 'error');
                            console.error('Decryption error:', e);
                            
                            // Log first few bytes of payload for debugging
                            const payloadPreview = Array.from(payload.slice(0, 32)).map(b => b.toString(16).padStart(2, '0')).join(' ');
                            log(`Payload hex preview: ${payloadPreview}`, 'info');
                            throw e;
                        }
                    } else {
                        throw new Error('ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ãŒçŸ­ã™ãã¾ã™');
                    }
                    
                    // Verify this is a meta-tx
                    if (metaData.version === "2.1" && metaData.type === "kaspa-meta-tx") {
                        log('ãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’æ­£å¸¸ã«å¾©å·åŒ–ã—ã¾ã—ãŸ', 'success');
                        
                        // Set kaspaMetadata from meta-tx data
                        kaspaMetadata = {
                            version: "2.0", // Convert back to standard format
                            kaspa: metaData.kaspa,
                            file: metaData.file,
                            encryption: metaData.encryption,
                            compression: metaData.compression,
                            chunks: metaData.chunks,
                            metadata: metaData.metadata,
                            metaTx: {
                                txid: metaTxId,
                                loadedAt: Date.now()
                            }
                        };
                        
                        // Show file info
                        document.getElementById('fileInfo').textContent = 
                            `ãƒ•ã‚¡ã‚¤ãƒ«å: ${kaspaMetadata.file.name}\n` +
                            `ã‚µã‚¤ã‚º: ${(kaspaMetadata.file.size / 1024).toFixed(1)} KB\n` +
                            `ãƒãƒ£ãƒ³ã‚¯æ•°: ${kaspaMetadata.chunks.length}\n` +
                            `æš—å·åŒ–: ${kaspaMetadata.encryption.algorithm}\n` +
                            `åœ§ç¸®: ${kaspaMetadata.compression.enabled ? kaspaMetadata.compression.algorithm : 'ãªã—'}\n` +
                            `ä½œæˆæ—¥æ™‚: ${new Date(kaspaMetadata.metadata.createdAt).toLocaleString()}\n` +
                            `ãƒ¡ã‚¿TxID: ${metaTxId.substring(0, 16)}...`;
                        
                        // Set password for download
                        document.getElementById('downloadPassword').value = password;
                        document.getElementById('downloadPassword').style.display = 'none';
                        
                        // Show download section
                        document.getElementById('downloadSection').style.display = 'block';
                        
                        log('ãƒ¡ã‚¿TxIDã‹ã‚‰ã®å¾©å…ƒæº–å‚™å®Œäº†ï¼ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚', 'success');
                        
                    } else {
                        throw new Error('ã“ã‚Œã¯æœ‰åŠ¹ãªãƒ¡ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã‚ã‚Šã¾ã›ã‚“');
                    }
                    
                } catch (error) {
                    log(`å¾©å·åŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                    throw error;
                }
                
            } catch (error) {
                log(`ãƒ¡ã‚¿TxIDå¾©å…ƒã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        // Download file
        window.downloadFile = async function() {
            let password = document.getElementById('downloadPassword').value;
            
            if (kaspaMetadata.auth?.passwordIncluded && kaspaMetadata.auth?.password) {
                password = kaspaMetadata.auth.password;
            }
            
            if (!password) {
                log('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', 'error');
                return;
            }
            
            if (!kaspaMetadata) {
                log('.kaspaãƒ•ã‚¡ã‚¤ãƒ«ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“', 'error');
                return;
            }
            
            if (!rpcClient) {
                log('å…ˆã«ã‚·ã‚¹ãƒ†ãƒ ã‚’åˆæœŸåŒ–ã—ã¦ãã ã•ã„', 'error');
                return;
            }
            
            document.getElementById('downloadProgress').style.display = 'block';
            
            try {
                log(`ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰é–‹å§‹: ${kaspaMetadata.file.name}`);
                
                // Derive key
                const salt = fromBase64(kaspaMetadata.encryption.pbkdf2.salt);
                const key = await deriveKey(password, salt);
                
                const chunks = [];
                
                for (let i = 0; i < kaspaMetadata.chunks.length; i++) {
                    const chunkMeta = kaspaMetadata.chunks[i];
                    
                    document.getElementById('downloadStatus').textContent = 
                        `ãƒãƒ£ãƒ³ã‚¯ ${i + 1}/${kaspaMetadata.chunks.length} ã‚’å–å¾—ä¸­...`;
                    
                    try {
                        log(`ãƒãƒ£ãƒ³ã‚¯ ${i + 1}: BlockID ${chunkMeta.blockId.substring(0, 16)}...`, 'info');
                        
                        // Get block data
                        const request = { 
                            hash: chunkMeta.blockId, 
                            includeTransactions: true 
                        };
                        log(`RPC getBlock request: ${JSON.stringify(request)}`, 'info');
                        
                        let response;
                        try {
                            response = await rpcClient.getBlock(request);
                            log(`RPC getBlock response received`, 'info');
                            log(`Response type: ${typeof response}`, 'info');
                            log(`Response keys: ${Object.keys(response || {}).join(', ')}`, 'info');
                        } catch (rpcError) {
                            log(`RPC getBlock error: ${rpcError.message || rpcError}`, 'error');
                            log(`Error type: ${rpcError.constructor.name}`, 'error');
                            throw rpcError;
                        }
                        
                        const block = response?.block?.block || response?.block;
                        log(`Block extracted: ${!!block}`, 'info');
                        
                        if (!block) {
                            log(`Block not found in response structure`, 'error');
                            throw new Error(`ãƒ–ãƒ­ãƒƒã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${chunkMeta.blockId}`);
                        }
                        
                        // Find transaction with matching TxID
                        let payload = null;
                        const txCount = block.transactions?.length || 0;
                        log(`ãƒ–ãƒ­ãƒƒã‚¯å†…ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³æ•°: ${txCount}`, 'info');
                        
                        if (txCount === 0) {
                            log(`è­¦å‘Š: ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãŒå«ã¾ã‚Œã¦ã„ã¾ã›ã‚“`, 'warning');
                            // BigIntã‚’å«ã‚€å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã§JSON.stringifyã¯é¿ã‘ã‚‹
                            log(`Block has header.hash: ${block.header?.hash}`, 'warning');
                        }
                        
                        for (const tx of block.transactions || []) {
                            // BigIntã‚’å«ã‚€å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã§JSON.stringifyã¯é¿ã‘ã‚‹
                            log(`Checking transaction...`, 'info');
                            const txId = tx.verboseData?.transactionId || tx.id || tx.transactionId;
                            log(`Transaction ID variants: verboseData.transactionId=${tx.verboseData?.transactionId}, tx.id=${tx.id}, tx.transactionId=${tx.transactionId}`, 'info');
                            
                            if (txId === chunkMeta.txid) {
                                log(`TxIDä¸€è‡´: ${txId.substring(0, 16)}...`, 'info');
                                log(`tx.payload exists: ${!!tx.payload}, length: ${tx.payload?.length || 0}`, 'info');
                                
                                if (tx.payload && tx.payload !== '') {
                                    // Get raw binary payload from hex (blockchain stores as hex)
                                    const hexPayload = tx.payload;
                                    log(`ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰é•·: ${hexPayload.length} æ–‡å­— (hex)`, 'info');
                                    log(`æœ€åˆã®100æ–‡å­—: ${hexPayload.substring(0, 100)}...`, 'info');
                                    
                                    // Blockchain stores binary payloads as hex strings
                                    try {
                                        payload = new Uint8Array(hexPayload.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
                                        log(`Hex decodeæˆåŠŸ: ${payload.length} ãƒã‚¤ãƒˆ (ç”Ÿãƒã‚¤ãƒŠãƒª)`, 'info');
                                    } catch (e) {
                                        log(`Hex decode error details: ${e.stack || e}`, 'error');
                                        throw new Error(`ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ã®ãƒ‡ã‚³ãƒ¼ãƒ‰ã«å¤±æ•—: ${e.message}`);
                                    }
                                    break;
                                } else {
                                    log(`è­¦å‘Š: ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ãŒç©ºã§ã™ (TxID: ${txId})`, 'warning');
                                }
                            } else {
                                log(`TxIDä¸ä¸€è‡´: ${txId} !== ${chunkMeta.txid}`, 'info');
                            }
                        }
                        
                        if (!payload) {
                            throw new Error(`ãƒãƒ£ãƒ³ã‚¯ ${i + 1} ã®ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
                        }
                        
                        // Decrypt and decompress
                        const encrypted = payload; // Already binary Uint8Array
                        const compressed = await decryptChunk(encrypted, key, i);
                        const original = kaspaMetadata.compression.enabled ? lzDecompress(compressed) : compressed;
                        
                        chunks.push(original);
                        
                        // Update progress
                        const progress = ((i + 1) / kaspaMetadata.chunks.length * 100).toFixed(0);
                        document.getElementById('downloadProgressBar').style.width = progress + '%';
                        document.getElementById('downloadProgressBar').textContent = progress + '%';
                        
                        log(`ãƒãƒ£ãƒ³ã‚¯ ${i + 1} å–å¾—æˆåŠŸ`);
                        
                    } catch (error) {
                        log(`ãƒãƒ£ãƒ³ã‚¯ ${i + 1} ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                        throw error;
                    }
                }
                
                // Combine chunks
                const totalSize = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
                const combined = new Uint8Array(totalSize);
                let offset = 0;
                for (const chunk of chunks) {
                    combined.set(chunk, offset);
                    offset += chunk.length;
                }
                
                // Verify hash
                const downloadedHash = await sha256(combined);
                if (downloadedHash !== kaspaMetadata.file.sha256) {
                    throw new Error('ãƒ•ã‚¡ã‚¤ãƒ«æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯å¤±æ•—ï¼');
                }
                
                // Download
                const blob = new Blob([combined], { type: kaspaMetadata.file.mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = kaspaMetadata.file.name;
                a.click();
                URL.revokeObjectURL(url);
                
                log(`ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†: ${kaspaMetadata.file.name}`, 'success');
                
            } catch (error) {
                log(`ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        // WebSocket monitoring
        window.startMonitoring = async function() {
            if (!rpcClient) {
                log('å…ˆã«ã‚·ã‚¹ãƒ†ãƒ ã‚’åˆæœŸåŒ–ã—ã¦ãã ã•ã„', 'error');
                return;
            }
            
            if (wsMonitorActive) {
                monitorLog('ã™ã§ã«ç›£è¦–ä¸­ã§ã™', 'warning');
                return;
            }
            
            try {
                monitorLog('WebSocketç›£è¦–ã‚’é–‹å§‹...');
                wsMonitorActive = true;
                
                await rpcClient.subscribeBlockAdded();
                monitorLog('Block Addedã‚¤ãƒ™ãƒ³ãƒˆã‚’è³¼èª­ã—ã¾ã—ãŸ', 'success');
                
                document.getElementById('monitorStartTime').textContent = new Date().toLocaleString();
                
                rpcClient.addEventListener('block-added', (event) => {
                    const block = event.data.block;
                    const blockId = block.header.hash;
                    const blockTime = new Date(Number(block.header.timestamp));
                    
                    if (block.transactions && block.transactions.length > 0) {
                        for (const tx of block.transactions) {
                            const txId = tx.verboseData?.transactionId;
                            if (txId) {
                                monitoredTransactions.set(txId, {
                                    blockId: blockId,
                                    blockTime: blockTime,
                                    foundAt: new Date()
                                });
                                
                                if (tx.payload && tx.payload !== '') {
                                    monitorLog(`ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ä»˜ãTxæ¤œå‡º: ${txId}`, 'success');
                                }
                            }
                        }
                        
                        document.getElementById('monitoringCount').textContent = monitoredTransactions.size;
                        document.getElementById('detectedCount').textContent = monitoredTransactions.size;
                    }
                });
                
                monitorLog('ç›£è¦–ã‚’é–‹å§‹ã—ã¾ã—ãŸ', 'success');
                
            } catch (error) {
                monitorLog(`ç›£è¦–é–‹å§‹ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                wsMonitorActive = false;
            }
        };

        window.stopMonitoring = async function() {
            if (!wsMonitorActive) {
                monitorLog('ç›£è¦–ã¯é–‹å§‹ã•ã‚Œã¦ã„ã¾ã›ã‚“', 'warning');
                return;
            }
            
            try {
                if (rpcClient) {
                    await rpcClient.unsubscribeBlockAdded();
                    monitorLog('ç›£è¦–ã‚’åœæ­¢ã—ã¾ã—ãŸ', 'success');
                }
                wsMonitorActive = false;
                
            } catch (error) {
                monitorLog(`ç›£è¦–åœæ­¢ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        // Settings functions
        window.exportLogs = function() {
            const exportData = {
                timestamp: new Date().toISOString(),
                logs: systemLogs,
                uploadHistory: uploadHistory,
                monitoredTransactions: Array.from(monitoredTransactions.entries())
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `kaspa-p2p-logs-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            log('ãƒ­ã‚°ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ', 'success');
        };

        window.clearLogs = function() {
            if (confirm('ã™ã¹ã¦ã®ãƒ­ã‚°ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã‹ï¼Ÿ')) {
                systemLogs = [];
                document.getElementById('systemLog').innerHTML = '';
                document.getElementById('monitorLog').innerHTML = '';
                log('ãƒ­ã‚°ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ', 'info');
            }
        };

        window.copyLog = function() {
            const logText = systemLogs.map(log => 
                `[${log.time}] ${log.type.toUpperCase()}: ${log.message}`
            ).join('\n');
            
            navigator.clipboard.writeText(logText).then(() => {
                alert('ãƒ­ã‚°ã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ');
            });
        };

        // Drag and drop
        window.handleDragOver = function(e) {
            e.preventDefault();
            e.currentTarget.classList.add('dragover');
        };

        window.handleDragLeave = function(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('dragover');
        };

        window.handleKaspaDrop = function(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('dragover');
            
            log('=== handleKaspaDrop é–‹å§‹ ===', 'info');
            log(`e.dataTransfer.files: ${e.dataTransfer.files}`, 'info');
            log(`files.length: ${e.dataTransfer.files.length}`, 'info');
            
            const file = e.dataTransfer.files[0];
            log(`file: ${file}`, 'info');
            
            if (file) {
                log(`file.name: ${file.name}`, 'info');
                log(`file.type: ${file.type}`, 'info');
                log(`file.size: ${file.size} bytes`, 'info');
                log(`endsWith('.kaspa'): ${file.name.endsWith('.kaspa')}`, 'info');
            }
            
            if (file && file.name.endsWith('.kaspa')) {
                document.getElementById('kaspaFileInput').files = e.dataTransfer.files;
                loadKaspaFile({ target: { files: [file] } });
            } else {
                log('ãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã¯.kaspaãƒ•ã‚¡ã‚¤ãƒ«ã§ã¯ã‚ã‚Šã¾ã›ã‚“', 'error');
            }
        };

        // File upload drag and drop
        document.addEventListener('DOMContentLoaded', () => {
            const fileLabel = document.querySelector('.file-input-label');
            
            fileLabel.addEventListener('dragover', handleDragOver);
            fileLabel.addEventListener('dragleave', handleDragLeave);
            fileLabel.addEventListener('drop', (e) => {
                e.preventDefault();
                e.currentTarget.classList.remove('dragover');
                
                const file = e.dataTransfer.files[0];
                if (file) {
                    document.getElementById('fileInput').files = e.dataTransfer.files;
                    handleFileSelect({ target: { files: [file] } });
                }
            });
            
            // Update config from settings
            document.getElementById('networkSelect').addEventListener('change', (e) => {
                config.network = e.target.value;
                log(`ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å¤‰æ›´: ${config.network}`, 'info');
            });
            
            document.getElementById('retryCount').addEventListener('change', (e) => {
                config.retryCount = parseInt(e.target.value);
                log(`ãƒªãƒˆãƒ©ã‚¤å›æ•°å¤‰æ›´: ${config.retryCount}`, 'info');
            });
            
            document.getElementById('timeout').addEventListener('change', (e) => {
                config.timeout = parseInt(e.target.value) * 1000;
                log(`ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå¤‰æ›´: ${config.timeout/1000}ç§’`, 'info');
            });
            
            // Display upload history
            setInterval(() => {
                const historyDiv = document.getElementById('uploadHistory');
                if (uploadHistory.length > 0) {
                    historyDiv.innerHTML = uploadHistory.slice(-5).reverse().map(item => `
                        <div class="metric-box">
                            <strong>${item.filename}</strong><br>
                            ${new Date(item.timestamp).toLocaleString()}<br>
                            ${item.metadata.chunks.length} ãƒãƒ£ãƒ³ã‚¯
                        </div>
                    `).join('');
                } else {
                    historyDiv.innerHTML = '<p>ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å±¥æ­´ã¯ã‚ã‚Šã¾ã›ã‚“</p>';
                }
            }, 5000);
            
            // Debug: Add event listener to file input
            const kaspaFileInput = document.getElementById('kaspaFileInput');
            if (kaspaFileInput) {
                log('kaspaFileInputè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸ', 'info');
                kaspaFileInput.addEventListener('change', (e) => {
                    log('=== kaspaFileInput change event ===', 'info');
                    log(`Event fired, files: ${e.target.files?.length || 0}`, 'info');
                });
            } else {
                log('è­¦å‘Š: kaspaFileInputè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“', 'error');
            }
            
            log('ğŸš€ Kaspa P2P v2.0 æº–å‚™å®Œäº†ï¼', 'info');
            log('ã‚·ã‚¹ãƒ†ãƒ ã‚’åˆæœŸåŒ–ã—ã¦ãã ã•ã„', 'info');
        });
    </script>
</body>
</html>