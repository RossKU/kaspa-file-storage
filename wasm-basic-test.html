<!DOCTYPE html>
<html>
<head>
    <title>Kaspa WASM Basic Test</title>
    <style>
        body { font-family: monospace; padding: 20px; }
        .result { background: #f0f0f0; padding: 10px; margin: 10px 0; }
        .success { color: green; }
        .error { color: red; }
        button { padding: 10px 20px; margin: 5px; }
    </style>
</head>
<body>
    <h1>Kaspa WASM SDK Basic Tests</h1>
    
    <div>
        <button onclick="testBasicInitialization()">1. Test Basic Initialization</button>
        <button onclick="testPrivateKeyCreation()">2. Test PrivateKey Creation</button>
        <button onclick="testAddressGeneration()">3. Test Address Generation</button>
        <button onclick="testTransactionFunction()">4. Test Transaction Functions</button>
        <button onclick="testPayloadHandling()">5. Test Payload Handling</button>
        <button onclick="testDetailedTransaction()">6. Test Detailed Transaction</button>
        <button onclick="testCreateTransactionDebug()">7. Debug createTransaction</button>
    </div>
    
    <div class="result" id="testOutput"></div>

    <script type="module">
        let kaspa = null;
        let testResults = [];
        
        // テスト結果を表示する関数
        function logTest(testName, result, details = '') {
            const status = result ? '✅' : '❌';
            const message = `${status} ${testName}: ${result ? 'PASS' : 'FAIL'} ${details}`;
            testResults.push(message);
            console.log(message);
            updateDisplay();
        }
        
        function updateDisplay() {
            document.getElementById('testOutput').innerHTML = testResults.join('<br>');
        }
        
        // 基本初期化テスト
        window.testBasicInitialization = async function() {
            testResults = [];
            logTest('Starting WASM Basic Tests', true, 'v1.0.0-basic');
            
            try {
                logTest('Importing kaspa-core.js', true);
                kaspa = await import('./kaspa-core.js');
                logTest('Module imported', !!kaspa);
                
                logTest('Initializing WASM', true);
                await kaspa.default('./kaspa-core_bg.wasm');
                logTest('WASM initialized', true);
                
                // バージョン確認
                if (kaspa.version) {
                    const version = kaspa.version();
                    logTest('Version check', true, version);
                } else {
                    logTest('Version check', false, 'version() not found');
                }
                
                // 基本クラスの存在確認
                logTest('PrivateKey class exists', !!kaspa.PrivateKey);
                logTest('Transaction class exists', !!kaspa.Transaction);
                logTest('createTransaction function exists', !!kaspa.createTransaction);
                logTest('createTransactions function exists', !!kaspa.createTransactions);
                
                // グローバル変数設定（他のテストで使用）
                window.kaspaReady = true;
                
            } catch (error) {
                logTest('Initialization failed', false, error.message);
            }
        };
        
        // PrivateKey作成テスト
        window.testPrivateKeyCreation = async function() {
            if (!kaspa || !window.kaspaReady) {
                logTest('PrivateKey test skipped', false, 'WASM not initialized - run test 1 first');
                return;
            }
            
            // WASM完全初期化を待機
            if (!kaspa.PrivateKey) {
                logTest('PrivateKey test skipped', false, 'PrivateKey class not available');
                return;
            }
            
            try {
                // テスト用の既知の秘密鍵
                const testKeyHex = '1111111111111111111111111111111111111111111111111111111111111111';
                logTest('Creating PrivateKey from hex', true, testKeyHex.substring(0, 8) + '...');
                
                const privateKey = new kaspa.PrivateKey(testKeyHex);
                logTest('PrivateKey created', !!privateKey);
                
                // toString メソッドテスト
                if (privateKey.toString) {
                    const keyString = privateKey.toString();
                    logTest('PrivateKey.toString()', keyString === testKeyHex, keyString.substring(0, 8) + '...');
                } else {
                    logTest('PrivateKey.toString()', false, 'method not found');
                }
                
                // toKeypair メソッドテスト
                if (privateKey.toKeypair) {
                    const keypair = privateKey.toKeypair();
                    logTest('PrivateKey.toKeypair()', !!keypair);
                } else {
                    logTest('PrivateKey.toKeypair()', false, 'method not found');
                }
                
                window.testPrivateKey = privateKey; // 次のテスト用に保存
                
            } catch (error) {
                logTest('PrivateKey creation failed', false, error.message);
            }
        };
        
        // アドレス生成テスト
        window.testAddressGeneration = async function() {
            if (!kaspa || !window.kaspaReady || !window.testPrivateKey) {
                logTest('Address test skipped', false, 'Prerequisites not available - run tests 1-2 first');
                return;
            }
            
            try {
                const privateKey = window.testPrivateKey;
                
                // NetworkType確認
                logTest('NetworkType available', !!kaspa.NetworkType);
                
                if (kaspa.NetworkType) {
                    // Keypairからアドレス生成
                    const keypair = privateKey.toKeypair();
                    
                    if (keypair.toAddress) {
                        // メインネットアドレス
                        if (kaspa.NetworkType.Mainnet) {
                            const mainnetAddr = keypair.toAddress(kaspa.NetworkType.Mainnet);
                            logTest('Mainnet address', !!mainnetAddr, mainnetAddr ? mainnetAddr.toString().substring(0, 20) + '...' : '');
                        }
                        
                        // テストネットアドレス
                        if (kaspa.NetworkType.Testnet) {
                            const testnetAddr = keypair.toAddress(kaspa.NetworkType.Testnet);
                            logTest('Testnet address', !!testnetAddr, testnetAddr ? testnetAddr.toString().substring(0, 20) + '...' : '');
                        }
                    } else {
                        logTest('toAddress method', false, 'not found on keypair');
                    }
                } else {
                    logTest('NetworkType not found', false);
                }
                
            } catch (error) {
                logTest('Address generation failed', false, error.message);
            }
        };
        
        // トランザクション関数テスト
        window.testTransactionFunction = async function() {
            if (!kaspa) {
                logTest('Transaction test skipped', false, 'WASM not initialized');
                return;
            }
            
            try {
                // createTransaction関数の基本テスト
                logTest('createTransaction function type', typeof kaspa.createTransaction === 'function');
                
                if (kaspa.createTransaction) {
                    // 関数の長さ（パラメータ数）確認
                    logTest('createTransaction parameters', true, `expects ${kaspa.createTransaction.length} params`);
                }
                
                // createTransactions関数の基本テスト  
                logTest('createTransactions function type', typeof kaspa.createTransactions === 'function');
                
                if (kaspa.createTransactions) {
                    logTest('createTransactions parameters', true, `expects ${kaspa.createTransactions.length} params`);
                }
                
                // 実際の呼び出しテスト（エラーが予想される）
                try {
                    const result = kaspa.createTransaction([], [], 0n);
                    logTest('createTransaction call', !!result, 'unexpected success');
                } catch (error) {
                    logTest('createTransaction call', true, `expected error: ${error.message.substring(0, 50)}...`);
                }
                
            } catch (error) {
                logTest('Transaction function test failed', false, error.message);
            }
        };
        
        // ペイロード処理テスト
        window.testPayloadHandling = async function() {
            if (!kaspa) {
                logTest('Payload test skipped', false, 'WASM not initialized');
                return;
            }
            
            try {
                // テストペイロード作成
                const testText = 'Hello Kaspa!';
                const testPayloadBytes = new TextEncoder().encode(testText);
                logTest('Test payload created', true, `${testPayloadBytes.length} bytes`);
                
                // Hex変換テスト
                const testPayloadHex = Array.from(testPayloadBytes, b => b.toString(16).padStart(2, '0')).join('');
                logTest('Payload hex conversion', true, testPayloadHex);
                
                // ペイロード関連関数の確認と実際のテスト
                const hexFunctions = ['textToHex', 'hexToText', 'arrayBufferToHex', 'hexToArrayBuffer'];
                
                hexFunctions.forEach(fnName => {
                    logTest(`${fnName} function`, !!kaspa[fnName]);
                });
                
                // 実際のHex変換テスト
                if (kaspa.textToHex) {
                    try {
                        const hexResult = kaspa.textToHex(testText);
                        logTest('textToHex function', hexResult === testPayloadHex, hexResult);
                    } catch (e) {
                        logTest('textToHex function', false, e.message);
                    }
                }
                
                if (kaspa.hexToText) {
                    try {
                        const textResult = kaspa.hexToText(testPayloadHex);
                        logTest('hexToText function', textResult === testText, textResult);
                    } catch (e) {
                        logTest('hexToText function', false, e.message);
                    }
                }
                
                if (kaspa.arrayBufferToHex) {
                    try {
                        const hexResult = kaspa.arrayBufferToHex(testPayloadBytes);
                        logTest('arrayBufferToHex function', hexResult === testPayloadHex, hexResult);
                    } catch (e) {
                        logTest('arrayBufferToHex function', false, e.message);
                    }
                }
                
                if (kaspa.hexToArrayBuffer) {
                    try {
                        const bufferResult = kaspa.hexToArrayBuffer(testPayloadHex);
                        logTest('hexToArrayBuffer function', bufferResult.byteLength === testPayloadBytes.length, `${bufferResult.byteLength} bytes`);
                    } catch (e) {
                        logTest('hexToArrayBuffer function', false, e.message);
                    }
                }
                
            } catch (error) {
                logTest('Payload handling test failed', false, error.message);
            }
        };
        
        // 詳細なトランザクション作成テスト
        window.testDetailedTransaction = async function() {
            if (!kaspa || !window.testPrivateKey) {
                logTest('Detailed transaction test skipped', false, 'Prerequisites not met');
                return;
            }
            
            try {
                logTest('=== REAL TRANSACTION CREATION TEST ===', true);
                
                const privateKey = window.testPrivateKey;
                const keypair = privateKey.toKeypair();
                const address = keypair.toAddress(kaspa.NetworkType.Testnet);
                
                // Test different UTXO formats
                logTest('Test UTXO data prepared', true, '1 UTXOs');
                
                // Test different output formats
                logTest('Test output data prepared', true, '1 outputs');
                
                // Test payload
                const testPayload = 'Test file storage payload';
                const payloadHex = kaspa.textToHex ? kaspa.textToHex(testPayload) : '';
                logTest('Test payload prepared', true, `${testPayload.length} bytes`);
                
                // Test createTransaction with various parameter combinations
                logTest('Calling createTransaction with real data...', true);
                
                try {
                    // Method 1: Standard parameters
                    const result1 = kaspa.createTransaction([], [], address, 1000n, payloadHex);
                    logTest('createTransaction Method 1 (standard)', !!result1, 'success');
                } catch (e) {
                    logTest('createTransaction Method 1 (standard)', false, e.message.substring(0, 50));
                }
                
                try {
                    // Method 2: Object parameter
                    const result2 = kaspa.createTransaction({
                        utxos: [],
                        outputs: [],
                        changeAddress: address,
                        feeRate: 1000n,
                        payload: payloadHex
                    });
                    logTest('createTransaction Method 2 (object)', !!result2, 'success');
                } catch (e) {
                    logTest('createTransaction Method 2 (object)', false, e.message.substring(0, 50));
                }
                
                try {
                    // Method 3: createTransactions (multiple)
                    const result3 = kaspa.createTransactions({
                        utxos: [],
                        outputs: [],
                        changeAddress: address,
                        feeRate: 1000n,
                        payload: payloadHex
                    });
                    logTest('createTransactions method', !!result3, 'success');
                } catch (e) {
                    logTest('createTransactions method', false, e.message.substring(0, 50));
                }
                
                logTest('=== UTXO AND OUTPUT FORMAT TEST ===', true);
                
                // Test kaspaToSompi function
                if (kaspa.kaspaToSompi) {
                    try {
                        const sompi = kaspa.kaspaToSompi(1);
                        logTest('kaspaToSompi function', true, `1 KAS = ${sompi} sompi`);
                    } catch (e) {
                        logTest('kaspaToSompi function', false, e.message);
                    }
                }
                
                // Test Address constructor 
                if (kaspa.Address) {
                    try {
                        const addr = new kaspa.Address('kaspatest:qqk8m83ypfr4yg0ykaszpwjfm86c9vf22jgfg0jpc39h2k80nx8rxrumw8zpd');
                        logTest('Address constructor', !!addr, addr.toString().substring(0, 20) + '...');
                    } catch (e) {
                        logTest('Address constructor', false, e.message);
                    }
                }
                
                // Test PaymentOutput class
                if (kaspa.PaymentOutput) {
                    try {
                        const output = new kaspa.PaymentOutput(address, 100000000n);
                        logTest('PaymentOutput class', !!output);
                    } catch (e) {
                        logTest('PaymentOutput class', false, e.message);
                    }
                }
                
                // Test UtxoEntry class  
                if (kaspa.UtxoEntry) {
                    try {
                        const utxo = new kaspa.UtxoEntry();
                        logTest('UtxoEntry class', !!utxo);
                    } catch (e) {
                        logTest('UtxoEntry class', false, e.message);
                    }
                }
                
            } catch (error) {
                logTest('Detailed transaction test failed', false, error.message);
            }
        };
        
        // createTransaction詳細デバッグテスト
        window.testCreateTransactionDebug = async function() {
            if (!kaspa || !window.testPrivateKey) {
                logTest('Debug test skipped', false, 'Prerequisites not met');
                return;
            }
            
            try {
                logTest('=== DEBUG createTransaction ERROR ===', true);
                
                const privateKey = window.testPrivateKey;
                const keypair = privateKey.toKeypair();
                const address = keypair.toAddress(kaspa.NetworkType.Testnet);
                
                // 複数の異なるUTXO/Output形式をテスト
                const testCases = [
                    {
                        name: 'Empty arrays',
                        utxos: [],
                        outputs: [],
                        feeRate: 1000n,
                        payload: 'test'
                    },
                    {
                        name: 'Simple UTXO format',
                        utxos: [{
                            outpoint: { transactionId: 'a'.repeat(64), index: 0 },
                            amount: 100000000n,
                            scriptPublicKey: { version: 0, script: new Uint8Array([0x76, 0xa9, 0x14]) }
                        }],
                        outputs: [{ address: address.toString(), amount: 50000000n }],
                        feeRate: 1000n,
                        payload: 'test payload'
                    },
                    {
                        name: 'PaymentOutput format',
                        utxos: [],
                        outputs: kaspa.PaymentOutput ? [new kaspa.PaymentOutput(address, 50000000n)] : [],
                        feeRate: 1000n,
                        payload: new Uint8Array([1, 2, 3, 4])
                    }
                ];
                
                for (const testCase of testCases) {
                    try {
                        logTest(`Testing ${testCase.name}...`, true);
                        
                        const result = kaspa.createTransaction(
                            testCase.utxos,
                            testCase.outputs,
                            address,
                            testCase.feeRate,
                            testCase.payload
                        );
                        
                        logTest(`${testCase.name}: SUCCESS`, true, typeof result);
                        
                    } catch (error) {
                        // 詳細なエラー情報
                        logTest(`${testCase.name}: FAILED`, false, error.message);
                        logTest(`Error type: ${error.name}`, false);
                        logTest(`Error stack (first 100 chars)`, false, error.stack ? error.stack.substring(0, 100) : 'No stack');
                        
                        // コンソールログ
                        console.group(`🔍 ${testCase.name} Error Details`);
                        console.error('Full error:', error);
                        console.log('Test case:', testCase);
                        console.log('Address object:', address);
                        console.log('kaspa object keys:', Object.keys(kaspa).slice(0, 20));
                        console.groupEnd();
                    }
                }
                
                // 関数signature分析
                logTest('=== FUNCTION SIGNATURE ANALYSIS ===', true);
                logTest('createTransaction length', true, `${kaspa.createTransaction.length} parameters`);
                logTest('createTransaction toString', true, kaspa.createTransaction.toString().substring(0, 100) + '...');
                
            } catch (error) {
                logTest('Debug test failed', false, error.message);
                console.error('Debug test error:', error);
            }
        };
        
        // 自動初期化
        window.addEventListener('load', () => {
            updateDisplay();
        });
        
    </script>
</body>
</html>