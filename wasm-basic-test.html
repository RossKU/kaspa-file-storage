<!DOCTYPE html>
<html>
<head>
    <title>Kaspa WASM Basic Test</title>
    <style>
        body { font-family: monospace; padding: 20px; }
        .result { background: #f0f0f0; padding: 10px; margin: 10px 0; }
        .success { color: green; }
        .error { color: red; }
        button { padding: 10px 20px; margin: 5px; }
    </style>
</head>
<body>
    <h1>Kaspa WASM SDK Basic Tests</h1>
    
    <div>
        <button onclick="testBasicInitialization()">1. Test Basic Initialization</button>
        <button onclick="testPrivateKeyCreation()">2. Test PrivateKey Creation</button>
        <button onclick="testAddressGeneration()">3. Test Address Generation</button>
        <button onclick="testTransactionFunction()">4. Test Transaction Functions</button>
        <button onclick="testPayloadHandling()">5. Test Payload Handling</button>
        <button onclick="testDetailedTransaction()">6. Test Detailed Transaction</button>
        <button onclick="testCreateTransactionDebug()">7. Test SDK-Compliant createTransaction</button>
        <button onclick="testFullTransactionFlow()">8. Test Full Transaction Flow (RPC + Balance)</button>
    </div>
    
    <div class="result" id="testOutput"></div>

    <script type="module">
        let kaspa = null;
        let testResults = [];
        
        // „Éö„Ç§„É≠„Éº„ÉâÂá¶ÁêÜ„Éò„É´„Éë„ÉºÈñ¢Êï∞
        function textToHex(text) {
            return Array.from(new TextEncoder().encode(text))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }
        
        function hexToText(hex) {
            const bytes = new Uint8Array(hex.length / 2);
            for (let i = 0; i < hex.length; i += 2) {
                bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
            }
            return new TextDecoder().decode(bytes);
        }
        
        function arrayBufferToHex(buffer) {
            return Array.from(new Uint8Array(buffer))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }
        
        function hexToArrayBuffer(hex) {
            const bytes = new Uint8Array(hex.length / 2);
            for (let i = 0; i < hex.length; i += 2) {
                bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
            }
            return bytes.buffer;
        }
        
        // „ÉÜ„Çπ„ÉàÁµêÊûú„ÇíË°®Á§∫„Åô„ÇãÈñ¢Êï∞
        function logTest(testName, result, details = '') {
            const status = result ? '‚úÖ' : '‚ùå';
            const message = `${status} ${testName}: ${result ? 'PASS' : 'FAIL'} ${details}`;
            testResults.push(message);
            console.log(message);
            updateDisplay();
        }
        
        function updateDisplay() {
            document.getElementById('testOutput').innerHTML = testResults.join('<br>');
        }
        
        // Âü∫Êú¨ÂàùÊúüÂåñ„ÉÜ„Çπ„Éà
        window.testBasicInitialization = async function() {
            testResults = [];
            logTest('Starting WASM Basic Tests', true, 'v1.0.0-basic');
            
            try {
                logTest('Importing kaspa-core.js', true);
                kaspa = await import('./kaspa-core.js');
                logTest('Module imported', !!kaspa);
                
                logTest('Initializing WASM', true);
                await kaspa.default('./kaspa-core_bg.wasm');
                logTest('WASM initialized', true);
                
                // „Éê„Éº„Ç∏„Éß„É≥Á¢∫Ë™ç
                if (kaspa.version) {
                    const version = kaspa.version();
                    logTest('Version check', true, version);
                } else {
                    logTest('Version check', false, 'version() not found');
                }
                
                // Âü∫Êú¨„ÇØ„É©„Çπ„ÅÆÂ≠òÂú®Á¢∫Ë™ç
                logTest('PrivateKey class exists', !!kaspa.PrivateKey);
                logTest('Transaction class exists', !!kaspa.Transaction);
                logTest('createTransaction function exists', !!kaspa.createTransaction);
                logTest('createTransactions function exists', !!kaspa.createTransactions);
                
                // WASMÂàùÊúüÂåñÂÆå‰∫Ü
                
            } catch (error) {
                logTest('Initialization failed', false, error.message || error.toString());
            }
        };
        
        // PrivateKey‰ΩúÊàê„ÉÜ„Çπ„Éà
        window.testPrivateKeyCreation = async function() {
            if (!kaspa) {
                logTest('PrivateKey test skipped', false, 'WASM not initialized - run test 1 first');
                return;
            }
            
            // WASMÂÆåÂÖ®ÂàùÊúüÂåñ„ÇíÂæÖÊ©ü
            if (!kaspa.PrivateKey) {
                logTest('PrivateKey test skipped', false, 'PrivateKey class not available');
                return;
            }
            
            try {
                // „ÉÜ„Çπ„ÉàÁî®„ÅÆÊó¢Áü•„ÅÆÁßòÂØÜÈçµÔºàÂÖ¨Âºè‰æã„Å®Âêå„ÅòÂΩ¢ÂºèÔºâ
                const testKeyHex = 'b7e151628aed2a6abf7158809cf4f3c762e7160f38b4da56a784d9045190cfef';
                logTest('Creating PrivateKey from hex', true, testKeyHex.substring(0, 8) + '...');
                
                // Â∞è„Åï„Å™ÂæÖÊ©üÊôÇÈñì„ÇíÂÖ•„Çå„Å¶WASMÂÆåÂÖ®ÂàùÊúüÂåñ„ÇíÁ¢∫‰øù
                await new Promise(resolve => setTimeout(resolve, 10));
                
                const privateKey = new kaspa.PrivateKey(testKeyHex);
                logTest('PrivateKey created', !!privateKey);
                
                // toString „É°„ÇΩ„ÉÉ„Éâ„ÉÜ„Çπ„Éà
                if (privateKey.toString) {
                    const keyString = privateKey.toString();
                    logTest('PrivateKey.toString()', keyString === testKeyHex, keyString.substring(0, 8) + '...');
                } else {
                    logTest('PrivateKey.toString()', false, 'method not found');
                }
                
                // toKeypair „É°„ÇΩ„ÉÉ„Éâ„ÉÜ„Çπ„Éà
                if (privateKey.toKeypair) {
                    const keypair = privateKey.toKeypair();
                    logTest('PrivateKey.toKeypair()', !!keypair);
                } else {
                    logTest('PrivateKey.toKeypair()', false, 'method not found');
                }
                
                window.testPrivateKey = privateKey; // Ê¨°„ÅÆ„ÉÜ„Çπ„ÉàÁî®„Å´‰øùÂ≠ò
                
            } catch (error) {
                logTest('PrivateKey creation failed', false, (error.message || error.toString()).substring(0, 100));
                console.error('PrivateKey creation error details:', error);
            }
        };
        
        // „Ç¢„Éâ„É¨„ÇπÁîüÊàê„ÉÜ„Çπ„Éà
        window.testAddressGeneration = async function() {
            if (!kaspa) {
                logTest('Address test skipped', false, 'WASM not initialized - run test 1 first');
                return;
            }
            
            if (!window.testPrivateKey) {
                // If no existing private key, create one for this test
                try {
                    const testKeyHex = 'b7e151628aed2a6abf7158809cf4f3c762e7160f38b4da56a784d9045190cfef';
                    await new Promise(resolve => setTimeout(resolve, 10));
                    window.testPrivateKey = new kaspa.PrivateKey(testKeyHex);
                } catch (e) {
                    logTest('Address test skipped', false, 'Cannot create PrivateKey - run test 2 first');
                    return;
                }
            }
            
            try {
                const privateKey = window.testPrivateKey;
                
                // NetworkTypeÁ¢∫Ë™ç
                logTest('NetworkType available', !!kaspa.NetworkType);
                
                if (kaspa.NetworkType) {
                    // Keypair„Åã„Çâ„Ç¢„Éâ„É¨„ÇπÁîüÊàê
                    const keypair = privateKey.toKeypair();
                    
                    if (keypair.toAddress) {
                        // „É°„Ç§„É≥„Éç„ÉÉ„Éà„Ç¢„Éâ„É¨„Çπ
                        if (kaspa.NetworkType.Mainnet) {
                            const mainnetAddr = keypair.toAddress(kaspa.NetworkType.Mainnet);
                            logTest('Mainnet address', !!mainnetAddr, mainnetAddr ? mainnetAddr.toString().substring(0, 20) + '...' : '');
                        }
                        
                        // „ÉÜ„Çπ„Éà„Éç„ÉÉ„Éà„Ç¢„Éâ„É¨„Çπ
                        if (kaspa.NetworkType.Testnet) {
                            const testnetAddr = keypair.toAddress(kaspa.NetworkType.Testnet);
                            logTest('Testnet address', !!testnetAddr, testnetAddr ? testnetAddr.toString().substring(0, 20) + '...' : '');
                        }
                    } else {
                        logTest('toAddress method', false, 'not found on keypair');
                    }
                } else {
                    logTest('NetworkType not found', false);
                }
                
            } catch (error) {
                logTest('Address generation failed', false, error.message);
            }
        };
        
        // „Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥Èñ¢Êï∞„ÉÜ„Çπ„Éà
        window.testTransactionFunction = async function() {
            if (!kaspa) {
                logTest('Transaction test skipped', false, 'WASM not initialized');
                return;
            }
            
            try {
                // createTransactionÈñ¢Êï∞„ÅÆÂü∫Êú¨„ÉÜ„Çπ„Éà
                logTest('createTransaction function type', typeof kaspa.createTransaction === 'function');
                
                if (kaspa.createTransaction) {
                    // Èñ¢Êï∞„ÅÆÈï∑„ÅïÔºà„Éë„É©„É°„Éº„ÇøÊï∞ÔºâÁ¢∫Ë™ç
                    logTest('createTransaction parameters', true, `expects ${kaspa.createTransaction.length} params`);
                }
                
                // createTransactionsÈñ¢Êï∞„ÅÆÂü∫Êú¨„ÉÜ„Çπ„Éà  
                logTest('createTransactions function type', typeof kaspa.createTransactions === 'function');
                
                if (kaspa.createTransactions) {
                    logTest('createTransactions parameters', true, `expects ${kaspa.createTransactions.length} params`);
                }
                
                // ÂÆüÈöõ„ÅÆÂëº„Å≥Âá∫„Åó„ÉÜ„Çπ„ÉàÔºà„Ç®„É©„Éº„Åå‰∫àÊÉ≥„Åï„Çå„ÇãÔºâ
                try {
                    const result = kaspa.createTransaction([], [], 0n, null, 1);
                    logTest('createTransaction call', !!result, 'unexpected success');
                } catch (error) {
                    logTest('createTransaction call', true, `expected error: ${(error.message || error.toString()).substring(0, 50)}...`);
                }
                
            } catch (error) {
                logTest('Transaction function test failed', false, error.message || error.toString());
            }
        };
        
        // „Éö„Ç§„É≠„Éº„ÉâÂá¶ÁêÜ„ÉÜ„Çπ„Éà
        window.testPayloadHandling = async function() {
            if (!kaspa) {
                logTest('Payload test skipped', false, 'WASM not initialized');
                return;
            }
            
            try {
                // „ÉÜ„Çπ„Éà„Éö„Ç§„É≠„Éº„Éâ‰ΩúÊàê
                const testText = 'Hello Kaspa!';
                const testPayloadBytes = new TextEncoder().encode(testText);
                logTest('Test payload created', true, `${testPayloadBytes.length} bytes`);
                
                // HexÂ§âÊèõ„ÉÜ„Çπ„Éà
                const testPayloadHex = Array.from(testPayloadBytes, b => b.toString(16).padStart(2, '0')).join('');
                logTest('Payload hex conversion', true, testPayloadHex);
                
                // Áã¨Ëá™ÂÆüË£Ö„ÅÆ„Éö„Ç§„É≠„Éº„ÉâÈñ¢Êï∞„Çí„ÉÜ„Çπ„Éà
                try {
                    const hexResult = textToHex(testText);
                    logTest('textToHex function', hexResult === testPayloadHex, hexResult);
                    
                    const textResult = hexToText(testPayloadHex);
                    logTest('hexToText function', textResult === testText, textResult);
                    
                    const bufferHex = arrayBufferToHex(testPayloadBytes.buffer);
                    logTest('arrayBufferToHex function', bufferHex === testPayloadHex, bufferHex);
                    
                    const bufferResult = hexToArrayBuffer(testPayloadHex);
                    const bufferMatch = new Uint8Array(bufferResult).every((val, idx) => val === testPayloadBytes[idx]);
                    logTest('hexToArrayBuffer function', bufferMatch, `${new Uint8Array(bufferResult).length} bytes`);
                    
                } catch (error) {
                    logTest('Payload helper functions', false, error.message);
                }
                
            } catch (error) {
                logTest('Payload handling test failed', false, error.message);
            }
        };
        
        // Ë©≥Á¥∞„Å™„Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥‰ΩúÊàê„ÉÜ„Çπ„Éà
        window.testDetailedTransaction = async function() {
            if (!kaspa) {
                logTest('Detailed transaction test skipped', false, 'WASM not initialized - run test 1 first');
                return;
            }
            
            if (!window.testPrivateKey) {
                // Create a private key for this test
                try {
                    const testKeyHex = 'b7e151628aed2a6abf7158809cf4f3c762e7160f38b4da56a784d9045190cfef';
                    await new Promise(resolve => setTimeout(resolve, 10));
                    window.testPrivateKey = new kaspa.PrivateKey(testKeyHex);
                } catch (e) {
                    logTest('Detailed transaction test skipped', false, 'Cannot create PrivateKey');
                    return;
                }
            }
            
            try {
                logTest('=== REAL TRANSACTION CREATION TEST ===', true);
                
                const privateKey = window.testPrivateKey;
                const keypair = privateKey.toKeypair();
                const address = keypair.toAddress(kaspa.NetworkType.Testnet);
                
                // Test different UTXO formats
                logTest('Test UTXO data prepared', true, '1 UTXOs');
                
                // Test different output formats
                logTest('Test output data prepared', true, '1 outputs');
                
                // Test payload
                const testPayload = 'Test file storage payload';
                const payloadBytes = new TextEncoder().encode(testPayload);
                logTest('Test payload prepared', true, `${testPayload.length} bytes`);
                
                // Test createTransaction with various parameter combinations
                logTest('Calling createTransaction with real data...', true);
                
                try {
                    // Method 1: Basic test with empty arrays
                    const result1 = kaspa.createTransaction([], [], 0n, payloadBytes, 1);
                    logTest('createTransaction Method 1 (empty)', !!result1, 'success');
                } catch (e) {
                    logTest('createTransaction Method 1 (empty)', false, (e.message || e.toString()).substring(0, 50));
                }
                
                logTest('=== UTXO AND OUTPUT FORMAT TEST ===', true);
                
                // Test kaspaToSompi function
                if (kaspa.kaspaToSompi) {
                    try {
                        // Try different parameter types
                        const sompi1 = kaspa.kaspaToSompi("1");
                        logTest('kaspaToSompi function (string)', true, `1 KAS = ${sompi1} sompi`);
                    } catch (e1) {
                        try {
                            const sompi2 = kaspa.kaspaToSompi(1.0);
                            logTest('kaspaToSompi function (float)', true, `1 KAS = ${sompi2} sompi`);
                        } catch (e2) {
                            logTest('kaspaToSompi function', false, (e1.message || e1.toString()).substring(0, 50));
                        }
                    }
                }
                
                // Test Address constructor 
                if (kaspa.Address) {
                    try {
                        const addr = new kaspa.Address('kaspatest:qqk8m83ypfr4yg0ykaszpwjfm86c9vf22jgfg0jpc39h2k80nx8rxrumw8zpd');
                        logTest('Address constructor', !!addr, addr.toString().substring(0, 20) + '...');
                    } catch (e) {
                        logTest('Address constructor', false, e.message);
                    }
                }
                
                // Test PaymentOutput class
                if (kaspa.PaymentOutput) {
                    try {
                        const output = new kaspa.PaymentOutput(address, 100000000n);
                        logTest('PaymentOutput class', !!output);
                    } catch (e) {
                        logTest('PaymentOutput class', false, e.message);
                    }
                }
                
                // Test UtxoEntry class  
                if (kaspa.UtxoEntry) {
                    try {
                        const utxo = new kaspa.UtxoEntry();
                        logTest('UtxoEntry class', !!utxo);
                    } catch (e) {
                        logTest('UtxoEntry class', false, e.message);
                    }
                }
                
            } catch (error) {
                logTest('Detailed transaction test failed', false, error.message || error.toString());
            }
        };
        
        // createTransactionË©≥Á¥∞„Éá„Éê„ÉÉ„Ç∞„ÉÜ„Çπ„Éà
        window.testCreateTransactionDebug = async function() {
            if (!kaspa) {
                logTest('Debug test skipped', false, 'WASM not initialized - run test 1 first');
                return;
            }
            
            if (!window.testPrivateKey) {
                // Create a private key for this test
                try {
                    const testKeyHex = 'b7e151628aed2a6abf7158809cf4f3c762e7160f38b4da56a784d9045190cfef';
                    await new Promise(resolve => setTimeout(resolve, 10));
                    window.testPrivateKey = new kaspa.PrivateKey(testKeyHex);
                } catch (e) {
                    logTest('Debug test skipped', false, 'Cannot create PrivateKey');
                    return;
                }
            }
            
            try {
                logTest('=== DEBUG createTransaction ERROR ===', true);
                
                const privateKey = window.testPrivateKey;
                const keypair = privateKey.toKeypair();
                const address = keypair.toAddress(kaspa.NetworkType.Testnet);
                
                // Ê≠£„Åó„ÅÑIUtxoEntryÂΩ¢Âºè„ÅÆ„ÉÜ„Çπ„Éà„Éá„Éº„Çø
                const testUtxos = [{
                    outpoint: {
                        transactionId: "b316c423c35c9e24bb263f56475df4297a82f4c52c70237e0fc36af5f7df1f9e",
                        index: 0
                    },
                    amount: 200000000000n, // 2000 KAS in sompi (enough for 1 TKAS + fees)
                    scriptPublicKey: {
                        version: 0,
                        script: new Uint8Array([0x20, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11])
                    },
                    blockDaaScore: 12345678n
                }];
                logTest('Test UTXO data prepared (IUtxoEntry format)', true, `${testUtxos.length} UTXOs`);
                
                // Ê≠£„Åó„ÅÑIPaymentOutputÂΩ¢Âºè„ÅÆ„ÉÜ„Çπ„Éà„Éá„Éº„ÇøÔºà1 TKASÈÄÅÈáëÔºâ
                const testOutputs = [{
                    address: address.toString(), // use generated address
                    amount: 100000000000n // 1 TKAS in sompi (1000 KAS)
                }];
                logTest('Test output data prepared (1 TKAS transfer)', true, `${testOutputs.length} outputs`);
                
                // „ÉÜ„Çπ„Éà„Éö„Ç§„É≠„Éº„ÉâÔºàUint8ArrayÂΩ¢ÂºèÔºâ- „Éï„Ç°„Ç§„É´„Çπ„Éà„É¨„Éº„Ç∏„Éá„Éº„Çø
                const testFileData = "Test 1 TKAS transfer with file storage payload!";
                const payloadBytes = new TextEncoder().encode(testFileData);
                logTest('Test file storage payload prepared', true, `${payloadBytes.length} bytes`);
                
                // createTransactionÈñ¢Êï∞„ÇíSDK‰ªïÊßò„Å´Ê∫ñÊã†„Åó„Å¶Âëº„Å≥Âá∫„Åó
                try {
                    logTest('=== Testing 1 TKAS Transfer with File Storage ===', true);
                
                // „Ç¶„Ç©„É¨„ÉÉ„ÉàÊÉÖÂ†±Ë°®Á§∫
                logTest('Sender address', true, address.toString().substring(0, 20) + '...');
                logTest('Recipient address', true, address.toString().substring(0, 20) + '...');
                logTest('Transfer amount', true, '1 TKAS (1000 KAS)');
                logTest('Fee amount', true, '0.01 KAS');
                logTest('File storage payload', true, `"${testFileData.substring(0, 30)}..."`);
                
                logTest('=== Testing createTransaction with proper SDK interfaces ===', true);
                    
                    // Test Case 1: Empty arrays (should work)
                    try {
                        const emptyResult = kaspa.createTransaction(
                            [],        // empty utxo_entry_source
                            [],        // empty outputs
                            0n,        // priority_fee (0 for empty UTXO)
                            payloadBytes,  // payload as Uint8Array
                            1          // sig_op_count
                        );
                        logTest('Empty arrays test', !!emptyResult, typeof emptyResult);
                    } catch (e) {
                        logTest('Empty arrays test', false, (e.message || e.toString()).substring(0, 50));
                    }
                    
                    // Test Case 2: With proper UTXO and output data
                    try {
                        const transaction = kaspa.createTransaction(
                            testUtxos,     // utxo_entry_source (IUtxoEntry[])
                            testOutputs,   // outputs (IPaymentOutput[])
                            1000000n,      // priority_fee (0.01 KAS in sompi for 1 TKAS transfer)
                            payloadBytes,  // payload (Uint8Array)
                            1              // sig_op_count
                        );
                        
                        logTest('createTransaction with data', !!transaction, typeof transaction);
                        
                        if (transaction) {
                            // „Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆË©≥Á¥∞Á¢∫Ë™ç
                            logTest('Transaction object type', typeof transaction === 'object');
                            
                            // Âà©Áî®ÂèØËÉΩ„Å™„É°„ÇΩ„ÉÉ„ÉâÁ¢∫Ë™ç
                            const methods = ['toString', 'id', 'inputs', 'outputs'].map(method => ({
                                name: method,
                                exists: transaction[method] !== undefined
                            }));
                            
                            methods.forEach(method => {
                                logTest(`Transaction.${method.name}`, method.exists);
                            });
                            
                            // Optional methods (may not exist)
                            const optionalMethods = ['sign', 'toJson', 'toRaw', 'serialize'].map(method => ({
                                name: method,
                                exists: transaction[method] !== undefined
                            }));
                            
                            optionalMethods.forEach(method => {
                                logTest(`Transaction.${method.name} (optional)`, true, method.exists ? 'available' : 'not available');
                            });
                            
                            window.testTransaction = transaction; // Ê¨°„ÅÆ„ÉÜ„Çπ„ÉàÁî®„Å´‰øùÂ≠ò
                        }
                        
                    } catch (createError) {
                        logTest('createTransaction with data', false, (createError.message || createError.toString()).substring(0, 50));
                        console.group('üîç createTransaction Error Details');
                        console.error('Full error:', createError);
                        console.log('Test UTXOs:', testUtxos);
                        console.log('Test outputs:', testOutputs);
                        console.log('Payload:', payloadBytes);
                        console.groupEnd();
                    }
                    
                    // Test Case 3: Test createTransactions (object parameter)
                    try {
                        logTest('=== Testing createTransactions function ===', true);
                        // Create proper mock UTXO entries with sufficient balance
                        // Create proper mock UTXO with realistic Kaspa transaction ID and correct format
                        const mockUtxoEntries = [{
                            address: address.toString(),
                            outpoint: {
                                transactionId: "b316c423c35c9e24bb263f56475df4297a82f4c52c70237e0fc36af5f7df1f9e",
                                index: 0
                            },
                            scriptPublicKey: kaspa.payToAddressScript ? kaspa.payToAddressScript(address) : {
                                version: 0,
                                script: new Uint8Array([
                                    0x20, // OP_DATA_32 - push 32 bytes
                                    // 32-byte public key hash derived from test private key
                                    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
                                    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
                                    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
                                    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
                                    0xac // OP_CHECKSIG
                                ])
                            },
                            amount: 500000000000n, // 5000 KAS (much more than needed: sufficient for 1000 KAS output + fees)
                            isCoinbase: false,
                            blockDaaScore: 12345678n
                        }];
                        
                        const transactionsResult = await kaspa.createTransactions({
                            entries: mockUtxoEntries,  // sufficient UTXO balance
                            outputs: testOutputs,      // 1000 KAS output
                            changeAddress: address,    // required for change
                            priorityFee: 1000000n,     // 0.01 KAS fee
                            networkId: "testnet-10"    // correct string format
                        });
                        logTest('createTransactions call', !!transactionsResult, typeof transactionsResult);
                        
                        if (transactionsResult && transactionsResult.transactions) {
                            logTest('createTransactions result has transactions', true, `${transactionsResult.transactions.length} transactions`);
                        }
                    } catch (e) {
                        logTest('createTransactions call', false, (e.message || e.toString()).substring(0, 50));
                    }
                    
                } catch (generalError) {
                    logTest('General createTransaction test failed', false, (generalError.message || generalError.toString()).substring(0, 50));
                    console.error('General error:', generalError);
                }
                
                // Èñ¢Êï∞signatureÂàÜÊûê
                logTest('=== FUNCTION SIGNATURE ANALYSIS ===', true);
                logTest('createTransaction length', true, `${kaspa.createTransaction.length} parameters`);
                logTest('createTransaction toString', true, kaspa.createTransaction.toString().substring(0, 100) + '...');
                
            } catch (error) {
                logTest('Debug test failed', false, error.message || error.toString());
                console.error('Debug test error:', error);
            }
        };
        
        // ÂÆåÂÖ®„Å™„Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥„Éï„É≠„ÉºÔºàRPC + ÊÆãÈ´òÁ¢∫Ë™çÔºâ
        window.testFullTransactionFlow = async function() {
            if (!kaspa) {
                logTest('Full flow test skipped', false, 'WASM not initialized - run test 1 first');
                return;
            }
            
            if (!window.testPrivateKey) {
                try {
                    const testKeyHex = 'b7e151628aed2a6abf7158809cf4f3c762e7160f38b4da56a784d9045190cfef';
                    await new Promise(resolve => setTimeout(resolve, 10));
                    window.testPrivateKey = new kaspa.PrivateKey(testKeyHex);
                } catch (e) {
                    logTest('Full flow test skipped', false, 'Cannot create PrivateKey');
                    return;
                }
            }
            
            try {
                logTest('=== COMPLETE TRANSACTION FLOW TEST ===', true);
                
                const privateKey = window.testPrivateKey;
                const keypair = privateKey.toKeypair();
                const senderAddress = keypair.toAddress(kaspa.NetworkType.Testnet);
                
                logTest('Sender Address', true, senderAddress.toString().substring(0, 30) + '...');
                
                // Step 1: RPCÊé•Á∂ö„ÅÆ„ÉÜ„Çπ„Éà
                logTest('=== Step 1: RPC Connection Test ===', true);
                let rpcClient = null;
                
                try {
                    // Kaspa testnet public node
                    const testnetNodes = [
                        'wss://testnet-1.kaspa.aspectron.org',
                        'wss://testnet-2.kaspa.aspectron.org'
                    ];
                    
                    rpcClient = new kaspa.RpcClient({
                        url: testnetNodes[0],
                        networkId: 'testnet-10'
                    });
                    
                    logTest('RPC Client created', true, testnetNodes[0]);
                    
                    // Êé•Á∂öË©¶Ë°å
                    await rpcClient.connect();
                    logTest('RPC Connection established', true);
                    
                    // „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØÊÉÖÂ†±ÂèñÂæó
                    const networkInfo = await rpcClient.getBlockDagInfo();
                    logTest('Network info retrieved', !!networkInfo, `DAA Score: ${networkInfo.daaScore || 'unknown'}`);
                    
                } catch (rpcError) {
                    logTest('RPC Connection failed', false, (rpcError.message || rpcError.toString()).substring(0, 50));
                    logTest('Full flow test using mock data', true, 'continuing with simulated data');
                    console.error('RPC Error details:', rpcError);
                    rpcClient = null; // Force fallback to mock data
                }
                
                // Step 2: ÊÆãÈ´òÁ¢∫Ë™ç
                logTest('=== Step 2: Balance Check ===', true);
                let currentBalance = 0n;
                let utxoEntries = [];
                
                try {
                    if (rpcClient) {
                        logTest('Attempting live balance check...', true);
                        const balanceInfo = await rpcClient.getBalanceByAddress(senderAddress.toString());
                        currentBalance = balanceInfo.balance || 0n;
                        logTest('Current balance retrieved', true, `${currentBalance} sompi`);
                        
                        // UTXOÂèñÂæó
                        logTest('Attempting UTXO retrieval...', true);
                        const utxoInfo = await rpcClient.getUtxosByAddresses([senderAddress.toString()]);
                        utxoEntries = utxoInfo.entries || [];
                        logTest('UTXO entries retrieved', true, `${utxoEntries.length} UTXOs`);
                    } else {
                        // Mock data for offline testing
                        currentBalance = 500000000000n; // 5000 KAS
                        utxoEntries = [{
                            address: senderAddress.toString(),
                            outpoint: {
                                transactionId: "b316c423c35c9e24bb263f56475df4297a82f4c52c70237e0fc36af5f7df1f9e",
                                index: 0
                            },
                            scriptPublicKey: {
                                version: 0,
                                script: new Uint8Array([0x20, 0xb7, 0xe1, 0x51, 0x62, 0x8a, 0xed, 0x2a, 0x6a, 0xbf, 0x71, 0x58, 0x80, 0x9c, 0xf4, 0xf3, 0xc7, 0x62, 0xe7, 0x16, 0x0f, 0x38, 0xb4, 0xda, 0x56, 0xa7, 0x84, 0xd9, 0x04, 0x51, 0x90, 0xcf, 0xef, 0xac])
                            },
                            amount: currentBalance,
                            isCoinbase: false,
                            blockDaaScore: 12345678n
                        }];
                        logTest('Using mock balance data', true, `${currentBalance} sompi (5000 KAS)`);
                    }
                } catch (balanceError) {
                    logTest('Balance check failed', false, (balanceError.message || balanceError.toString()).substring(0, 50));
                    console.error('Balance Error details:', balanceError);
                    
                    // Fallback to mock data on balance error
                    logTest('Fallback to mock data', true, 'due to balance error');
                    currentBalance = 500000000000n; // 5000 KAS
                    utxoEntries = [{
                        address: senderAddress.toString(),
                        outpoint: {
                            transactionId: "b316c423c35c9e24bb263f56475df4297a82f4c52c70237e0fc36af5f7df1f9e",
                            index: 0
                        },
                        scriptPublicKey: {
                            version: 0,
                            script: new Uint8Array([0x20, 0xb7, 0xe1, 0x51, 0x62, 0x8a, 0xed, 0x2a, 0x6a, 0xbf, 0x71, 0x58, 0x80, 0x9c, 0xf4, 0xf3, 0xc7, 0x62, 0xe7, 0x16, 0x0f, 0x38, 0xb4, 0xda, 0x56, 0xa7, 0x84, 0xd9, 0x04, 0x51, 0x90, 0xcf, 0xef, 0xac])
                        },
                        amount: currentBalance,
                        isCoinbase: false,
                        blockDaaScore: 12345678n
                    }];
                }
                
                // Step 3: „Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥‰ΩúÊàê
                logTest('=== Step 3: Transaction Creation ===', true);
                
                const transferAmount = 100000000000n; // 1000 KAS (1 TKAS)
                const priorityFee = 1000000n; // 0.01 KAS
                const totalRequired = transferAmount + priorityFee;
                
                if (currentBalance < totalRequired) {
                    logTest('Insufficient funds', false, `Need ${totalRequired}, have ${currentBalance}`);
                    return;
                }
                
                logTest('Sufficient balance confirmed', true, `${currentBalance} >= ${totalRequired}`);
                
                // Âèó‰ø°„Ç¢„Éâ„É¨„ÇπÔºà„ÉÜ„Çπ„ÉàÁî®„Å´ÈÄÅ‰ø°ËÄÖ„Å®Âêå„Åò„Ç¢„Éâ„É¨„ÇπÔºâ
                const recipientAddress = senderAddress.toString();
                
                const testPayload = `File storage test - 1 TKAS transfer at ${new Date().toISOString()}`;
                const payloadBytes = new TextEncoder().encode(testPayload);
                
                let transactionResult = null;
                
                try {
                    transactionResult = await kaspa.createTransactions({
                        entries: utxoEntries,
                        outputs: [{
                            address: recipientAddress,
                            amount: transferAmount
                        }],
                        changeAddress: senderAddress.toString(),
                        priorityFee: priorityFee,
                        networkId: "testnet-10",
                        payload: payloadBytes
                    });
                    
                    logTest('Transaction created successfully', !!transactionResult, `${transactionResult.transactions?.length || 0} transactions`);
                    
                    if (transactionResult.summary) {
                        const summary = transactionResult.summary;
                        logTest('Transaction fees calculated', true, `${summary.fees || 'unknown'} sompi`);
                        logTest('Final transaction amount', true, `${summary.finalAmount || transferAmount} sompi`);
                        logTest('Change amount', true, `${summary.changeAmount || 'unknown'} sompi`);
                    }
                    
                } catch (txError) {
                    logTest('Transaction creation failed', false, (txError.message || txError.toString()).substring(0, 50));
                    return;
                }
                
                // Step 4: „Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥ÁΩ≤ÂêçÔºà„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥Ôºâ
                logTest('=== Step 4: Transaction Signing (Simulation) ===', true);
                
                if (transactionResult?.transactions?.length > 0) {
                    const firstTx = transactionResult.transactions[0];
                    logTest('Transaction ready for signing', true, typeof firstTx);
                    
                    // Note: ÂÆüÈöõ„ÅÆÁΩ≤Âêç„ÅØ PendingTransaction.sign([privateKey]) „Çí‰ΩøÁî®
                    logTest('Signing simulation', true, 'would call: pendingTx.sign([privateKey])');
                    logTest('Submission simulation', true, 'would call: pendingTx.submit(rpcClient)');
                }
                
                // Step 5: ÊÆãÈ´òÂ§âÊõ¥„ÅÆ‰∫àÊ∏¨
                logTest('=== Step 5: Expected Balance Changes ===', true);
                
                const expectedNewBalance = currentBalance - transferAmount - priorityFee;
                logTest('Expected sender balance after tx', true, `${expectedNewBalance} sompi`);
                logTest('Expected recipient balance change', true, `+${transferAmount} sompi`);
                logTest('Total fees paid', true, `${priorityFee} sompi (0.01 KAS)`);
                
                // Step 6: „Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥Ë©≥Á¥∞
                logTest('=== Step 6: Transaction Details ===', true);
                logTest('File storage payload', true, `"${testPayload.substring(0, 40)}..."`);
                logTest('Payload size', true, `${payloadBytes.length} bytes`);
                logTest('Transaction type', true, '1 TKAS transfer with file storage');
                
                // Step 7: „ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
                if (rpcClient) {
                    try {
                        await rpcClient.disconnect();
                        logTest('RPC Connection closed', true);
                    } catch (disconnectError) {
                        logTest('RPC Disconnect warning', false, 'connection may still be open');
                    }
                }
                
                logTest('=== COMPLETE TRANSACTION FLOW FINISHED ===', true, 'Ready for real deployment');
                
            } catch (error) {
                logTest('Full transaction flow failed', false, (error.message || error.toString()).substring(0, 100));
                console.error('Full flow error:', error);
            }
        };
        
        // Ëá™ÂãïÂàùÊúüÂåñ
        window.addEventListener('load', () => {
            updateDisplay();
        });
        
    </script>
</body>
</html>