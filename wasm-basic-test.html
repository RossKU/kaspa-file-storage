<!DOCTYPE html>
<html>
<head>
    <title>Kaspa WASM Basic Test</title>
    <style>
        body { font-family: monospace; padding: 20px; }
        .result { background: #f0f0f0; padding: 10px; margin: 10px 0; }
        .success { color: green; }
        .error { color: red; }
        button { padding: 10px 20px; margin: 5px; }
    </style>
</head>
<body>
    <h1>Kaspa WASM SDK Basic Tests</h1>
    
    <div>
        <button onclick="testBasicInitialization()">1. Test Basic Initialization</button>
        <button onclick="testPrivateKeyCreation()">2. Test PrivateKey Creation</button>
        <button onclick="testAddressGeneration()">3. Test Address Generation</button>
        <button onclick="testTransactionFunction()">4. Test Transaction Functions</button>
        <button onclick="testPayloadHandling()">5. Test Payload Handling</button>
        <button onclick="testDetailedTransaction()">6. Test Detailed Transaction</button>
        <button onclick="testCreateTransactionDebug()">7. Debug createTransaction</button>
    </div>
    
    <div class="result" id="testOutput"></div>

    <script type="module">
        let kaspa = null;
        let testResults = [];
        
        // ãƒ†ã‚¹ãƒˆçµæœã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•°
        function logTest(testName, result, details = '') {
            const status = result ? 'âœ…' : 'âŒ';
            const message = `${status} ${testName}: ${result ? 'PASS' : 'FAIL'} ${details}`;
            testResults.push(message);
            console.log(message);
            updateDisplay();
        }
        
        function updateDisplay() {
            document.getElementById('testOutput').innerHTML = testResults.join('<br>');
        }
        
        // åŸºæœ¬åˆæœŸåŒ–ãƒ†ã‚¹ãƒˆ
        window.testBasicInitialization = async function() {
            testResults = [];
            logTest('Starting WASM Basic Tests', true, 'v1.0.0-basic');
            
            try {
                logTest('Importing kaspa-core.js', true);
                kaspa = await import('./kaspa-core.js');
                logTest('Module imported', !!kaspa);
                
                logTest('Initializing WASM', true);
                await kaspa.default('./kaspa-core_bg.wasm');
                logTest('WASM initialized', true);
                
                // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç¢ºèª
                if (kaspa.version) {
                    const version = kaspa.version();
                    logTest('Version check', true, version);
                } else {
                    logTest('Version check', false, 'version() not found');
                }
                
                // åŸºæœ¬ã‚¯ãƒ©ã‚¹ã®å­˜åœ¨ç¢ºèª
                logTest('PrivateKey class exists', !!kaspa.PrivateKey);
                logTest('Transaction class exists', !!kaspa.Transaction);
                logTest('createTransaction function exists', !!kaspa.createTransaction);
                logTest('createTransactions function exists', !!kaspa.createTransactions);
                
                // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°è¨­å®šï¼ˆä»–ã®ãƒ†ã‚¹ãƒˆã§ä½¿ç”¨ï¼‰
                window.kaspaReady = true;
                
            } catch (error) {
                logTest('Initialization failed', false, error.message);
            }
        };
        
        // PrivateKeyä½œæˆãƒ†ã‚¹ãƒˆ
        window.testPrivateKeyCreation = async function() {
            if (!kaspa || !window.kaspaReady) {
                logTest('PrivateKey test skipped', false, 'WASM not initialized - run test 1 first');
                return;
            }
            
            // WASMå®Œå…¨åˆæœŸåŒ–ã‚’å¾…æ©Ÿ
            if (!kaspa.PrivateKey) {
                logTest('PrivateKey test skipped', false, 'PrivateKey class not available');
                return;
            }
            
            try {
                // ãƒ†ã‚¹ãƒˆç”¨ã®æ—¢çŸ¥ã®ç§˜å¯†éµ
                const testKeyHex = '1111111111111111111111111111111111111111111111111111111111111111';
                logTest('Creating PrivateKey from hex', true, testKeyHex.substring(0, 8) + '...');
                
                const privateKey = new kaspa.PrivateKey(testKeyHex);
                logTest('PrivateKey created', !!privateKey);
                
                // toString ãƒ¡ã‚½ãƒƒãƒ‰ãƒ†ã‚¹ãƒˆ
                if (privateKey.toString) {
                    const keyString = privateKey.toString();
                    logTest('PrivateKey.toString()', keyString === testKeyHex, keyString.substring(0, 8) + '...');
                } else {
                    logTest('PrivateKey.toString()', false, 'method not found');
                }
                
                // toKeypair ãƒ¡ã‚½ãƒƒãƒ‰ãƒ†ã‚¹ãƒˆ
                if (privateKey.toKeypair) {
                    const keypair = privateKey.toKeypair();
                    logTest('PrivateKey.toKeypair()', !!keypair);
                } else {
                    logTest('PrivateKey.toKeypair()', false, 'method not found');
                }
                
                window.testPrivateKey = privateKey; // æ¬¡ã®ãƒ†ã‚¹ãƒˆç”¨ã«ä¿å­˜
                
            } catch (error) {
                logTest('PrivateKey creation failed', false, error.message);
            }
        };
        
        // ã‚¢ãƒ‰ãƒ¬ã‚¹ç”Ÿæˆãƒ†ã‚¹ãƒˆ
        window.testAddressGeneration = async function() {
            if (!kaspa || !window.kaspaReady || !window.testPrivateKey) {
                logTest('Address test skipped', false, 'Prerequisites not available - run tests 1-2 first');
                return;
            }
            
            try {
                const privateKey = window.testPrivateKey;
                
                // NetworkTypeç¢ºèª
                logTest('NetworkType available', !!kaspa.NetworkType);
                
                if (kaspa.NetworkType) {
                    // Keypairã‹ã‚‰ã‚¢ãƒ‰ãƒ¬ã‚¹ç”Ÿæˆ
                    const keypair = privateKey.toKeypair();
                    
                    if (keypair.toAddress) {
                        // ãƒ¡ã‚¤ãƒ³ãƒãƒƒãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹
                        if (kaspa.NetworkType.Mainnet) {
                            const mainnetAddr = keypair.toAddress(kaspa.NetworkType.Mainnet);
                            logTest('Mainnet address', !!mainnetAddr, mainnetAddr ? mainnetAddr.toString().substring(0, 20) + '...' : '');
                        }
                        
                        // ãƒ†ã‚¹ãƒˆãƒãƒƒãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹
                        if (kaspa.NetworkType.Testnet) {
                            const testnetAddr = keypair.toAddress(kaspa.NetworkType.Testnet);
                            logTest('Testnet address', !!testnetAddr, testnetAddr ? testnetAddr.toString().substring(0, 20) + '...' : '');
                        }
                    } else {
                        logTest('toAddress method', false, 'not found on keypair');
                    }
                } else {
                    logTest('NetworkType not found', false);
                }
                
            } catch (error) {
                logTest('Address generation failed', false, error.message);
            }
        };
        
        // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³é–¢æ•°ãƒ†ã‚¹ãƒˆ
        window.testTransactionFunction = async function() {
            if (!kaspa) {
                logTest('Transaction test skipped', false, 'WASM not initialized');
                return;
            }
            
            try {
                // createTransactioné–¢æ•°ã®åŸºæœ¬ãƒ†ã‚¹ãƒˆ
                logTest('createTransaction function type', typeof kaspa.createTransaction === 'function');
                
                if (kaspa.createTransaction) {
                    // é–¢æ•°ã®é•·ã•ï¼ˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ•°ï¼‰ç¢ºèª
                    logTest('createTransaction parameters', true, `expects ${kaspa.createTransaction.length} params`);
                }
                
                // createTransactionsé–¢æ•°ã®åŸºæœ¬ãƒ†ã‚¹ãƒˆ  
                logTest('createTransactions function type', typeof kaspa.createTransactions === 'function');
                
                if (kaspa.createTransactions) {
                    logTest('createTransactions parameters', true, `expects ${kaspa.createTransactions.length} params`);
                }
                
                // å®Ÿéš›ã®å‘¼ã³å‡ºã—ãƒ†ã‚¹ãƒˆï¼ˆã‚¨ãƒ©ãƒ¼ãŒäºˆæƒ³ã•ã‚Œã‚‹ï¼‰
                try {
                    const result = kaspa.createTransaction([], [], 0n);
                    logTest('createTransaction call', !!result, 'unexpected success');
                } catch (error) {
                    logTest('createTransaction call', true, `expected error: ${error.message.substring(0, 50)}...`);
                }
                
            } catch (error) {
                logTest('Transaction function test failed', false, error.message);
            }
        };
        
        // ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰å‡¦ç†ãƒ†ã‚¹ãƒˆ
        window.testPayloadHandling = async function() {
            if (!kaspa) {
                logTest('Payload test skipped', false, 'WASM not initialized');
                return;
            }
            
            try {
                // ãƒ†ã‚¹ãƒˆãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ä½œæˆ
                const testText = 'Hello Kaspa!';
                const testPayloadBytes = new TextEncoder().encode(testText);
                logTest('Test payload created', true, `${testPayloadBytes.length} bytes`);
                
                // Hexå¤‰æ›ãƒ†ã‚¹ãƒˆ
                const testPayloadHex = Array.from(testPayloadBytes, b => b.toString(16).padStart(2, '0')).join('');
                logTest('Payload hex conversion', true, testPayloadHex);
                
                // ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰é–¢é€£é–¢æ•°ã®ç¢ºèªã¨å®Ÿéš›ã®ãƒ†ã‚¹ãƒˆ
                const hexFunctions = ['textToHex', 'hexToText', 'arrayBufferToHex', 'hexToArrayBuffer'];
                
                hexFunctions.forEach(fnName => {
                    logTest(`${fnName} function`, !!kaspa[fnName]);
                });
                
                // å®Ÿéš›ã®Hexå¤‰æ›ãƒ†ã‚¹ãƒˆ
                if (kaspa.textToHex) {
                    try {
                        const hexResult = kaspa.textToHex(testText);
                        logTest('textToHex function', hexResult === testPayloadHex, hexResult);
                    } catch (e) {
                        logTest('textToHex function', false, e.message);
                    }
                }
                
                if (kaspa.hexToText) {
                    try {
                        const textResult = kaspa.hexToText(testPayloadHex);
                        logTest('hexToText function', textResult === testText, textResult);
                    } catch (e) {
                        logTest('hexToText function', false, e.message);
                    }
                }
                
                if (kaspa.arrayBufferToHex) {
                    try {
                        const hexResult = kaspa.arrayBufferToHex(testPayloadBytes);
                        logTest('arrayBufferToHex function', hexResult === testPayloadHex, hexResult);
                    } catch (e) {
                        logTest('arrayBufferToHex function', false, e.message);
                    }
                }
                
                if (kaspa.hexToArrayBuffer) {
                    try {
                        const bufferResult = kaspa.hexToArrayBuffer(testPayloadHex);
                        logTest('hexToArrayBuffer function', bufferResult.byteLength === testPayloadBytes.length, `${bufferResult.byteLength} bytes`);
                    } catch (e) {
                        logTest('hexToArrayBuffer function', false, e.message);
                    }
                }
                
            } catch (error) {
                logTest('Payload handling test failed', false, error.message);
            }
        };
        
        // è©³ç´°ãªãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ä½œæˆãƒ†ã‚¹ãƒˆ
        window.testDetailedTransaction = async function() {
            if (!kaspa || !window.testPrivateKey) {
                logTest('Detailed transaction test skipped', false, 'Prerequisites not met');
                return;
            }
            
            try {
                logTest('=== REAL TRANSACTION CREATION TEST ===', true);
                
                const privateKey = window.testPrivateKey;
                const keypair = privateKey.toKeypair();
                const address = keypair.toAddress(kaspa.NetworkType.Testnet);
                
                // Test different UTXO formats
                logTest('Test UTXO data prepared', true, '1 UTXOs');
                
                // Test different output formats
                logTest('Test output data prepared', true, '1 outputs');
                
                // Test payload
                const testPayload = 'Test file storage payload';
                const payloadHex = kaspa.textToHex ? kaspa.textToHex(testPayload) : '';
                logTest('Test payload prepared', true, `${testPayload.length} bytes`);
                
                // Test createTransaction with various parameter combinations
                logTest('Calling createTransaction with real data...', true);
                
                try {
                    // Method 1: Standard parameters
                    const result1 = kaspa.createTransaction([], [], address, 1000n, payloadHex);
                    logTest('createTransaction Method 1 (standard)', !!result1, 'success');
                } catch (e) {
                    logTest('createTransaction Method 1 (standard)', false, e.message.substring(0, 50));
                }
                
                try {
                    // Method 2: Object parameter
                    const result2 = kaspa.createTransaction({
                        utxos: [],
                        outputs: [],
                        changeAddress: address,
                        feeRate: 1000n,
                        payload: payloadHex
                    });
                    logTest('createTransaction Method 2 (object)', !!result2, 'success');
                } catch (e) {
                    logTest('createTransaction Method 2 (object)', false, e.message.substring(0, 50));
                }
                
                try {
                    // Method 3: createTransactions (multiple)
                    const result3 = kaspa.createTransactions({
                        utxos: [],
                        outputs: [],
                        changeAddress: address,
                        feeRate: 1000n,
                        payload: payloadHex
                    });
                    logTest('createTransactions method', !!result3, 'success');
                } catch (e) {
                    logTest('createTransactions method', false, e.message.substring(0, 50));
                }
                
                logTest('=== UTXO AND OUTPUT FORMAT TEST ===', true);
                
                // Test kaspaToSompi function
                if (kaspa.kaspaToSompi) {
                    try {
                        const sompi = kaspa.kaspaToSompi(1);
                        logTest('kaspaToSompi function', true, `1 KAS = ${sompi} sompi`);
                    } catch (e) {
                        logTest('kaspaToSompi function', false, e.message);
                    }
                }
                
                // Test Address constructor 
                if (kaspa.Address) {
                    try {
                        const addr = new kaspa.Address('kaspatest:qqk8m83ypfr4yg0ykaszpwjfm86c9vf22jgfg0jpc39h2k80nx8rxrumw8zpd');
                        logTest('Address constructor', !!addr, addr.toString().substring(0, 20) + '...');
                    } catch (e) {
                        logTest('Address constructor', false, e.message);
                    }
                }
                
                // Test PaymentOutput class
                if (kaspa.PaymentOutput) {
                    try {
                        const output = new kaspa.PaymentOutput(address, 100000000n);
                        logTest('PaymentOutput class', !!output);
                    } catch (e) {
                        logTest('PaymentOutput class', false, e.message);
                    }
                }
                
                // Test UtxoEntry class  
                if (kaspa.UtxoEntry) {
                    try {
                        const utxo = new kaspa.UtxoEntry();
                        logTest('UtxoEntry class', !!utxo);
                    } catch (e) {
                        logTest('UtxoEntry class', false, e.message);
                    }
                }
                
            } catch (error) {
                logTest('Detailed transaction test failed', false, error.message);
            }
        };
        
        // createTransactionè©³ç´°ãƒ‡ãƒãƒƒã‚°ãƒ†ã‚¹ãƒˆ
        window.testCreateTransactionDebug = async function() {
            if (!kaspa || !window.testPrivateKey) {
                logTest('Debug test skipped', false, 'Prerequisites not met');
                return;
            }
            
            try {
                logTest('=== DEBUG createTransaction ERROR ===', true);
                
                const privateKey = window.testPrivateKey;
                const keypair = privateKey.toKeypair();
                const address = keypair.toAddress(kaspa.NetworkType.Testnet);
                
                // è¤‡æ•°ã®ç•°ãªã‚‹UTXO/Outputå½¢å¼ã‚’ãƒ†ã‚¹ãƒˆ
                const testCases = [
                    {
                        name: 'Empty arrays',
                        utxos: [],
                        outputs: [],
                        feeRate: 1000n,
                        payload: 'test'
                    },
                    {
                        name: 'Simple UTXO format',
                        utxos: [{
                            outpoint: { transactionId: 'a'.repeat(64), index: 0 },
                            amount: 100000000n,
                            scriptPublicKey: { version: 0, script: new Uint8Array([0x76, 0xa9, 0x14]) }
                        }],
                        outputs: [{ address: address.toString(), amount: 50000000n }],
                        feeRate: 1000n,
                        payload: 'test payload'
                    },
                    {
                        name: 'PaymentOutput format',
                        utxos: [],
                        outputs: kaspa.PaymentOutput ? [new kaspa.PaymentOutput(address, 50000000n)] : [],
                        feeRate: 1000n,
                        payload: new Uint8Array([1, 2, 3, 4])
                    }
                ];
                
                for (const testCase of testCases) {
                    try {
                        logTest(`Testing ${testCase.name}...`, true);
                        
                        const result = kaspa.createTransaction(
                            testCase.utxos,
                            testCase.outputs,
                            address,
                            testCase.feeRate,
                            testCase.payload
                        );
                        
                        logTest(`${testCase.name}: SUCCESS`, true, typeof result);
                        
                    } catch (error) {
                        // è©³ç´°ãªã‚¨ãƒ©ãƒ¼æƒ…å ±
                        logTest(`${testCase.name}: FAILED`, false, error.message);
                        logTest(`Error type: ${error.name}`, false);
                        logTest(`Error stack (first 100 chars)`, false, error.stack ? error.stack.substring(0, 100) : 'No stack');
                        
                        // ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ãƒ­ã‚°
                        console.group(`ğŸ” ${testCase.name} Error Details`);
                        console.error('Full error:', error);
                        console.log('Test case:', testCase);
                        console.log('Address object:', address);
                        console.log('kaspa object keys:', Object.keys(kaspa).slice(0, 20));
                        console.groupEnd();
                    }
                }
                
                // é–¢æ•°signatureåˆ†æ
                logTest('=== FUNCTION SIGNATURE ANALYSIS ===', true);
                logTest('createTransaction length', true, `${kaspa.createTransaction.length} parameters`);
                logTest('createTransaction toString', true, kaspa.createTransaction.toString().substring(0, 100) + '...');
                
            } catch (error) {
                logTest('Debug test failed', false, error.message);
                console.error('Debug test error:', error);
            }
        };
        
        // è‡ªå‹•åˆæœŸåŒ–
        window.addEventListener('load', () => {
            updateDisplay();
        });
        
    </script>
</body>
</html>