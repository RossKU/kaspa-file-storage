<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kaspa P2P File Storage v3.6.1 - Stable Edition with Optional Parallel</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
        }
        .header {
            background: linear-gradient(135deg, #16213e 0%, #0f3460 100%);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        h1 {
            margin: 0;
            color: #e94560;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .container {
            background: #0f3460;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        .tab-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .tab-btn {
            flex: 1;
            background: #16213e;
            color: #e94560;
            border: 2px solid #e94560;
            padding: 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        .tab-btn:hover {
            background: #1a2540;
            transform: translateY(-2px);
        }
        .tab-btn.active {
            background: #e94560;
            color: white;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        button {
            background: #e94560;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: all 0.3s;
        }
        button:hover {
            background: #c13651;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(233, 69, 96, 0.3);
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        .small-button {
            background: #16213e;
            color: #49EACB;
            border: 1px solid #49EACB;
            padding: 8px 16px;
            font-size: 14px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .small-button:hover {
            background: #49EACB;
            color: #16213e;
        }
        input[type="text"], input[type="password"], input[type="number"], select {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            border: 1px solid #49EACB;
            background: #16213e;
            color: white;
            border-radius: 5px;
            font-size: 16px;
        }
        .drop-area {
            border: 3px dashed #49EACB;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin: 20px 0;
            background: #16213e;
            transition: all 0.3s;
        }
        .drop-area.dragover {
            background: #1f2940;
            border-color: #e94560;
        }
        .metric-box {
            background: #16213e;
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 15px;
            border: 1px solid #2a3f5f;
        }
        .metric-box h3 {
            margin-top: 0;
            color: #49EACB;
        }
        .log-container {
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 5px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 14px;
        }
        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-radius: 3px;
        }
        .log-info { color: #49EACB; }
        .log-error { color: #e94560; background: rgba(233, 69, 96, 0.1); }
        .log-success { color: #4ecdc4; }
        .log-warning { color: #ffa502; }
        .progress-bar {
            background: #16213e;
            border-radius: 5px;
            padding: 3px;
            margin: 10px 0;
        }
        .progress-fill {
            background: linear-gradient(90deg, #49EACB 0%, #4ecdc4 100%);
            height: 30px;
            border-radius: 3px;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #16213e;
            font-weight: bold;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-connected { background: #4ecdc4; }
        .status-disconnected { background: #e94560; }
        .chunk-info {
            background: #1a2540;
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
            font-family: monospace;
            font-size: 13px;
        }
        .upload-item {
            background: #16213e;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            border: 1px solid #2a3f5f;
        }
        .upload-title {
            font-weight: bold;
            color: #49EACB;
            margin-bottom: 5px;
        }
        .upload-meta {
            font-size: 14px;
            color: #999;
        }
        .copy-btn {
            background: #16213e;
            color: #49EACB;
            border: 1px solid #49EACB;
            padding: 8px 16px;
            font-size: 14px;
            float: right;
            margin-top: -40px;
        }
        .copy-btn:hover {
            background: #49EACB;
            color: #16213e;
        }
        code {
            background: #0a0a0a;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            color: #49EACB;
        }
        .history-tab-buttons {
            display: flex;
            gap: 5px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        .history-small-btn {
            background: #16213e;
            color: #49EACB;
            border: 1px solid #49EACB;
            padding: 6px 12px;
            font-size: 13px;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.3s;
            white-space: nowrap;
        }
        .history-small-btn:hover {
            background: #49EACB;
            color: #16213e;
        }
        .success-toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #4ecdc4;
            color: #16213e;
            padding: 15px 25px;
            border-radius: 5px;
            box-shadow: 0 4px 20px rgba(78, 205, 196, 0.3);
            animation: slideIn 0.3s ease-out;
            z-index: 1000;
        }
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 30px;
            margin-left: 10px;
            vertical-align: middle;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #666;
            transition: .4s;
            border-radius: 34px;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .toggle-slider {
            background-color: #49EACB;
        }
        input:checked + .toggle-slider:before {
            transform: translateX(30px);
        }
        .setting-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 15px 0;
        }
        .setting-label {
            font-size: 16px;
            color: #eee;
        }
        .setting-description {
            font-size: 12px;
            color: #999;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ” Kaspa P2P File Storage v3.6.1</h1>
        <p style="margin: 10px 0 0 0; color: #aaa;">Decentralized file storage using Kaspa blockchain - Stable Edition</p>
        <p style="margin: 5px 0 0 0; color: #999; font-size: 14px;">ä¸¦åˆ—ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰æ©Ÿèƒ½ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰ä»˜ãå®‰å®šç‰ˆ</p>
    </div>

    <!-- Tab Buttons -->
    <div class="tab-buttons">
        <button class="tab-btn active" onclick="switchTab('upload')">ğŸ“¤ Upload</button>
        <button class="tab-btn" onclick="switchTab('download')">ğŸ“¥ Download</button>
        <button class="tab-btn" onclick="switchTab('history')">ğŸ“‹ History</button>
        <button class="tab-btn" onclick="switchTab('settings')">âš™ï¸ Settings</button>
    </div>

    <!-- Upload Tab -->
    <div id="upload-tab" class="tab-content active">
        <div class="container">
            <h2>ğŸ“¤ ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰</h2>
            
            <div class="metric-box">
                <h3>ã‚¦ã‚©ãƒ¬ãƒƒãƒˆè¨­å®š</h3>
                <label>ç§˜å¯†éµï¼ˆBIP0340å½¢å¼ã€64æ–‡å­—ã®16é€²æ•°ï¼‰</label>
                <input type="password" id="privateKeyInput" placeholder="ç§˜å¯†éµã‚’å…¥åŠ›">
                <button onclick="importWallet()">ã‚¦ã‚©ãƒ¬ãƒƒãƒˆã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</button>
                <button onclick="generateNewWallet()">æ–°ã—ã„ã‚¦ã‚©ãƒ¬ãƒƒãƒˆã‚’ç”Ÿæˆ</button>
                
                <div id="walletInfo" style="margin-top: 15px; display: none;">
                    <p><strong>ã‚¢ãƒ‰ãƒ¬ã‚¹:</strong> <code id="walletAddress">-</code></p>
                    <p><strong>æ®‹é«˜:</strong> <span id="walletBalance">-</span> KAS</p>
                </div>
            </div>
            
            <div class="metric-box">
                <h3>ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ</h3>
                <div class="drop-area" id="dropArea">
                    <p>ğŸ“ ã“ã“ã«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‰ãƒ­ãƒƒãƒ—ã€ã¾ãŸã¯ã‚¯ãƒªãƒƒã‚¯ã—ã¦é¸æŠ</p>
                    <input type="file" id="fileInput" style="display: none;">
                </div>
                <div id="fileInfo" style="display: none; margin-top: 15px;">
                    <p><strong>ãƒ•ã‚¡ã‚¤ãƒ«å:</strong> <span id="fileName">-</span></p>
                    <p><strong>ã‚µã‚¤ã‚º:</strong> <span id="fileSize">-</span></p>
                    <p><strong>æ¨å®šãƒãƒ£ãƒ³ã‚¯æ•°:</strong> <span id="estimatedChunks">-</span></p>
                    <p><strong>æ¨å®šã‚³ã‚¹ãƒˆ:</strong> <span id="estimatedCost">-</span> KAS</p>
                </div>
            </div>
            
            <div class="metric-box">
                <h3>æš—å·åŒ–è¨­å®š</h3>
                <label>ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼ˆ8æ–‡å­—ä»¥ä¸Šï¼‰</label>
                <input type="password" id="passwordInput" placeholder="ãƒ•ã‚¡ã‚¤ãƒ«æš—å·åŒ–ç”¨ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰">
                <input type="password" id="passwordConfirm" placeholder="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ç¢ºèª">
            </div>
            
            <button onclick="startUpload()" id="uploadButton" disabled>ğŸš€ ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰é–‹å§‹</button>
            
            <div id="uploadProgress" style="display: none; margin-top: 20px;">
                <h3>ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰é€²è¡ŒçŠ¶æ³</h3>
                <div class="progress-bar">
                    <div class="progress-fill" id="uploadProgressBar" style="width: 0%">0%</div>
                </div>
                <p id="uploadStatus">æº–å‚™ä¸­...</p>
                <div id="chunkDetails"></div>
            </div>
        </div>
    </div>

    <!-- Download Tab -->
    <div id="download-tab" class="tab-content">
        <div class="container">
            <h2>ğŸ“¥ ãƒ•ã‚¡ã‚¤ãƒ«ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</h2>
            
            <div class="metric-box">
                <h3>ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±å…¥åŠ›</h3>
                <label>Transaction ID (å¿…é ˆ)</label>
                <input type="text" id="downloadTxId" placeholder="ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®TxID">
                
                <label>Block ID (ã‚ªãƒ—ã‚·ãƒ§ãƒ³ - è‡ªå‹•æ¤œç´¢ã•ã‚Œã¾ã™)</label>
                <input type="text" id="downloadBlockId" placeholder="ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ãŒå«ã¾ã‚Œã‚‹ãƒ–ãƒ­ãƒƒã‚¯ID">
                
                <label>ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰</label>
                <input type="password" id="downloadPassword" placeholder="ãƒ•ã‚¡ã‚¤ãƒ«å¾©å·åŒ–ç”¨ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰">
                
                <p style="font-size: 14px; color: #999; margin-top: 10px;">
                    å…¥åŠ›å½¢å¼:
                    <br>â€¢ TxID ã®ã¿ï¼ˆè‡ªå‹•ã§BlockIDã‚’æ¤œç´¢ï¼‰
                    <br>â€¢ TxID:BlockIDï¼ˆé«˜é€Ÿãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ï¼‰
                    <br>â€¢ TxID:BlockID:Passwordï¼ˆä¸€æ‹¬å…¥åŠ›ï¼‰
                </p>
            </div>
            
            <button onclick="startDownload()">ğŸ“¥ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰é–‹å§‹</button>
            
            <div id="downloadProgress" style="display: none; margin-top: 20px;">
                <h3>ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰é€²è¡ŒçŠ¶æ³</h3>
                <div class="progress-bar">
                    <div class="progress-fill" id="downloadProgressBar" style="width: 0%">0%</div>
                </div>
                <p id="downloadStatus">æº–å‚™ä¸­...</p>
            </div>
        </div>
    </div>
    
    <!-- History Tab -->
    <div id="history-tab" class="tab-content">
        <div class="container">
            <h2>ğŸ“‹ ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å±¥æ­´</h2>
            <div id="historyContent">
                <p style="color: #999;">å±¥æ­´ã‚’èª­ã¿è¾¼ã¿ä¸­...</p>
            </div>
        </div>
    </div>

    <!-- Settings Tab -->
    <div id="settings-tab" class="tab-content">
        <div class="container">
            <h2>âš™ï¸ è¨­å®š</h2>
            
            <div class="metric-box">
                <h3>ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯è¨­å®š</h3>
                <label>ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯</label>
                <select id="networkSelect">
                    <option value="testnet-10" selected>Testnet-10 (ãƒ†ã‚¹ãƒˆç”¨)</option>
                    <option value="mainnet">Mainnet (æœ¬ç•ª)</option>
                </select>
                
                <label>ãƒªãƒˆãƒ©ã‚¤å›æ•°</label>
                <input type="number" id="retryCount" value="3" min="0" max="10">
                
                <label>ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ (ç§’)</label>
                <input type="number" id="timeout" value="30" min="10" max="120">
            </div>
            
            <div class="metric-box">
                <h3>ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰è¨­å®š</h3>
                <div class="setting-row">
                    <div>
                        <div class="setting-label">ä¸¦åˆ—ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</div>
                        <div class="setting-description">10ãƒãƒ£ãƒ³ã‚¯ä»¥ä¸Šã®ãƒ•ã‚¡ã‚¤ãƒ«ã§8ä¸¦åˆ—æ¥ç¶šã‚’ä½¿ç”¨ï¼ˆå®Ÿé¨“çš„æ©Ÿèƒ½ï¼‰</div>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="parallelDownloadToggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="setting-row">
                    <div>
                        <div class="setting-label">ä¸¦åˆ—æ¥ç¶šæ•°</div>
                        <div class="setting-description">ä¸¦åˆ—ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰æ™‚ã®åŒæ™‚æ¥ç¶šæ•°ï¼ˆ2-16ï¼‰</div>
                    </div>
                    <input type="number" id="parallelConcurrency" value="8" min="2" max="16" style="width: 80px;">
                </div>
                <div class="setting-row">
                    <div>
                        <div class="setting-label">ä¸¦åˆ—ãƒ¢ãƒ¼ãƒ‰é–¾å€¤</div>
                        <div class="setting-description">ã“ã®æ•°ä»¥ä¸Šã®ãƒãƒ£ãƒ³ã‚¯ã§ä¸¦åˆ—ãƒ¢ãƒ¼ãƒ‰ã‚’ä½¿ç”¨</div>
                    </div>
                    <input type="number" id="parallelThreshold" value="10" min="5" max="100" style="width: 80px;">
                </div>
            </div>
            
            <div class="metric-box">
                <h3>ãƒ­ã‚°ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</h3>
                <button onclick="exportLogs()">ãƒ­ã‚°ã‚’JSONå½¢å¼ã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
                <button onclick="clearLogs()">ãƒ­ã‚°ã‚’ã‚¯ãƒªã‚¢</button>
            </div>
            
            <div class="metric-box">
                <h3>ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å±¥æ­´</h3>
                <div id="uploadHistory"></div>
            </div>
            
            <div class="metric-box">
                <h3>ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ</h3>
                <p style="font-size: 14px; color: #999; margin-bottom: 10px;">
                    ä¸¦åˆ—ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã®æœ€é©ãªåŒæ™‚æ¥ç¶šæ•°ã‚’ãƒ†ã‚¹ãƒˆã—ã¾ã™ï¼ˆç›®æ¨™: 100ãƒ–ãƒ­ãƒƒã‚¯/ç§’ï¼‰
                </p>
                <button onclick="testParallelPerformance()">ğŸš€ ä¸¦åˆ—ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</button>
                <div id="performanceResults" style="margin-top: 15px; display: none;">
                    <h4>ãƒ†ã‚¹ãƒˆçµæœ:</h4>
                    <div id="performanceChart" style="background: #0a0a0a; padding: 15px; border-radius: 5px; font-family: monospace; font-size: 12px;"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- System Log -->
    <div class="container">
        <h3>ğŸ“ ã‚·ã‚¹ãƒ†ãƒ ãƒ­ã‚°</h3>
        <div class="log-container" id="systemLog"></div>
        <button class="copy-btn" onclick="copyLog()">ãƒ­ã‚°ã‚’ã‚³ãƒ”ãƒ¼</button>
    </div>

    <script type="module">
        // Global state
        let kaspa = null;
        let rpcClient = null;
        let currentFile = null;
        let currentPassword = null;
        let processedChunks = [];
        let kaspaMetadata = null;
        let wsMonitorActive = false;
        let monitoredTransactions = new Map();
        let uploadHistory = [];
        let systemLogs = [];
        let privateKey = null;
        let address = null;
        let progressManager = null;
        let wsConnection = null;
        let wsConnected = false;
        let wsReconnectInterval = null;
        let workspaceHandle = null; // File System Access API directory handle
        let progressFileMap = new Map(); // Map of filename -> {cid, fileHandle}
        let historyManager = null; // Upload history manager
        let wsMonitorTimeout = null; // WebSocket monitoring timeout
        let uploadingChunksCount = 0; // Number of chunks being uploaded
        let uploadingMetaTx = false; // Whether meta-tx is being uploaded
        
        // Settings state
        let settings = {
            parallelDownloadEnabled: false, // Default OFF for v3.5.0 compatibility
            parallelConcurrency: 8,
            parallelThreshold: 10
        };
        
        // Load settings from localStorage
        function loadSettings() {
            const saved = localStorage.getItem('kaspaFileStorageSettings');
            if (saved) {
                try {
                    Object.assign(settings, JSON.parse(saved));
                    // Update UI
                    document.getElementById('parallelDownloadToggle').checked = settings.parallelDownloadEnabled;
                    document.getElementById('parallelConcurrency').value = settings.parallelConcurrency;
                    document.getElementById('parallelThreshold').value = settings.parallelThreshold;
                } catch (e) {
                    log('è¨­å®šã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
                }
            }
        }
        
        // Save settings to localStorage
        function saveSettings() {
            localStorage.setItem('kaspaFileStorageSettings', JSON.stringify(settings));
            log('è¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸ', 'success');
        }
        
        // Settings event listeners
        document.getElementById('parallelDownloadToggle').addEventListener('change', (e) => {
            settings.parallelDownloadEnabled = e.target.checked;
            saveSettings();
            if (e.target.checked) {
                log('ä¸¦åˆ—ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚’æœ‰åŠ¹ã«ã—ã¾ã—ãŸï¼ˆå®Ÿé¨“çš„æ©Ÿèƒ½ï¼‰', 'warning');
            } else {
                log('ä¸¦åˆ—ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚’ç„¡åŠ¹ã«ã—ã¾ã—ãŸï¼ˆå®‰å®šãƒ¢ãƒ¼ãƒ‰ï¼‰', 'success');
            }
        });
        
        document.getElementById('parallelConcurrency').addEventListener('change', (e) => {
            settings.parallelConcurrency = parseInt(e.target.value);
            saveSettings();
        });
        
        document.getElementById('parallelThreshold').addEventListener('change', (e) => {
            settings.parallelThreshold = parseInt(e.target.value);
            saveSettings();
        });
        
        // Upload History Manager Class
        class UploadHistoryManager {
            constructor() {
                this.dbName = 'kaspa-upload-history';
                this.fileName = 'kaspa-uploads.kenv';
                this.maxSize = 100 * 1024 * 1024; // 100MB
                this.archiveSize = 10 * 1024 * 1024; // 10MB chunks
                this.encryptionKey = null;
                log('[UploadHistoryManager] ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’åˆæœŸåŒ–ã—ã¾ã—ãŸ', 'debug');
            }
            
            async initialize(privateKey) {
                log('[UploadHistoryManager] åˆæœŸåŒ–ã‚’é–‹å§‹ã—ã¾ã™', 'debug');
                try {
                    // Derive encryption key from private key
                    const keyData = new TextEncoder().encode(privateKey);
                    const hashBuffer = await crypto.subtle.digest('SHA-256', keyData);
                    this.encryptionKey = await crypto.subtle.importKey(
                        'raw',
                        hashBuffer,
                        { name: 'AES-GCM' },
                        false,
                        ['encrypt', 'decrypt']
                    );
                    log('[UploadHistoryManager] æš—å·åŒ–ã‚­ãƒ¼ã‚’ç”Ÿæˆã—ã¾ã—ãŸ', 'debug');
                    
                    // Try to load existing history
                    await this.loadFromFile();
                    log('[UploadHistoryManager] åˆæœŸåŒ–ãŒå®Œäº†ã—ã¾ã—ãŸ', 'success');
                } catch (error) {
                    log(`[UploadHistoryManager] åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                    uploadHistory = [];
                }
            }
            
            async loadFromFile() {
                if (!workspaceHandle) {
                    log('[UploadHistoryManager] ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ãƒãƒ³ãƒ‰ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“', 'debug');
                    return;
                }
                
                try {
                    const fileHandle = await workspaceHandle.getFileHandle(this.fileName);
                    const file = await fileHandle.getFile();
                    const encryptedData = await file.text();
                    
                    if (!encryptedData || encryptedData.trim() === '') {
                        log('[UploadHistoryManager] å±¥æ­´ãƒ•ã‚¡ã‚¤ãƒ«ãŒç©ºã§ã™', 'debug');
                        uploadHistory = [];
                        return;
                    }
                    
                    // Decrypt data
                    const decrypted = await this.decrypt(encryptedData);
                    const data = JSON.parse(decrypted);
                    
                    if (data.version === '1.0' && Array.isArray(data.history)) {
                        uploadHistory = data.history;
                        log(`[UploadHistoryManager] ${uploadHistory.length}ä»¶ã®å±¥æ­´ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ`, 'success');
                    } else {
                        log('[UploadHistoryManager] ç„¡åŠ¹ãªå±¥æ­´ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ', 'error');
                        uploadHistory = [];
                    }
                } catch (error) {
                    if (error.name === 'NotFoundError') {
                        log('[UploadHistoryManager] å±¥æ­´ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆæ–°è¦ä½œæˆã—ã¾ã™ï¼‰', 'debug');
                        uploadHistory = [];
                    } else {
                        log(`[UploadHistoryManager] å±¥æ­´èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                        uploadHistory = [];
                    }
                }
            }
            
            async saveToFile() {
                if (!workspaceHandle) {
                    log('[UploadHistoryManager] ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ãƒãƒ³ãƒ‰ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“', 'warning');
                    return;
                }
                
                try {
                    const data = {
                        version: '1.0',
                        updated: new Date().toISOString(),
                        history: uploadHistory
                    };
                    
                    // Encrypt data
                    const encrypted = await this.encrypt(JSON.stringify(data, null, 2));
                    
                    // Write to file
                    const fileHandle = await workspaceHandle.getFileHandle(this.fileName, { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write(encrypted);
                    await writable.close();
                    
                    log(`[UploadHistoryManager] ${uploadHistory.length}ä»¶ã®å±¥æ­´ã‚’ä¿å­˜ã—ã¾ã—ãŸ`, 'success');
                } catch (error) {
                    log(`[UploadHistoryManager] å±¥æ­´ä¿å­˜ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                }
            }
            
            async encrypt(text) {
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const data = new TextEncoder().encode(text);
                
                const encrypted = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv: iv },
                    this.encryptionKey,
                    data
                );
                
                // Combine IV and encrypted data
                const combined = new Uint8Array(iv.length + encrypted.byteLength);
                combined.set(iv);
                combined.set(new Uint8Array(encrypted), iv.length);
                
                return btoa(String.fromCharCode(...combined));
            }
            
            async decrypt(encryptedText) {
                const combined = Uint8Array.from(atob(encryptedText), c => c.charCodeAt(0));
                const iv = combined.slice(0, 12);
                const encrypted = combined.slice(12);
                
                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv },
                    this.encryptionKey,
                    encrypted
                );
                
                return new TextDecoder().decode(decrypted);
            }
            
            async addEntry(entry) {
                // Add timestamp if not present
                if (!entry.timestamp) {
                    entry.timestamp = new Date().toISOString();
                }
                
                // Add to beginning of array (newest first)
                uploadHistory.unshift(entry);
                
                // Limit history size
                if (uploadHistory.length > 1000) {
                    uploadHistory = uploadHistory.slice(0, 1000);
                }
                
                // Save to file
                await this.saveToFile();
                
                // Update UI
                updateHistoryDisplay();
            }
            
            async exportHistory() {
                const data = {
                    version: '1.0',
                    exported: new Date().toISOString(),
                    history: uploadHistory
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `kaspa-upload-history-${new Date().toISOString().slice(0, 10)}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                log('å±¥æ­´ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ', 'success');
            }
        }
        
        // Progress Manager Class
        class ProgressManager {
            constructor() {
                this.uploads = new Map();
                this.downloads = new Map();
                this.activeDownload = null;
                this.downloads = new Map();
            }
            
            // Upload progress methods
            createUpload(txid, metadata) {
                const progress = {
                    txid: txid,
                    metadata: metadata,
                    chunks: new Map(),
                    startTime: Date.now(),
                    status: 'uploading'
                };
                this.uploads.set(txid, progress);
                return progress;
            }
            
            updateChunkStatus(txid, chunkIndex, status) {
                const upload = this.uploads.get(txid);
                if (!upload) return;
                
                upload.chunks.set(chunkIndex, {
                    status: status,
                    timestamp: Date.now()
                });
            }
            
            getUploadProgress(txid) {
                const upload = this.uploads.get(txid);
                if (!upload) return null;
                
                const total = upload.metadata.totalChunks;
                const completed = Array.from(upload.chunks.values())
                    .filter(chunk => chunk.status === 'completed').length;
                
                return {
                    txid: txid,
                    fileName: upload.metadata.fileName,
                    progress: (completed / total) * 100,
                    completed: completed,
                    total: total,
                    status: upload.status,
                    elapsedTime: Date.now() - upload.startTime
                };
            }
            
            // Download progress methods
            createDownload(txid, totalChunks) {
                const id = `${txid}_${Date.now()}`;
                const progress = {
                    id: id,
                    txid: txid,
                    totalChunks: totalChunks,
                    completedChunks: 0,
                    startTime: Date.now(),
                    lastUpdate: Date.now(),
                    status: 'downloading',
                    speed: 0,
                    throughput: 0,
                    errors: []
                };
                this.downloads.set(id, progress);
                this.activeDownload = id;
                return progress;
            }
            
            updateDownloadProgress(downloadId, completed, speed = 0, throughput = 0) {
                const download = this.downloads.get(downloadId || this.activeDownload);
                if (!download) return;
                
                download.completedChunks = completed;
                download.lastUpdate = Date.now();
                download.speed = speed;
                download.throughput = throughput;
                
                if (completed >= download.totalChunks) {
                    download.status = 'completed';
                }
            }
            
            getDownloadProgress(downloadId) {
                const download = this.downloads.get(downloadId || this.activeDownload);
                if (!download) return null;
                
                const elapsed = (Date.now() - download.startTime) / 1000;
                const progress = (download.completedChunks / download.totalChunks) * 100;
                const eta = download.speed > 0 ? 
                    (download.totalChunks - download.completedChunks) / download.speed : 0;
                
                return {
                    id: download.id,
                    txid: download.txid,
                    progress: progress,
                    completed: download.completedChunks,
                    total: download.totalChunks,
                    speed: download.speed,
                    throughput: download.throughput,
                    elapsed: elapsed,
                    eta: eta,
                    status: download.status
                };
            }
        }
        
        // Fixed Parallel Downloader Class with proper synchronization
        class ParallelDownloader {
            constructor(rpcClient, concurrency = 8) {
                this.rpcClient = rpcClient;
                this.concurrency = concurrency;
                this.queue = [];
                this.active = 0;
                this.results = new Map();
                this.errors = new Map();
                this.startTime = null;
                this.completedCount = 0;
                this.totalBytes = 0;
                this.queueLock = false; // Simple mutex for queue access
                this.maxRetries = 3; // Add retry capability
            }
            
            async downloadChunks(chunksMetadata, key, kaspaMetadata, progressCallback) {
                this.startTime = Date.now();
                this.queue = chunksMetadata.map((chunk, index) => ({ 
                    chunk, 
                    index, 
                    retries: 0 
                }));
                this.results = new Map();
                this.errors = new Map();
                this.completedCount = 0;
                this.totalBytes = 0;
                this.totalChunks = chunksMetadata.length;
                
                log(`ä¸¦åˆ—ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰é–‹å§‹: ${chunksMetadata.length}ãƒãƒ£ãƒ³ã‚¯, ${this.concurrency}ä¸¦åˆ—`, 'info');
                
                try {
                    // Start workers
                    const workers = [];
                    for (let i = 0; i < this.concurrency; i++) {
                        workers.push(this.worker(key, kaspaMetadata, progressCallback));
                    }
                    
                    // Wait for all workers
                    await Promise.all(workers);
                    
                    // Check for errors
                    if (this.errors.size > 0) {
                        const errorRate = (this.errors.size / chunksMetadata.length) * 100;
                        if (errorRate > 10) { // Allow up to 10% failure rate
                            const errorMsg = Array.from(this.errors.entries())
                                .map(([idx, err]) => `ãƒãƒ£ãƒ³ã‚¯${idx}: ${err}`)
                                .join(', ');
                            throw new Error(`ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼ç‡ãŒé«˜ã™ãã¾ã™ (${errorRate.toFixed(1)}%): ${errorMsg}`);
                        }
                    }
                    
                    // Sort results by index
                    const sortedChunks = [];
                    for (let i = 0; i < chunksMetadata.length; i++) {
                        if (!this.results.has(i)) {
                            if (this.errors.has(i)) {
                                throw new Error(`ãƒãƒ£ãƒ³ã‚¯${i}ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—: ${this.errors.get(i)}`);
                            } else {
                                throw new Error(`ãƒãƒ£ãƒ³ã‚¯${i}ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
                            }
                        }
                        sortedChunks.push(this.results.get(i));
                    }
                    
                    const elapsed = (Date.now() - this.startTime) / 1000;
                    const throughput = (this.totalBytes / 1024 / 1024) / elapsed;
                    log(`ä¸¦åˆ—ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†: ${elapsed.toFixed(1)}ç§’, ${throughput.toFixed(1)} MB/ç§’`, 'success');
                    
                    return sortedChunks;
                } catch (error) {
                    log(`ä¸¦åˆ—ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                    throw error;
                }
            }
            
            async worker(key, kaspaMetadata, progressCallback) {
                while (true) {
                    // Thread-safe queue access
                    let work = null;
                    
                    // Simple mutex implementation
                    while (this.queueLock) {
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                    
                    this.queueLock = true;
                    try {
                        if (this.queue.length > 0) {
                            work = this.queue.shift();
                            this.active++;
                        }
                    } finally {
                        this.queueLock = false;
                    }
                    
                    if (!work && this.active === 0) {
                        break; // All work done
                    }
                    
                    if (!work) {
                        await new Promise(resolve => setTimeout(resolve, 50));
                        continue;
                    }
                    
                    try {
                        const { chunk: chunkMeta, index } = work;
                        
                        // Get block data with retry
                        let response = null;
                        let lastError = null;
                        
                        for (let retry = 0; retry <= this.maxRetries; retry++) {
                            try {
                                response = await this.rpcClient.getBlock({
                                    hash: chunkMeta.blockId,
                                    includeTransactions: true
                                });
                                break; // Success
                            } catch (error) {
                                lastError = error;
                                if (retry < this.maxRetries) {
                                    log(`ãƒãƒ£ãƒ³ã‚¯${index}ã®å–å¾—ã«å¤±æ•— (ãƒªãƒˆãƒ©ã‚¤ ${retry + 1}/${this.maxRetries})`, 'warning');
                                    await new Promise(resolve => setTimeout(resolve, 1000 * (retry + 1)));
                                }
                            }
                        }
                        
                        if (!response) {
                            throw lastError || new Error('ãƒ–ãƒ­ãƒƒã‚¯å–å¾—ã«å¤±æ•—');
                        }
                        
                        const block = response?.block?.block || response?.block;
                        if (!block) {
                            throw new Error(`ãƒ–ãƒ­ãƒƒã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${chunkMeta.blockId}`);
                        }
                        
                        // Find transaction
                        let payload = null;
                        for (const tx of block.transactions || []) {
                            const txId = tx.verboseData?.transactionId || tx.id || tx.transactionId;
                            if (txId === chunkMeta.txid) {
                                if (tx.payload && tx.payload !== '') {
                                    payload = safeHexDecode(tx.payload, 'chunk payload');
                                    break;
                                }
                            }
                        }
                        
                        if (!payload) {
                            throw new Error(`ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
                        }
                        
                        // Decrypt and decompress
                        const compressed = await decryptChunk(payload, key, index);
                        const original = kaspaMetadata.compression.enabled ? 
                            lzDecompress(compressed) : compressed;
                        
                        this.results.set(index, original);
                        this.completedCount++;
                        this.totalBytes += original.length;
                        
                        // Update progress
                        const elapsed = (Date.now() - this.startTime) / 1000;
                        const speed = this.completedCount / elapsed;
                        const throughput = (this.totalBytes / 1024 / 1024) / elapsed;
                        
                        if (progressCallback) {
                            progressCallback({
                                completed: this.completedCount,
                                total: this.totalChunks,
                                speed: speed,
                                throughput: throughput
                            });
                        }
                        
                    } catch (error) {
                        work.retries++;
                        if (work.retries <= this.maxRetries) {
                            // Re-queue for retry
                            while (this.queueLock) {
                                await new Promise(resolve => setTimeout(resolve, 10));
                            }
                            this.queueLock = true;
                            try {
                                this.queue.push(work);
                            } finally {
                                this.queueLock = false;
                            }
                            log(`ãƒãƒ£ãƒ³ã‚¯${work.index}ã‚’å†è©¦è¡Œã‚­ãƒ¥ãƒ¼ã«è¿½åŠ  (${work.retries}/${this.maxRetries})`, 'warning');
                        } else {
                            log(`ãƒ¯ãƒ¼ã‚«ãƒ¼ã‚¨ãƒ©ãƒ¼ (ãƒãƒ£ãƒ³ã‚¯${work.index}): ${error.message}`, 'error');
                            this.errors.set(work.index, error.message);
                        }
                    } finally {
                        this.active--;
                    }
                }
            }
        }
        
        // Configuration
        const config = {
            network: 'testnet-10',
            retryCount: 3,
            timeout: 30000,
            testPrivateKey: 'b7e151628aed2a6abf7158809cf4f3c762e7160f38b4da56a784d9045190cfef'
        };

        // Safe hex decode function
        function safeHexDecode(hexString, context = '') {
            try {
                if (!hexString || typeof hexString !== 'string') {
                    throw new Error('Invalid hex string: null or not a string');
                }
                
                // Remove any whitespace
                hexString = hexString.trim();
                
                if (hexString.length === 0) {
                    throw new Error('Invalid hex string: empty');
                }
                
                if (hexString.length % 2 !== 0) {
                    throw new Error(`Invalid hex string: odd length (${hexString.length})`);
                }
                
                if (!/^[0-9a-fA-F]+$/.test(hexString)) {
                    throw new Error('Invalid hex string: contains non-hex characters');
                }
                
                const matches = hexString.match(/.{1,2}/g);
                if (!matches) {
                    throw new Error('Failed to parse hex string');
                }
                
                return new Uint8Array(matches.map(byte => parseInt(byte, 16)));
            } catch (e) {
                const errorMsg = context ? `Hex decode error in ${context}: ${e.message}` : `Hex decode error: ${e.message}`;
                log(errorMsg, 'error');
                throw new Error(errorMsg);
            }
        }
        
        // Logging system
        function log(message, type = 'info') {
            const timestamp = new Date();
            const logEntry = {
                timestamp: timestamp.toISOString(),
                time: timestamp.toLocaleTimeString(),
                type: type,
                message: message
            };
            
            systemLogs.push(logEntry);
            
            const logContainer = document.getElementById('systemLog');
            if (logContainer) {
                const logElement = document.createElement('div');
                logElement.className = `log-entry log-${type}`;
                logElement.textContent = `[${logEntry.time}] ${message}`;
                logContainer.appendChild(logElement);
                logContainer.scrollTop = logContainer.scrollHeight;
            }
            
            // Keep only last 1000 logs
            if (systemLogs.length > 1000) {
                systemLogs = systemLogs.slice(-1000);
            }
        }
        
        // Tab switching
        window.switchTab = function(tabName) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(`${tabName}-tab`).classList.add('active');
            
            if (tabName === 'history') {
                updateHistoryDisplay();
            }
        };
        
        // File handling
        const dropArea = document.getElementById('dropArea');
        const fileInput = document.getElementById('fileInput');
        
        dropArea.addEventListener('click', () => fileInput.click());
        dropArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropArea.classList.add('dragover');
        });
        dropArea.addEventListener('dragleave', () => {
            dropArea.classList.remove('dragover');
        });
        dropArea.addEventListener('drop', (e) => {
            e.preventDefault();
            dropArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) handleFileSelect(file);
        });
        
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) handleFileSelect(file);
        });
        
        function handleFileSelect(file) {
            currentFile = file;
            document.getElementById('fileName').textContent = file.name;
            document.getElementById('fileSize').textContent = formatFileSize(file.size);
            
            const chunkSize = 12 * 1024; // 12KB chunks
            const estimatedChunks = Math.ceil(file.size / chunkSize);
            document.getElementById('estimatedChunks').textContent = estimatedChunks;
            
            // Estimate cost (rough estimate)
            const estimatedCost = estimatedChunks * 0.00001;
            document.getElementById('estimatedCost').textContent = estimatedCost.toFixed(6);
            
            document.getElementById('fileInfo').style.display = 'block';
            checkUploadReady();
        }
        
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
            if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
            return (bytes / (1024 * 1024 * 1024)).toFixed(2) + ' GB';
        }
        
        // Wallet management
        window.importWallet = async function() {
            const keyInput = document.getElementById('privateKeyInput').value.trim();
            if (!keyInput || keyInput.length !== 64) {
                showToast('ç§˜å¯†éµã¯64æ–‡å­—ã®16é€²æ•°ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™', 'error');
                return;
            }
            
            try {
                await initializeKaspa();
                
                privateKey = keyInput;
                const privKey = new kaspa.PrivateKey(privateKey);
                const pubKey = privKey.toPublicKey();
                address = pubKey.toAddress(kaspa.NetworkType.Testnet).toString();
                
                document.getElementById('walletAddress').textContent = address;
                document.getElementById('walletInfo').style.display = 'block';
                
                // Initialize history manager
                if (!historyManager) {
                    historyManager = new UploadHistoryManager();
                    await historyManager.initialize(privateKey);
                }
                
                // Update balance
                await updateBalance();
                
                // Save to localStorage
                localStorage.setItem('kaspaPrivateKey', privateKey);
                
                log('ã‚¦ã‚©ãƒ¬ãƒƒãƒˆã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ', 'success');
                showToast('ã‚¦ã‚©ãƒ¬ãƒƒãƒˆã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«æˆåŠŸã—ã¾ã—ãŸ', 'success');
                checkUploadReady();
            } catch (error) {
                log(`ã‚¦ã‚©ãƒ¬ãƒƒãƒˆã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                showToast('ã‚¦ã‚©ãƒ¬ãƒƒãƒˆã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
            }
        };
        
        window.generateNewWallet = async function() {
            try {
                await initializeKaspa();
                
                // Generate mnemonic
                const mnemonic = kaspa.Mnemonic.random();
                const seed = mnemonic.toSeed();
                
                // Derive key
                const xprv = new kaspa.XPrv(seed);
                const account = await xprv.deriveAccount(0);
                const prvKey = await account.deriveKey(0, 0);
                
                privateKey = prvKey.toString();
                const pubKey = prvKey.toPublicKey();
                address = pubKey.toAddress(kaspa.NetworkType.Testnet).toString();
                
                // Show mnemonic
                alert(`æ–°ã—ã„ã‚¦ã‚©ãƒ¬ãƒƒãƒˆã‚’ç”Ÿæˆã—ã¾ã—ãŸã€‚\n\né‡è¦: ä»¥ä¸‹ã®ãƒªã‚«ãƒãƒªãƒ¼ãƒ•ãƒ¬ãƒ¼ã‚ºã‚’å®‰å…¨ã«ä¿ç®¡ã—ã¦ãã ã•ã„:\n${mnemonic.phrase}\n\nç§˜å¯†éµ: ${privateKey}`);
                
                document.getElementById('privateKeyInput').value = privateKey;
                document.getElementById('walletAddress').textContent = address;
                document.getElementById('walletInfo').style.display = 'block';
                
                // Initialize history manager
                if (!historyManager) {
                    historyManager = new UploadHistoryManager();
                    await historyManager.initialize(privateKey);
                }
                
                await updateBalance();
                
                // Save to localStorage
                localStorage.setItem('kaspaPrivateKey', privateKey);
                
                log('æ–°ã—ã„ã‚¦ã‚©ãƒ¬ãƒƒãƒˆã‚’ç”Ÿæˆã—ã¾ã—ãŸ', 'success');
                showToast('æ–°ã—ã„ã‚¦ã‚©ãƒ¬ãƒƒãƒˆã‚’ç”Ÿæˆã—ã¾ã—ãŸ', 'success');
                checkUploadReady();
            } catch (error) {
                log(`ã‚¦ã‚©ãƒ¬ãƒƒãƒˆç”Ÿæˆã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                showToast('ã‚¦ã‚©ãƒ¬ãƒƒãƒˆç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
            }
        };
        
        async function updateBalance() {
            if (!address || !rpcClient) return;
            
            try {
                const response = await rpcClient.getBalanceByAddress({ address });
                const balance = Number(response.balance) / 100000000;
                document.getElementById('walletBalance').textContent = balance.toFixed(8);
            } catch (error) {
                log(`æ®‹é«˜å–å¾—ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                document.getElementById('walletBalance').textContent = 'ã‚¨ãƒ©ãƒ¼';
            }
        }
        
        function checkUploadReady() {
            const hasFile = currentFile !== null;
            const hasWallet = privateKey !== null;
            const hasPassword = document.getElementById('passwordInput').value.length >= 8;
            const passwordMatch = document.getElementById('passwordInput').value === 
                                 document.getElementById('passwordConfirm').value;
            
            document.getElementById('uploadButton').disabled = 
                !(hasFile && hasWallet && hasPassword && passwordMatch);
        }
        
        // Password validation
        document.getElementById('passwordInput').addEventListener('input', checkUploadReady);
        document.getElementById('passwordConfirm').addEventListener('input', checkUploadReady);
        
        // Kaspa initialization
        async function initializeKaspa() {
            if (kaspa) return;
            
            try {
                const kaspaModule = await import('./kaspa-core.js');
                kaspa = kaspaModule.default || kaspaModule;
                
                if (kaspa.initWASM32Bindings) {
                    await kaspa.initWASM32Bindings();
                }
                
                log('Kaspa WASM initialized', 'success');
            } catch (error) {
                log(`KaspaåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                throw error;
            }
        }
        
        // RPC Client initialization
        async function initializeRPC() {
            if (rpcClient && rpcClient.isConnected) return;
            
            try {
                const network = document.getElementById('networkSelect').value;
                
                rpcClient = new kaspa.RpcClient({
                    resolver: new kaspa.Resolver(),
                    networkId: network
                });
                
                await rpcClient.connect();
                log(`RPCã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆæ¥ç¶šå®Œäº† (${network})`, 'success');
                
                // Update config
                config.network = network;
            } catch (error) {
                log(`RPCæ¥ç¶šã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                throw error;
            }
        }
        
        // Encryption functions
        async function deriveKey(password, salt) {
            const encoder = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                'raw',
                encoder.encode(password),
                'PBKDF2',
                false,
                ['deriveBits', 'deriveKey']
            );
            
            return crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: 100000,
                    hash: 'SHA-256'
                },
                keyMaterial,
                { name: 'AES-GCM', length: 256 },
                false,
                ['encrypt', 'decrypt']
            );
        }
        
        async function encryptChunk(data, key, chunkIndex) {
            const iv = crypto.getRandomValues(new Uint8Array(12));
            
            // Add chunk index to additional data for authentication
            const additionalData = new Uint8Array(4);
            new DataView(additionalData.buffer).setUint32(0, chunkIndex, true);
            
            const encrypted = await crypto.subtle.encrypt(
                {
                    name: 'AES-GCM',
                    iv: iv,
                    additionalData: additionalData
                },
                key,
                data
            );
            
            // Combine IV and ciphertext
            const result = new Uint8Array(iv.length + encrypted.byteLength);
            result.set(iv);
            result.set(new Uint8Array(encrypted), iv.length);
            
            return result;
        }
        
        async function decryptChunk(data, key, chunkIndex) {
            const iv = data.slice(0, 12);
            const ciphertext = data.slice(12);
            
            // Add chunk index to additional data for authentication
            const additionalData = new Uint8Array(4);
            new DataView(additionalData.buffer).setUint32(0, chunkIndex, true);
            
            const decrypted = await crypto.subtle.decrypt(
                {
                    name: 'AES-GCM',
                    iv: iv,
                    additionalData: additionalData
                },
                key,
                ciphertext
            );
            
            return new Uint8Array(decrypted);
        }
        
        // Compression functions
        function lzCompress(data) {
            // Simple LZ77-style compression
            const result = [];
            const windowSize = 4096;
            const lookaheadSize = 15;
            
            let pos = 0;
            while (pos < data.length) {
                let bestMatch = { distance: 0, length: 0 };
                
                // Search for matches in the sliding window
                const searchStart = Math.max(0, pos - windowSize);
                for (let i = searchStart; i < pos; i++) {
                    let matchLength = 0;
                    while (matchLength < lookaheadSize && 
                           pos + matchLength < data.length &&
                           data[i + matchLength] === data[pos + matchLength]) {
                        matchLength++;
                    }
                    
                    if (matchLength > bestMatch.length) {
                        bestMatch = { distance: pos - i, length: matchLength };
                    }
                }
                
                if (bestMatch.length >= 3) {
                    // Output distance/length pair
                    result.push(0); // Marker for compressed data
                    result.push((bestMatch.distance >> 8) & 0xFF);
                    result.push(bestMatch.distance & 0xFF);
                    result.push(bestMatch.length);
                    pos += bestMatch.length;
                } else {
                    // Output literal
                    result.push(1); // Marker for literal
                    result.push(data[pos]);
                    pos++;
                }
            }
            
            return new Uint8Array(result);
        }
        
        function lzDecompress(compressed) {
            const result = [];
            let pos = 0;
            
            while (pos < compressed.length) {
                const marker = compressed[pos++];
                
                if (marker === 0) {
                    // Compressed data
                    const distance = (compressed[pos++] << 8) | compressed[pos++];
                    const length = compressed[pos++];
                    
                    for (let i = 0; i < length; i++) {
                        result.push(result[result.length - distance]);
                    }
                } else {
                    // Literal
                    result.push(compressed[pos++]);
                }
            }
            
            return new Uint8Array(result);
        }
        
        // Base64 encoding/decoding
        function toBase64(uint8Array) {
            return btoa(String.fromCharCode.apply(null, uint8Array));
        }
        
        function fromBase64(base64) {
            const binaryString = atob(base64);
            const uint8Array = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                uint8Array[i] = binaryString.charCodeAt(i);
            }
            return uint8Array;
        }
        
        // Upload functionality
        window.startUpload = async function() {
            if (!currentFile || !privateKey) return;
            
            const password = document.getElementById('passwordInput').value;
            if (password.length < 8) {
                showToast('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯8æ–‡å­—ä»¥ä¸Šã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™', 'error');
                return;
            }
            
            if (password !== document.getElementById('passwordConfirm').value) {
                showToast('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒä¸€è‡´ã—ã¾ã›ã‚“', 'error');
                return;
            }
            
            currentPassword = password;
            
            try {
                await initializeRPC();
                
                document.getElementById('uploadProgress').style.display = 'block';
                document.getElementById('uploadButton').disabled = true;
                
                // Start workspace selection if not already selected
                if (!workspaceHandle) {
                    try {
                        workspaceHandle = await window.showDirectoryPicker({
                            mode: 'readwrite'
                        });
                        log('ä½œæ¥­ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’é¸æŠã—ã¾ã—ãŸ', 'success');
                    } catch (error) {
                        if (error.name === 'AbortError') {
                            log('ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªé¸æŠãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸ', 'warning');
                        }
                    }
                }
                
                // Create metadata
                const salt = crypto.getRandomValues(new Uint8Array(16));
                const key = await deriveKey(password, salt);
                
                const fileData = await currentFile.arrayBuffer();
                const fileBytes = new Uint8Array(fileData);
                
                // Compress file
                const compressed = lzCompress(fileBytes);
                const compressionRatio = (compressed.length / fileBytes.length);
                const useCompression = compressionRatio < 0.9;
                
                const dataToChunk = useCompression ? compressed : fileBytes;
                
                // Create chunks
                const chunkSize = 12 * 1024; // 12KB
                const chunks = [];
                processedChunks = [];
                
                for (let i = 0; i < dataToChunk.length; i += chunkSize) {
                    const chunk = dataToChunk.slice(i, Math.min(i + chunkSize, dataToChunk.length));
                    chunks.push(chunk);
                }
                
                log(`ãƒ•ã‚¡ã‚¤ãƒ«åˆ†å‰²å®Œäº†: ${chunks.length}ãƒãƒ£ãƒ³ã‚¯`, 'info');
                
                // Create metadata
                kaspaMetadata = {
                    version: '2.0',
                    file: {
                        name: currentFile.name,
                        size: currentFile.size,
                        type: currentFile.type,
                        lastModified: currentFile.lastModified
                    },
                    encryption: {
                        algorithm: 'AES-256-GCM',
                        pbkdf2: {
                            iterations: 100000,
                            salt: toBase64(salt)
                        }
                    },
                    compression: {
                        enabled: useCompression,
                        algorithm: useCompression ? 'LZ77' : 'none',
                        originalSize: fileBytes.length,
                        compressedSize: useCompression ? compressed.length : fileBytes.length
                    },
                    chunks: []
                };
                
                // Start WebSocket monitoring
                startWebSocketMonitoring();
                
                // Upload chunks
                for (let i = 0; i < chunks.length; i++) {
                    const encrypted = await encryptChunk(chunks[i], key, i);
                    
                    document.getElementById('uploadStatus').textContent = 
                        `ãƒãƒ£ãƒ³ã‚¯ ${i + 1}/${chunks.length} ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ä¸­...`;
                    
                    const progress = ((i + 1) / chunks.length * 100).toFixed(0);
                    document.getElementById('uploadProgressBar').style.width = progress + '%';
                    document.getElementById('uploadProgressBar').textContent = progress + '%';
                    
                    const txid = await uploadChunk(encrypted, i);
                    
                    processedChunks.push({
                        index: i,
                        txid: txid,
                        size: encrypted.length
                    });
                    
                    const chunkInfo = document.createElement('div');
                    chunkInfo.className = 'chunk-info';
                    chunkInfo.innerHTML = `ãƒãƒ£ãƒ³ã‚¯ ${i + 1}: TxID: <code>${txid}</code> (${encrypted.length} bytes)`;
                    document.getElementById('chunkDetails').appendChild(chunkInfo);
                }
                
                // Wait for all transactions to be included in blocks
                document.getElementById('uploadStatus').textContent = 
                    'ã™ã¹ã¦ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãŒãƒ–ãƒ­ãƒƒã‚¯ã«å«ã¾ã‚Œã‚‹ã®ã‚’å¾…ã£ã¦ã„ã¾ã™...';
                
                await waitForAllTransactions();
                
                // Create final metadata with block IDs
                for (let i = 0; i < processedChunks.length; i++) {
                    const chunk = processedChunks[i];
                    const blockInfo = monitoredTransactions.get(chunk.txid);
                    
                    kaspaMetadata.chunks.push({
                        index: i,
                        txid: chunk.txid,
                        blockId: blockInfo?.blockHash || 'pending',
                        size: chunk.size
                    });
                }
                
                // Upload metadata
                document.getElementById('uploadStatus').textContent = 'ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ä¸­...';
                const metadataJson = JSON.stringify(kaspaMetadata);
                const metadataBytes = new TextEncoder().encode(metadataJson);
                const metaTxId = await uploadChunk(metadataBytes, -1);
                
                // Wait for metadata transaction
                uploadingMetaTx = true;
                await waitForTransaction(metaTxId);
                uploadingMetaTx = false;
                
                const metaBlockInfo = monitoredTransactions.get(metaTxId);
                
                // Save to history
                const historyEntry = {
                    txid: metaTxId,
                    blockId: metaBlockInfo?.blockHash || 'pending',
                    fileName: currentFile.name,
                    fileSize: currentFile.size,
                    chunks: chunks.length,
                    timestamp: new Date().toISOString(),
                    network: config.network,
                    metadata: kaspaMetadata
                };
                
                if (historyManager) {
                    await historyManager.addEntry(historyEntry);
                }
                
                // Show completion
                document.getElementById('uploadStatus').textContent = 'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å®Œäº†ï¼';
                document.getElementById('uploadProgressBar').style.width = '100%';
                document.getElementById('uploadProgressBar').textContent = '100%';
                
                // Create download info
                const downloadInfo = `${metaTxId}:${metaBlockInfo?.blockHash || 'pending'}:${password}`;
                
                showToast('ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å®Œäº†ï¼ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰æƒ…å ±ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ', 'success');
                await navigator.clipboard.writeText(downloadInfo);
                
                alert(`ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å®Œäº†ï¼\n\nãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰æƒ…å ±ï¼ˆã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼æ¸ˆã¿ï¼‰:\n${downloadInfo}\n\nãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿TxID: ${metaTxId}`);
                
                // Reset
                stopWebSocketMonitoring();
                currentFile = null;
                document.getElementById('fileInput').value = '';
                document.getElementById('fileInfo').style.display = 'none';
                document.getElementById('passwordInput').value = '';
                document.getElementById('passwordConfirm').value = '';
                document.getElementById('uploadButton').disabled = false;
                
            } catch (error) {
                log(`ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                showToast('ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
                document.getElementById('uploadButton').disabled = false;
                stopWebSocketMonitoring();
            }
        };
        
        async function uploadChunk(data, chunkIndex) {
            try {
                // Create transaction
                const privKey = new kaspa.PrivateKey(privateKey);
                const pubKey = privKey.toPublicKey();
                const addr = pubKey.toAddress(kaspa.NetworkType.Testnet);
                
                // Get UTXOs
                const response = await rpcClient.getUtxosByAddresses({
                    addresses: [addr.toString()]
                });
                
                if (!response.entries || response.entries.length === 0) {
                    throw new Error('åˆ©ç”¨å¯èƒ½ãªUTXOãŒã‚ã‚Šã¾ã›ã‚“');
                }
                
                // Select UTXO
                const utxo = response.entries[0];
                const utxoAmount = Number(utxo.utxoEntry.amount);
                
                // Create transaction input
                const input = new kaspa.TransactionInput({
                    previousOutpoint: new kaspa.TransactionOutpoint({
                        transactionId: utxo.outpoint.transactionId,
                        index: utxo.outpoint.index
                    }),
                    signatureScript: new Uint8Array(0),
                    sequence: 0xffffffff,
                    sigOpCount: 1
                });
                
                // Create outputs (send back to self minus fee)
                const fee = 1000; // 0.00001 KAS
                const changeAmount = utxoAmount - fee;
                
                const output = new kaspa.TransactionOutput({
                    value: BigInt(changeAmount),
                    scriptPublicKey: new kaspa.ScriptPublicKey({
                        version: 0,
                        scriptPublicKey: addr.toScriptPublicKey().script
                    })
                });
                
                // Create transaction with payload
                const tx = new kaspa.Transaction({
                    version: 0,
                    inputs: [input],
                    outputs: [output],
                    lockTime: 0,
                    subnetworkId: new Uint8Array(20),
                    gas: 0,
                    payload: data
                });
                
                // Sign transaction
                const signature = await kaspa.signTransaction(tx, [privKey], kaspa.SighashType.All);
                tx.inputs[0].signatureScript = signature[0];
                
                // Submit transaction
                const submitResponse = await rpcClient.submitTransaction({
                    transaction: tx,
                    allowOrphan: false
                });
                
                const txid = submitResponse.transactionId;
                log(`ãƒãƒ£ãƒ³ã‚¯ ${chunkIndex + 1} é€ä¿¡å®Œäº†: ${txid}`, 'success');
                
                return txid;
            } catch (error) {
                log(`ãƒãƒ£ãƒ³ã‚¯ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                throw error;
            }
        }
        
        // WebSocket monitoring
        function startWebSocketMonitoring() {
            if (wsMonitorActive) return;
            
            wsMonitorActive = true;
            monitoredTransactions.clear();
            uploadingChunksCount = 0;
            
            // Connect to WebSocket
            connectWebSocket();
            
            log('WebSocketãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã‚’é–‹å§‹ã—ã¾ã—ãŸ', 'info');
        }
        
        function stopWebSocketMonitoring() {
            wsMonitorActive = false;
            if (wsConnection) {
                wsConnection.close();
                wsConnection = null;
            }
            if (wsReconnectInterval) {
                clearInterval(wsReconnectInterval);
                wsReconnectInterval = null;
            }
            if (wsMonitorTimeout) {
                clearTimeout(wsMonitorTimeout);
                wsMonitorTimeout = null;
            }
            log('WebSocketãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã‚’åœæ­¢ã—ã¾ã—ãŸ', 'info');
        }
        
        async function connectWebSocket() {
            if (!wsMonitorActive) return;
            
            try {
                const wsUrl = config.network === 'mainnet' ? 
                    'wss://kaspa-mainnet-public-ws.kaspa.stream' : 
                    'wss://kaspa-testnet-10-public-ws.kaspa.stream';
                
                wsConnection = new WebSocket(wsUrl);
                
                wsConnection.onopen = () => {
                    wsConnected = true;
                    log('WebSocketæ¥ç¶šæˆåŠŸ', 'success');
                    
                    // Subscribe to blocks
                    wsConnection.send(JSON.stringify({
                        id: 1,
                        command: 'notifyBlockAdded'
                    }));
                };
                
                wsConnection.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        if (data.type === 'blockAdded' && data.blockAdded) {
                            handleNewBlock(data.blockAdded.block);
                        }
                    } catch (error) {
                        log(`WebSocketãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                    }
                };
                
                wsConnection.onerror = (error) => {
                    log('WebSocketã‚¨ãƒ©ãƒ¼', 'error');
                    wsConnected = false;
                };
                
                wsConnection.onclose = () => {
                    wsConnected = false;
                    log('WebSocketæ¥ç¶šãŒåˆ‡æ–­ã•ã‚Œã¾ã—ãŸ', 'warning');
                    
                    // Reconnect after 5 seconds
                    if (wsMonitorActive && !wsReconnectInterval) {
                        wsReconnectInterval = setTimeout(() => {
                            wsReconnectInterval = null;
                            connectWebSocket();
                        }, 5000);
                    }
                };
                
            } catch (error) {
                log(`WebSocketæ¥ç¶šã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        }
        
        async function handleNewBlock(block) {
            if (!block || !block.transactions) return;
            
            const blockHash = block.verboseData?.hash || block.header?.hash;
            if (!blockHash) return;
            
            for (const tx of block.transactions) {
                const txId = tx.verboseData?.transactionId || tx.id;
                if (!txId) continue;
                
                // Check if this is one of our transactions
                const isOurTx = processedChunks.some(chunk => chunk.txid === txId) || 
                               (uploadingMetaTx && monitoredTransactions.size === processedChunks.length);
                
                if (isOurTx && !monitoredTransactions.has(txId)) {
                    monitoredTransactions.set(txId, {
                        txid: txId,
                        blockHash: blockHash,
                        timestamp: Date.now()
                    });
                    
                    log(`ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ ${txId} ãŒãƒ–ãƒ­ãƒƒã‚¯ ${blockHash} ã«å«ã¾ã‚Œã¾ã—ãŸ`, 'success');
                    
                    // Update progress if needed
                    if (progressManager) {
                        progressManager.updateChunkStatus(txId, processedChunks.findIndex(c => c.txid === txId), 'completed');
                    }
                }
            }
        }
        
        async function waitForTransaction(txid, timeout = 300000) {
            const startTime = Date.now();
            
            while (!monitoredTransactions.has(txid)) {
                if (Date.now() - startTime > timeout) {
                    throw new Error(`ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ ${txid} ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ`);
                }
                
                // Try to get transaction info via RPC as backup
                try {
                    const response = await rpcClient.getTransaction({
                        transactionId: txid,
                        includeBlockInfo: true
                    });
                    
                    if (response && response.block) {
                        monitoredTransactions.set(txid, {
                            txid: txid,
                            blockHash: response.block.hash,
                            timestamp: Date.now()
                        });
                        break;
                    }
                } catch (error) {
                    // Transaction not found yet
                }
                
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            return monitoredTransactions.get(txid);
        }
        
        async function waitForAllTransactions() {
            const total = processedChunks.length;
            let completed = 0;
            
            for (const chunk of processedChunks) {
                if (!monitoredTransactions.has(chunk.txid)) {
                    await waitForTransaction(chunk.txid);
                }
                completed++;
                
                const progress = (completed / total * 100).toFixed(0);
                document.getElementById('uploadProgressBar').style.width = progress + '%';
                document.getElementById('uploadProgressBar').textContent = progress + '%';
            }
        }
        
        // Download functionality
        window.startDownload = async function() {
            const inputValue = document.getElementById('downloadTxId').value.trim();
            const downloadPassword = document.getElementById('downloadPassword').value;
            
            if (!inputValue) {
                showToast('Transaction IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', 'error');
                return;
            }
            
            let txid, blockId;
            
            // Parse input (supports multiple formats)
            const parts = inputValue.split(':');
            if (parts.length >= 3) {
                // Format: TxID:BlockID:Password
                txid = parts[0];
                blockId = parts[1];
                if (!downloadPassword) {
                    document.getElementById('downloadPassword').value = parts[2];
                }
            } else if (parts.length === 2) {
                // Format: TxID:BlockID
                txid = parts[0];
                blockId = parts[1];
            } else {
                // Format: TxID only
                txid = parts[0];
                blockId = document.getElementById('downloadBlockId').value.trim();
            }
            
            if (!downloadPassword && !document.getElementById('downloadPassword').value) {
                showToast('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', 'error');
                return;
            }
            
            const password = downloadPassword || document.getElementById('downloadPassword').value;
            
            try {
                await initializeKaspa();
                await initializeRPC();
                
                document.getElementById('downloadProgress').style.display = 'block';
                
                // Get metadata
                document.getElementById('downloadStatus').textContent = 'ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ä¸­...';
                
                let metadataBlock;
                if (blockId) {
                    // Use provided block ID
                    metadataBlock = await getBlockData(blockId);
                } else {
                    // Search for block containing the transaction
                    document.getElementById('downloadStatus').textContent = 'ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ¤œç´¢ä¸­...';
                    metadataBlock = await findBlockContainingTx(txid);
                }
                
                if (!metadataBlock) {
                    throw new Error('ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ãƒ–ãƒ­ãƒƒã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                }
                
                // Extract metadata from transaction
                const metadataPayload = await extractPayloadFromBlock(metadataBlock, txid);
                if (!metadataPayload) {
                    throw new Error('ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                }
                
                const metadataJson = new TextDecoder().decode(metadataPayload);
                kaspaMetadata = JSON.parse(metadataJson);
                
                log(`ãƒ•ã‚¡ã‚¤ãƒ«: ${kaspaMetadata.file.name} (${kaspaMetadata.chunks.length}ãƒãƒ£ãƒ³ã‚¯)`, 'info');
                
                // Determine download mode based on settings and chunk count
                const useParallel = settings.parallelDownloadEnabled && 
                                   kaspaMetadata.chunks.length >= settings.parallelThreshold;
                
                if (useParallel) {
                    log(`ä¸¦åˆ—ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¾ã™ (${settings.parallelConcurrency}ä¸¦åˆ—)`, 'info');
                } else {
                    log('ã‚·ãƒ¼ã‚±ãƒ³ã‚·ãƒ£ãƒ«ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¾ã™', 'info');
                }
                
                // Derive key
                const salt = fromBase64(kaspaMetadata.encryption.pbkdf2.salt);
                const key = await deriveKey(password, salt);
                
                // Create progress tracker
                if (!progressManager) {
                    progressManager = new ProgressManager();
                }
                const downloadProgress = progressManager.createDownload(txid, kaspaMetadata.chunks.length);
                
                let chunks;
                
                if (useParallel) {
                    // Parallel download with fallback
                    try {
                        const downloader = new ParallelDownloader(rpcClient, settings.parallelConcurrency);
                        
                        chunks = await downloader.downloadChunks(
                            kaspaMetadata.chunks,
                            key,
                            kaspaMetadata,
                            (progress) => {
                                const percent = ((progress.completed / progress.total) * 100).toFixed(0);
                                document.getElementById('downloadProgressBar').style.width = percent + '%';
                                document.getElementById('downloadProgressBar').textContent = percent + '%';
                                document.getElementById('downloadStatus').textContent = 
                                    `${progress.completed}/${progress.total} ãƒãƒ£ãƒ³ã‚¯ (${progress.speed.toFixed(1)} ãƒãƒ£ãƒ³ã‚¯/ç§’, ${progress.throughput.toFixed(1)} MB/ç§’)`;
                                
                                progressManager.updateDownloadProgress(
                                    downloadProgress.id, 
                                    progress.completed,
                                    progress.speed,
                                    progress.throughput
                                );
                            }
                        );
                    } catch (parallelError) {
                        log(`ä¸¦åˆ—ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ${parallelError.message}`, 'error');
                        log('ã‚·ãƒ¼ã‚±ãƒ³ã‚·ãƒ£ãƒ«ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã—ã¾ã™', 'warning');
                        
                        // Fallback to sequential download
                        chunks = await sequentialDownload(kaspaMetadata, key, downloadProgress);
                    }
                } else {
                    // Sequential download (v3.5.0 compatible)
                    chunks = await sequentialDownload(kaspaMetadata, key, downloadProgress);
                }
                
                // Combine chunks
                document.getElementById('downloadStatus').textContent = 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å¾©å…ƒä¸­...';
                
                const combined = new Uint8Array(chunks.reduce((acc, chunk) => acc + chunk.length, 0));
                let offset = 0;
                for (const chunk of chunks) {
                    combined.set(chunk, offset);
                    offset += chunk.length;
                }
                
                // Decompress if needed
                const fileData = kaspaMetadata.compression.enabled ? 
                    lzDecompress(combined) : combined;
                
                // Create download
                const blob = new Blob([fileData], { type: kaspaMetadata.file.type });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = kaspaMetadata.file.name;
                a.click();
                URL.revokeObjectURL(url);
                
                document.getElementById('downloadStatus').textContent = 'ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†ï¼';
                document.getElementById('downloadProgressBar').style.width = '100%';
                document.getElementById('downloadProgressBar').textContent = '100%';
                
                showToast('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†ï¼', 'success');
                
            } catch (error) {
                log(`ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                showToast('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
            }
        };
        
        // Sequential download function (v3.5.0 compatible)
        async function sequentialDownload(kaspaMetadata, key, downloadProgress) {
            const chunks = [];
            
            for (let i = 0; i < kaspaMetadata.chunks.length; i++) {
                const chunkMeta = kaspaMetadata.chunks[i];
                
                document.getElementById('downloadStatus').textContent = 
                    `ãƒãƒ£ãƒ³ã‚¯ ${i + 1}/${kaspaMetadata.chunks.length} ã‚’å–å¾—ä¸­...`;
                
                let success = false;
                let lastError = null;
                
                // Retry logic
                for (let retry = 0; retry <= config.retryCount; retry++) {
                    try {
                        // Get block data
                        const response = await rpcClient.getBlock({
                            hash: chunkMeta.blockId,
                            includeTransactions: true
                        });
                        
                        const block = response?.block?.block || response?.block;
                        if (!block) {
                            throw new Error(`ãƒ–ãƒ­ãƒƒã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${chunkMeta.blockId}`);
                        }
                        
                        // Find transaction and extract payload
                        let payload = null;
                        for (const tx of block.transactions || []) {
                            const txId = tx.verboseData?.transactionId || tx.id || tx.transactionId;
                            if (txId === chunkMeta.txid) {
                                if (tx.payload && tx.payload !== '') {
                                    payload = safeHexDecode(tx.payload, 'chunk payload');
                                    break;
                                }
                            }
                        }
                        
                        if (!payload) {
                            throw new Error(`ãƒãƒ£ãƒ³ã‚¯ ${i + 1} ã®ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
                        }
                        
                        // Decrypt chunk
                        const decrypted = await decryptChunk(payload, key, i);
                        chunks.push(decrypted);
                        
                        const progress = ((i + 1) / kaspaMetadata.chunks.length * 100).toFixed(0);
                        document.getElementById('downloadProgressBar').style.width = progress + '%';
                        document.getElementById('downloadProgressBar').textContent = progress + '%';
                        
                        progressManager.updateDownloadProgress(downloadProgress.id, i + 1);
                        
                        success = true;
                        break;
                    } catch (error) {
                        lastError = error;
                        if (retry < config.retryCount) {
                            log(`ãƒãƒ£ãƒ³ã‚¯ ${i + 1} ã®å–å¾—ã«å¤±æ•— (ãƒªãƒˆãƒ©ã‚¤ ${retry + 1}/${config.retryCount})`, 'warning');
                            await new Promise(resolve => setTimeout(resolve, 1000 * (retry + 1)));
                        }
                    }
                }
                
                if (!success) {
                    throw lastError || new Error(`ãƒãƒ£ãƒ³ã‚¯ ${i + 1} ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ`);
                }
            }
            
            return chunks;
        }
        
        async function getBlockData(blockId) {
            try {
                const response = await rpcClient.getBlock({
                    hash: blockId,
                    includeTransactions: true
                });
                
                return response?.block?.block || response?.block;
            } catch (error) {
                log(`ãƒ–ãƒ­ãƒƒã‚¯å–å¾—ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                return null;
            }
        }
        
        async function findBlockContainingTx(txid) {
            try {
                // First try WebSocket monitoring if active
                if (monitoredTransactions.has(txid)) {
                    const blockInfo = monitoredTransactions.get(txid);
                    return await getBlockData(blockInfo.blockHash);
                }
                
                // Try to get transaction info
                const txResponse = await rpcClient.getTransaction({
                    transactionId: txid,
                    includeBlockInfo: true
                });
                
                if (txResponse && txResponse.block) {
                    return await getBlockData(txResponse.block.hash);
                }
                
                // Fallback: search recent blocks
                log('ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ¤œç´¢ä¸­...', 'info');
                
                const virtualSelectedParentBlueScoreResponse = await rpcClient.getVirtualSelectedParentBlueScore();
                const currentBlueScore = virtualSelectedParentBlueScoreResponse.blueScore;
                
                // Search last 1000 blocks
                for (let i = 0; i < 1000; i += 10) {
                    const blocksResponse = await rpcClient.getBlocksByLowHash({
                        lowHash: '0000000000000000000000000000000000000000000000000000000000000000',
                        includeBlocks: true,
                        includeTransactions: true
                    });
                    
                    if (blocksResponse && blocksResponse.blocks) {
                        for (const blockData of blocksResponse.blocks) {
                            const block = blockData.block;
                            if (block && block.transactions) {
                                for (const tx of block.transactions) {
                                    const foundTxId = tx.verboseData?.transactionId || tx.id;
                                    if (foundTxId === txid) {
                                        return block;
                                    }
                                }
                            }
                        }
                    }
                    
                    // Wait before next batch
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                throw new Error('ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’å«ã‚€ãƒ–ãƒ­ãƒƒã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
            } catch (error) {
                log(`ãƒ–ãƒ­ãƒƒã‚¯æ¤œç´¢ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                throw error;
            }
        }
        
        async function extractPayloadFromBlock(block, txid) {
            if (!block || !block.transactions) return null;
            
            for (const tx of block.transactions) {
                const foundTxId = tx.verboseData?.transactionId || tx.id || tx.transactionId;
                if (foundTxId === txid) {
                    if (tx.payload && tx.payload !== '') {
                        return safeHexDecode(tx.payload, 'metadata payload');
                    }
                }
            }
            
            return null;
        }
        
        // History display
        function updateHistoryDisplay() {
            const historyContent = document.getElementById('historyContent');
            
            if (uploadHistory.length === 0) {
                historyContent.innerHTML = '<p style="color: #999;">ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“</p>';
                return;
            }
            
            historyContent.innerHTML = '';
            
            uploadHistory.forEach((entry, index) => {
                const uploadDiv = document.createElement('div');
                uploadDiv.className = 'upload-item';
                
                const date = new Date(entry.timestamp);
                const downloadInfo = `${entry.txid}:${entry.blockId}`;
                
                uploadDiv.innerHTML = `
                    <div class="upload-title">${entry.fileName}</div>
                    <div class="upload-meta">
                        æ—¥æ™‚: ${date.toLocaleString()}<br>
                        ã‚µã‚¤ã‚º: ${formatFileSize(entry.fileSize)}<br>
                        ãƒãƒ£ãƒ³ã‚¯æ•°: ${entry.chunks}<br>
                        ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯: ${entry.network}<br>
                        TxID: <code>${entry.txid}</code>
                    </div>
                    <div class="history-tab-buttons">
                        <button class="history-small-btn" onclick="downloadWithPassword('${entry.txid}', '${entry.blockId}', ${index})">ğŸ” .kaspa (ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ä»˜ã)</button>
                        <button class="history-small-btn" onclick="downloadWithoutPassword('${entry.txid}', '${entry.blockId}', ${index})">ğŸ”“ .kaspa (ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãªã—)</button>
                        <button class="history-small-btn" onclick="copyDownloadInfo('${downloadInfo}', true)">ğŸ“‹ TxID (ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ä»˜ã)</button>
                        <button class="history-small-btn" onclick="copyDownloadInfo('${downloadInfo}', false)">ğŸ“‹ TxID (ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãªã—)</button>
                        <button class="history-small-btn" onclick="copyPasswordOnly(${index})">ğŸ”‘ ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã®ã¿</button>
                    </div>
                `;
                
                historyContent.appendChild(uploadDiv);
            });
        }
        
        // History actions
        window.downloadWithPassword = async function(txid, blockId, index) {
            const password = prompt('ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:');
            if (!password) return;
            
            const entry = uploadHistory[index];
            const fileData = {
                version: '1.0',
                type: 'kaspa-encrypted-file',
                txid: txid,
                blockId: blockId,
                metadata: entry.metadata,
                requiresPassword: true
            };
            
            const blob = new Blob([JSON.stringify(fileData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = entry.fileName + '.kaspa';
            a.click();
            URL.revokeObjectURL(url);
            
            showToast('.kaspaãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸï¼ˆãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ä»˜ãï¼‰', 'success');
        };
        
        window.downloadWithoutPassword = async function(txid, blockId, index) {
            const password = prompt('ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:');
            if (!password) return;
            
            const entry = uploadHistory[index];
            const fileData = {
                version: '1.0',
                type: 'kaspa-encrypted-file',
                txid: txid,
                blockId: blockId,
                metadata: entry.metadata,
                password: password,
                requiresPassword: false
            };
            
            const blob = new Blob([JSON.stringify(fileData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = entry.fileName + '.kaspa';
            a.click();
            URL.revokeObjectURL(url);
            
            showToast('.kaspaãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸï¼ˆãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰åŸ‹ã‚è¾¼ã¿ï¼‰', 'success');
        };
        
        window.copyDownloadInfo = async function(info, withPasswordPrompt) {
            if (withPasswordPrompt) {
                const password = prompt('ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:');
                if (password) {
                    await navigator.clipboard.writeText(`${info}:${password}`);
                    showToast('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰æƒ…å ±ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼ˆãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ä»˜ãï¼‰', 'success');
                }
            } else {
                await navigator.clipboard.writeText(info);
                showToast('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰æƒ…å ±ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼ˆãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãªã—ï¼‰', 'success');
            }
        };
        
        window.copyPasswordOnly = async function(index) {
            const password = prompt('ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:');
            if (password) {
                await navigator.clipboard.writeText(password);
                showToast('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ', 'success');
            }
        };
        
        // Settings functions
        window.exportLogs = function() {
            const data = {
                version: '1.0',
                exported: new Date().toISOString(),
                logs: systemLogs,
                settings: {
                    network: config.network,
                    retryCount: config.retryCount,
                    timeout: config.timeout
                }
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `kaspa-logs-${new Date().toISOString().slice(0, 10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            showToast('ãƒ­ã‚°ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ', 'success');
        };
        
        window.clearLogs = function() {
            if (confirm('ã™ã¹ã¦ã®ãƒ­ã‚°ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã‹ï¼Ÿ')) {
                systemLogs = [];
                document.getElementById('systemLog').innerHTML = '';
                showToast('ãƒ­ã‚°ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ', 'success');
            }
        };
        
        window.copyLog = async function() {
            const logText = systemLogs.map(log => 
                `[${log.time}] [${log.type.toUpperCase()}] ${log.message}`
            ).join('\n');
            
            await navigator.clipboard.writeText(logText);
            showToast('ãƒ­ã‚°ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ', 'success');
        };
        
        // Performance test
        window.testParallelPerformance = async function() {
            if (!rpcClient || !rpcClient.isConnected) {
                await initializeRPC();
            }
            
            document.getElementById('performanceResults').style.display = 'block';
            const chartDiv = document.getElementById('performanceChart');
            chartDiv.innerHTML = 'ãƒ†ã‚¹ãƒˆå®Ÿè¡Œä¸­...\n\n';
            
            const testConfigs = [2, 4, 8, 12, 16];
            const results = [];
            
            for (const concurrency of testConfigs) {
                chartDiv.innerHTML += `ä¸¦åˆ—åº¦ ${concurrency} ã‚’ãƒ†ã‚¹ãƒˆä¸­...\n`;
                
                try {
                    const startTime = Date.now();
                    const testBlocks = 100;
                    let completed = 0;
                    
                    // Create test workers
                    const workers = [];
                    const queue = [];
                    
                    // Get recent blocks for testing
                    const response = await rpcClient.getVirtualChainFromBlock({
                        startHash: '0000000000000000000000000000000000000000000000000000000000000000',
                        includeAcceptedTransactionIds: false
                    });
                    
                    if (response && response.removedChainBlockHashes) {
                        for (let i = 0; i < Math.min(testBlocks, response.removedChainBlockHashes.length); i++) {
                            queue.push(response.removedChainBlockHashes[i]);
                        }
                    }
                    
                    // Test parallel fetching
                    const workerFunc = async () => {
                        while (queue.length > 0) {
                            const blockHash = queue.shift();
                            if (!blockHash) continue;
                            
                            try {
                                await rpcClient.getBlock({
                                    hash: blockHash,
                                    includeTransactions: false
                                });
                                completed++;
                            } catch (error) {
                                // Ignore errors in test
                            }
                        }
                    };
                    
                    for (let i = 0; i < concurrency; i++) {
                        workers.push(workerFunc());
                    }
                    
                    await Promise.all(workers);
                    
                    const elapsed = (Date.now() - startTime) / 1000;
                    const speed = completed / elapsed;
                    
                    results.push({
                        concurrency: concurrency,
                        speed: speed,
                        elapsed: elapsed
                    });
                    
                    chartDiv.innerHTML += `å®Œäº†: ${speed.toFixed(1)} ãƒ–ãƒ­ãƒƒã‚¯/ç§’\n`;
                    
                } catch (error) {
                    chartDiv.innerHTML += `ã‚¨ãƒ©ãƒ¼: ${error.message}\n`;
                }
                
                chartDiv.innerHTML += '\n';
            }
            
            // Show results
            chartDiv.innerHTML += '=== ãƒ†ã‚¹ãƒˆçµæœ ===\n\n';
            results.forEach(result => {
                const bar = 'â–ˆ'.repeat(Math.round(result.speed / 5));
                chartDiv.innerHTML += `${result.concurrency}ä¸¦åˆ—: ${bar} ${result.speed.toFixed(1)} blocks/s\n`;
            });
            
            const best = results.reduce((a, b) => a.speed > b.speed ? a : b);
            chartDiv.innerHTML += `\næœ€é©ãªä¸¦åˆ—åº¦: ${best.concurrency} (${best.speed.toFixed(1)} blocks/s)`;
            
            showToast('ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
        };
        
        // Toast notification
        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = 'success-toast';
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.remove();
            }, 3000);
        }
        
        // Initialize on load
        window.addEventListener('load', async () => {
            log('Kaspa P2P File Storage v3.6.1 èµ·å‹•', 'info');
            
            // Load settings
            loadSettings();
            
            // Try to load saved private key
            const savedKey = localStorage.getItem('kaspaPrivateKey');
            if (savedKey) {
                document.getElementById('privateKeyInput').value = savedKey;
                await importWallet();
            }
            
            // Update network settings
            document.getElementById('networkSelect').addEventListener('change', (e) => {
                config.network = e.target.value;
                if (rpcClient) {
                    rpcClient.disconnect();
                    rpcClient = null;
                }
            });
            
            document.getElementById('retryCount').addEventListener('change', (e) => {
                config.retryCount = parseInt(e.target.value);
            });
            
            document.getElementById('timeout').addEventListener('change', (e) => {
                config.timeout = parseInt(e.target.value) * 1000;
            });
            
            // Initialize progress manager
            progressManager = new ProgressManager();
        });
    </script>
</body>
</html>