<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kaspa P2P File Storage v3.6.1 - Stable Edition with Optional Parallel</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
        }
        .header {
            background: linear-gradient(135deg, #16213e 0%, #0f3460 100%);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        h1 {
            margin: 0;
            color: #e94560;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .container {
            background: #0f3460;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        .tab-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .tab-btn {
            flex: 1;
            background: #16213e;
            color: #e94560;
            border: 2px solid #e94560;
            padding: 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        .tab-btn:hover {
            background: #1a2540;
            transform: translateY(-2px);
        }
        .tab-btn.active {
            background: #e94560;
            color: white;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        button {
            background: #e94560;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: all 0.3s;
        }
        button:hover {
            background: #c13651;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(233, 69, 96, 0.3);
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        .small-button {
            background: #16213e;
            color: #49EACB;
            border: 1px solid #49EACB;
            padding: 8px 16px;
            font-size: 14px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .small-button:hover {
            background: #49EACB;
            color: #16213e;
        }
        input[type="text"], input[type="password"], input[type="number"], select {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            border: 1px solid #49EACB;
            background: #16213e;
            color: white;
            border-radius: 5px;
            font-size: 16px;
        }
        .drop-area {
            border: 3px dashed #49EACB;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin: 20px 0;
            background: #16213e;
            transition: all 0.3s;
        }
        .drop-area.dragover {
            background: #1f2940;
            border-color: #e94560;
        }
        .metric-box {
            background: #16213e;
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 15px;
            border: 1px solid #2a3f5f;
        }
        .metric-box h3 {
            margin-top: 0;
            color: #49EACB;
        }
        .log-container {
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 5px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 14px;
        }
        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-radius: 3px;
        }
        .log-info { color: #49EACB; }
        .log-error { color: #e94560; background: rgba(233, 69, 96, 0.1); }
        .log-success { color: #4ecdc4; }
        .log-warning { color: #ffa502; }
        .progress-bar {
            background: #16213e;
            border-radius: 5px;
            padding: 3px;
            margin: 10px 0;
        }
        .progress-fill {
            background: linear-gradient(90deg, #49EACB 0%, #4ecdc4 100%);
            height: 30px;
            border-radius: 3px;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #16213e;
            font-weight: bold;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-connected { background: #4ecdc4; }
        .status-disconnected { background: #e94560; }
        .chunk-info {
            background: #1a2540;
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
            font-family: monospace;
            font-size: 13px;
        }
        .upload-item {
            background: #16213e;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            border: 1px solid #2a3f5f;
        }
        .upload-title {
            font-weight: bold;
            color: #49EACB;
            margin-bottom: 5px;
        }
        .upload-meta {
            font-size: 14px;
            color: #999;
        }
        .copy-btn {
            background: #16213e;
            color: #49EACB;
            border: 1px solid #49EACB;
            padding: 8px 16px;
            font-size: 14px;
            float: right;
            margin-top: -40px;
        }
        .copy-btn:hover {
            background: #49EACB;
            color: #16213e;
        }
        code {
            background: #0a0a0a;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            color: #49EACB;
        }
        .history-tab-buttons {
            display: flex;
            gap: 5px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        .history-small-btn {
            background: #16213e;
            color: #49EACB;
            border: 1px solid #49EACB;
            padding: 6px 12px;
            font-size: 13px;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.3s;
            white-space: nowrap;
        }
        .history-small-btn:hover {
            background: #49EACB;
            color: #16213e;
        }
        .success-toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #4ecdc4;
            color: #16213e;
            padding: 15px 25px;
            border-radius: 5px;
            box-shadow: 0 4px 20px rgba(78, 205, 196, 0.3);
            animation: slideIn 0.3s ease-out;
            z-index: 1000;
        }
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 30px;
            margin-left: 10px;
            vertical-align: middle;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #666;
            transition: .4s;
            border-radius: 34px;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .toggle-slider {
            background-color: #49EACB;
        }
        input:checked + .toggle-slider:before {
            transform: translateX(30px);
        }
        .setting-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 15px 0;
        }
        .setting-label {
            font-size: 16px;
            color: #eee;
        }
        .setting-description {
            font-size: 12px;
            color: #999;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üîê Kaspa P2P File Storage v3.6.1</h1>
        <p style="margin: 10px 0 0 0; color: #aaa;">Decentralized file storage using Kaspa blockchain - Stable Edition</p>
        <p style="margin: 5px 0 0 0; color: #999; font-size: 14px;">‰∏¶Âàó„ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÊ©üËÉΩÔºà„Ç™„Éó„Ç∑„Éß„É≥Ôºâ‰ªò„ÅçÂÆâÂÆöÁâà</p>
    </div>

    <!-- Tab Buttons -->
    <div class="tab-buttons">
        <button class="tab-btn active" onclick="switchTab('upload')">üì§ Upload</button>
        <button class="tab-btn" onclick="switchTab('download')">üì• Download</button>
        <button class="tab-btn" onclick="switchTab('history')">üìã History</button>
        <button class="tab-btn" onclick="switchTab('settings')">‚öôÔ∏è Settings</button>
    </div>

    <!-- Upload Tab -->
    <div id="upload-tab" class="tab-content active">
        <div class="container">
            <h2>üì§ „Éï„Ç°„Ç§„É´„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ</h2>
            
            <div class="metric-box">
                <h3>„Ç¶„Ç©„É¨„ÉÉ„ÉàË®≠ÂÆö</h3>
                <label>ÁßòÂØÜÈçµÔºàBIP0340ÂΩ¢Âºè„ÄÅ64ÊñáÂ≠ó„ÅÆ16ÈÄ≤Êï∞Ôºâ</label>
                <input type="password" id="privateKeyInput" placeholder="ÁßòÂØÜÈçµ„ÇíÂÖ•Âäõ">
                <button onclick="importWallet()">„Ç¶„Ç©„É¨„ÉÉ„Éà„Çí„Ç§„É≥„Éù„Éº„Éà</button>
                <button onclick="generateNewWallet()">Êñ∞„Åó„ÅÑ„Ç¶„Ç©„É¨„ÉÉ„Éà„ÇíÁîüÊàê</button>
                
                <div id="walletInfo" style="margin-top: 15px; display: none;">
                    <p><strong>„Ç¢„Éâ„É¨„Çπ:</strong> <code id="walletAddress">-</code></p>
                    <p><strong>ÊÆãÈ´ò:</strong> <span id="walletBalance">-</span> KAS</p>
                </div>
            </div>
            
            <div class="metric-box">
                <h3>„Éï„Ç°„Ç§„É´ÈÅ∏Êäû</h3>
                <div class="drop-area" id="dropArea">
                    <p>üìÅ „Åì„Åì„Å´„Éï„Ç°„Ç§„É´„Çí„Éâ„É≠„ÉÉ„Éó„ÄÅ„Åæ„Åü„ÅØ„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶ÈÅ∏Êäû</p>
                    <input type="file" id="fileInput" style="display: none;">
                </div>
                <div id="fileInfo" style="display: none; margin-top: 15px;">
                    <p><strong>„Éï„Ç°„Ç§„É´Âêç:</strong> <span id="fileName">-</span></p>
                    <p><strong>„Çµ„Ç§„Ç∫:</strong> <span id="fileSize">-</span></p>
                    <p><strong>Êé®ÂÆö„ÉÅ„É£„É≥„ÇØÊï∞:</strong> <span id="estimatedChunks">-</span></p>
                    <p><strong>Êé®ÂÆö„Ç≥„Çπ„Éà:</strong> <span id="estimatedCost">-</span> KAS</p>
                </div>
            </div>
            
            <div class="metric-box">
                <h3>ÊöóÂè∑ÂåñË®≠ÂÆö</h3>
                <label>„Éë„Çπ„ÉØ„Éº„ÉâÔºà8ÊñáÂ≠ó‰ª•‰∏äÔºâ</label>
                <input type="password" id="passwordInput" placeholder="„Éï„Ç°„Ç§„É´ÊöóÂè∑ÂåñÁî®„Éë„Çπ„ÉØ„Éº„Éâ">
                <input type="password" id="passwordConfirm" placeholder="„Éë„Çπ„ÉØ„Éº„ÉâÁ¢∫Ë™ç">
            </div>
            
            <button onclick="startUpload()" id="uploadButton" disabled>üöÄ „Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÈñãÂßã</button>
            
            <div id="uploadProgress" style="display: none; margin-top: 20px;">
                <h3>„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÈÄ≤Ë°åÁä∂Ê≥Å</h3>
                <div class="progress-bar">
                    <div class="progress-fill" id="uploadProgressBar" style="width: 0%">0%</div>
                </div>
                <p id="uploadStatus">Ê∫ñÂÇô‰∏≠...</p>
                <div id="chunkDetails"></div>
            </div>
        </div>
    </div>

    <!-- Download Tab -->
    <div id="download-tab" class="tab-content">
        <div class="container">
            <h2>üì• „Éï„Ç°„Ç§„É´„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ</h2>
            
            <div class="metric-box">
                <h3>„Éï„Ç°„Ç§„É´ÊÉÖÂ†±ÂÖ•Âäõ</h3>
                <label>Transaction ID (ÂøÖÈ†à)</label>
                <input type="text" id="downloadTxId" placeholder="„É°„Çø„Éá„Éº„Çø„Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥„ÅÆTxID">
                
                <label>Block ID („Ç™„Éó„Ç∑„Éß„É≥ - Ëá™ÂãïÊ§úÁ¥¢„Åï„Çå„Åæ„Åô)</label>
                <input type="text" id="downloadBlockId" placeholder="„É°„Çø„Éá„Éº„Çø„ÅåÂê´„Åæ„Çå„Çã„Éñ„É≠„ÉÉ„ÇØID">
                
                <label>„Éë„Çπ„ÉØ„Éº„Éâ</label>
                <input type="password" id="downloadPassword" placeholder="„Éï„Ç°„Ç§„É´Âæ©Âè∑ÂåñÁî®„Éë„Çπ„ÉØ„Éº„Éâ">
                
                <p style="font-size: 14px; color: #999; margin-top: 10px;">
                    ÂÖ•ÂäõÂΩ¢Âºè:
                    <br>‚Ä¢ TxID „ÅÆ„ÅøÔºàËá™Âãï„ÅßBlockID„ÇíÊ§úÁ¥¢Ôºâ
                    <br>‚Ä¢ TxID:BlockIDÔºàÈ´òÈÄü„ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÔºâ
                    <br>‚Ä¢ TxID:BlockID:PasswordÔºà‰∏ÄÊã¨ÂÖ•ÂäõÔºâ
                </p>
            </div>
            
            <button onclick="startDownload()">üì• „ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÈñãÂßã</button>
            
            <div id="downloadProgress" style="display: none; margin-top: 20px;">
                <h3>„ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÈÄ≤Ë°åÁä∂Ê≥Å</h3>
                <div class="progress-bar">
                    <div class="progress-fill" id="downloadProgressBar" style="width: 0%">0%</div>
                </div>
                <p id="downloadStatus">Ê∫ñÂÇô‰∏≠...</p>
            </div>
        </div>
    </div>
    
    <!-- History Tab -->
    <div id="history-tab" class="tab-content">
        <div class="container">
            <h2>üìã „Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂ±•Ê≠¥</h2>
            <div id="historyContent">
                <p style="color: #999;">Â±•Ê≠¥„ÇíË™≠„ÅøËæº„Åø‰∏≠...</p>
            </div>
        </div>
    </div>

    <!-- Settings Tab -->
    <div id="settings-tab" class="tab-content">
        <div class="container">
            <h2>‚öôÔ∏è Ë®≠ÂÆö</h2>
            
            <div class="metric-box">
                <h3>„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØË®≠ÂÆö</h3>
                <label>„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ</label>
                <select id="networkSelect">
                    <option value="testnet-10" selected>Testnet-10 („ÉÜ„Çπ„ÉàÁî®)</option>
                    <option value="mainnet">Mainnet (Êú¨Áï™)</option>
                </select>
                
                <label>„É™„Éà„É©„Ç§ÂõûÊï∞</label>
                <input type="number" id="retryCount" value="3" min="0" max="10">
                
                <label>„Çø„Ç§„É†„Ç¢„Ç¶„Éà (Áßí)</label>
                <input type="number" id="timeout" value="30" min="10" max="120">
            </div>
            
            <div class="metric-box">
                <h3>„ÉÄ„Ç¶„É≥„É≠„Éº„ÉâË®≠ÂÆö</h3>
                <div class="setting-row">
                    <div>
                        <div class="setting-label">‰∏¶Âàó„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ</div>
                        <div class="setting-description">10„ÉÅ„É£„É≥„ÇØ‰ª•‰∏ä„ÅÆ„Éï„Ç°„Ç§„É´„Åß8‰∏¶ÂàóÊé•Á∂ö„Çí‰ΩøÁî®ÔºàÂÆüÈ®ìÁöÑÊ©üËÉΩÔºâ</div>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="parallelDownloadToggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="setting-row">
                    <div>
                        <div class="setting-label">‰∏¶ÂàóÊé•Á∂öÊï∞</div>
                        <div class="setting-description">‰∏¶Âàó„ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÊôÇ„ÅÆÂêåÊôÇÊé•Á∂öÊï∞Ôºà2-16Ôºâ</div>
                    </div>
                    <input type="number" id="parallelConcurrency" value="8" min="2" max="16" style="width: 80px;">
                </div>
                <div class="setting-row">
                    <div>
                        <div class="setting-label">‰∏¶Âàó„É¢„Éº„ÉâÈñæÂÄ§</div>
                        <div class="setting-description">„Åì„ÅÆÊï∞‰ª•‰∏ä„ÅÆ„ÉÅ„É£„É≥„ÇØ„Åß‰∏¶Âàó„É¢„Éº„Éâ„Çí‰ΩøÁî®</div>
                    </div>
                    <input type="number" id="parallelThreshold" value="10" min="5" max="100" style="width: 80px;">
                </div>
            </div>
            
            <div class="metric-box">
                <h3>„É≠„Ç∞„Ç®„ÇØ„Çπ„Éù„Éº„Éà</h3>
                <button onclick="exportLogs()">„É≠„Ç∞„ÇíJSONÂΩ¢Âºè„Åß„Ç®„ÇØ„Çπ„Éù„Éº„Éà</button>
                <button onclick="clearLogs()">„É≠„Ç∞„Çí„ÇØ„É™„Ç¢</button>
            </div>
            
            <div class="metric-box">
                <h3>„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂ±•Ê≠¥</h3>
                <div id="uploadHistory"></div>
            </div>
            
            <div class="metric-box">
                <h3>„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÉÜ„Çπ„Éà</h3>
                <p style="font-size: 14px; color: #999; margin-bottom: 10px;">
                    ‰∏¶Âàó„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„ÅÆÊúÄÈÅ©„Å™ÂêåÊôÇÊé•Á∂öÊï∞„Çí„ÉÜ„Çπ„Éà„Åó„Åæ„ÅôÔºàÁõÆÊ®ô: 100„Éñ„É≠„ÉÉ„ÇØ/ÁßíÔºâ
                </p>
                <button onclick="testParallelPerformance()">üöÄ ‰∏¶Âàó„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„ÉÜ„Çπ„ÉàÂÆüË°å</button>
                <div id="performanceResults" style="margin-top: 15px; display: none;">
                    <h4>„ÉÜ„Çπ„ÉàÁµêÊûú:</h4>
                    <div id="performanceChart" style="background: #0a0a0a; padding: 15px; border-radius: 5px; font-family: monospace; font-size: 12px;"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- System Log -->
    <div class="container">
        <h3>üìù „Ç∑„Çπ„ÉÜ„É†„É≠„Ç∞</h3>
        <div class="log-container" id="systemLog"></div>
        <button class="copy-btn" onclick="copyLog()">„É≠„Ç∞„Çí„Ç≥„Éî„Éº</button>
    </div>

    <script type="module">
        // Global state
        let kaspa = null;
        let rpcClient = null;
        let currentFile = null;
        let currentPassword = null;
        let processedChunks = [];
        let kaspaMetadata = null;
        let wsMonitorActive = false;
        let monitoredTransactions = new Map();
        let uploadHistory = [];
        let systemLogs = [];
        let privateKey = null;
        let address = null;
        let progressManager = null;
        let wsConnection = null;
        let wsConnected = false;
        let wsReconnectInterval = null;
        let workspaceHandle = null; // File System Access API directory handle
        let progressFileMap = new Map(); // Map of filename -> {cid, fileHandle}
        let historyManager = null; // Upload history manager
        let wsMonitorTimeout = null; // WebSocket monitoring timeout
        let uploadingChunksCount = 0; // Number of chunks being uploaded
        let uploadingMetaTx = false; // Whether meta-tx is being uploaded
        
        // Settings state
        let settings = {
            parallelDownloadEnabled: false, // Default OFF for v3.5.0 compatibility
            parallelConcurrency: 8,
            parallelThreshold: 10
        };
        
        // Load settings from localStorage
        function loadSettings() {
            const saved = localStorage.getItem('kaspaFileStorageSettings');
            if (saved) {
                try {
                    Object.assign(settings, JSON.parse(saved));
                    // Update UI
                    document.getElementById('parallelDownloadToggle').checked = settings.parallelDownloadEnabled;
                    document.getElementById('parallelConcurrency').value = settings.parallelConcurrency;
                    document.getElementById('parallelThreshold').value = settings.parallelThreshold;
                } catch (e) {
                    log('Ë®≠ÂÆö„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
                }
            }
        }
        
        // Save settings to localStorage
        function saveSettings() {
            localStorage.setItem('kaspaFileStorageSettings', JSON.stringify(settings));
            log('Ë®≠ÂÆö„Çí‰øùÂ≠ò„Åó„Åæ„Åó„Åü', 'success');
        }
        
        // Settings event listeners
        document.getElementById('parallelDownloadToggle').addEventListener('change', (e) => {
            settings.parallelDownloadEnabled = e.target.checked;
            saveSettings();
            if (e.target.checked) {
                log('‰∏¶Âàó„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„ÇíÊúâÂäπ„Å´„Åó„Åæ„Åó„ÅüÔºàÂÆüÈ®ìÁöÑÊ©üËÉΩÔºâ', 'warning');
            } else {
                log('‰∏¶Âàó„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„ÇíÁÑ°Âäπ„Å´„Åó„Åæ„Åó„ÅüÔºàÂÆâÂÆö„É¢„Éº„ÉâÔºâ', 'success');
            }
        });
        
        document.getElementById('parallelConcurrency').addEventListener('change', (e) => {
            settings.parallelConcurrency = parseInt(e.target.value);
            saveSettings();
        });
        
        document.getElementById('parallelThreshold').addEventListener('change', (e) => {
            settings.parallelThreshold = parseInt(e.target.value);
            saveSettings();
        });
        
        // Upload History Manager Class
        class UploadHistoryManager {
            constructor() {
                this.dbName = 'kaspa-upload-history';
                this.fileName = 'kaspa-uploads.kenv';
                this.maxSize = 100 * 1024 * 1024; // 100MB
                this.archiveSize = 10 * 1024 * 1024; // 10MB chunks
                this.encryptionKey = null;
                log('[UploadHistoryManager] „Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂàùÊúüÂåñ„Åó„Åæ„Åó„Åü', 'debug');
            }
            
            async initialize(privateKey) {
                log('[UploadHistoryManager] ÂàùÊúüÂåñ„ÇíÈñãÂßã„Åó„Åæ„Åô', 'debug');
                try {
                    // Derive encryption key from private key
                    const keyData = new TextEncoder().encode(privateKey);
                    const hashBuffer = await crypto.subtle.digest('SHA-256', keyData);
                    this.encryptionKey = await crypto.subtle.importKey(
                        'raw',
                        hashBuffer,
                        { name: 'AES-GCM' },
                        false,
                        ['encrypt', 'decrypt']
                    );
                    log('[UploadHistoryManager] ÊöóÂè∑Âåñ„Ç≠„Éº„ÇíÁîüÊàê„Åó„Åæ„Åó„Åü', 'debug');
                    
                    // Try to load existing history
                    await this.loadFromFile();
                    log('[UploadHistoryManager] ÂàùÊúüÂåñ„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü', 'success');
                } catch (error) {
                    log(`[UploadHistoryManager] ÂàùÊúüÂåñ„Ç®„É©„Éº: ${error.message}`, 'error');
                    uploadHistory = [];
                }
            }
            
            async loadFromFile() {
                if (!workspaceHandle) {
                    log('[UploadHistoryManager] „ÉØ„Éº„ÇØ„Çπ„Éö„Éº„Çπ„Éè„É≥„Éâ„É´„Åå„ÅÇ„Çä„Åæ„Åõ„Çì', 'debug');
                    return;
                }
                
                try {
                    const fileHandle = await workspaceHandle.getFileHandle(this.fileName);
                    const file = await fileHandle.getFile();
                    const encryptedData = await file.text();
                    
                    if (!encryptedData || encryptedData.trim() === '') {
                        log('[UploadHistoryManager] Â±•Ê≠¥„Éï„Ç°„Ç§„É´„ÅåÁ©∫„Åß„Åô', 'debug');
                        uploadHistory = [];
                        return;
                    }
                    
                    // Decrypt data
                    const decrypted = await this.decrypt(encryptedData);
                    const data = JSON.parse(decrypted);
                    
                    if (data.version === '1.0' && Array.isArray(data.history)) {
                        uploadHistory = data.history;
                        log(`[UploadHistoryManager] ${uploadHistory.length}‰ª∂„ÅÆÂ±•Ê≠¥„ÇíË™≠„ÅøËæº„Åø„Åæ„Åó„Åü`, 'success');
                    } else {
                        log('[UploadHistoryManager] ÁÑ°Âäπ„Å™Â±•Ê≠¥„Éï„Ç©„Éº„Éû„ÉÉ„Éà', 'error');
                        uploadHistory = [];
                    }
                } catch (error) {
                    if (error.name === 'NotFoundError') {
                        log('[UploadHistoryManager] Â±•Ê≠¥„Éï„Ç°„Ç§„É´„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„ÇìÔºàÊñ∞Ë¶è‰ΩúÊàê„Åó„Åæ„ÅôÔºâ', 'debug');
                        uploadHistory = [];
                    } else {
                        log(`[UploadHistoryManager] Â±•Ê≠¥Ë™≠„ÅøËæº„Åø„Ç®„É©„Éº: ${error.message}`, 'error');
                        uploadHistory = [];
                    }
                }
            }
            
            async saveToFile() {
                if (!workspaceHandle) {
                    log('[UploadHistoryManager] „ÉØ„Éº„ÇØ„Çπ„Éö„Éº„Çπ„Éè„É≥„Éâ„É´„Åå„ÅÇ„Çä„Åæ„Åõ„Çì', 'warning');
                    return;
                }
                
                try {
                    const data = {
                        version: '1.0',
                        updated: new Date().toISOString(),
                        history: uploadHistory
                    };
                    
                    // Encrypt data
                    const encrypted = await this.encrypt(JSON.stringify(data, null, 2));
                    
                    // Write to file
                    const fileHandle = await workspaceHandle.getFileHandle(this.fileName, { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write(encrypted);
                    await writable.close();
                    
                    log(`[UploadHistoryManager] ${uploadHistory.length}‰ª∂„ÅÆÂ±•Ê≠¥„Çí‰øùÂ≠ò„Åó„Åæ„Åó„Åü`, 'success');
                } catch (error) {
                    log(`[UploadHistoryManager] Â±•Ê≠¥‰øùÂ≠ò„Ç®„É©„Éº: ${error.message}`, 'error');
                }
            }
            
            async encrypt(text) {
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const data = new TextEncoder().encode(text);
                
                const encrypted = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv: iv },
                    this.encryptionKey,
                    data
                );
                
                // Combine IV and encrypted data
                const combined = new Uint8Array(iv.length + encrypted.byteLength);
                combined.set(iv);
                combined.set(new Uint8Array(encrypted), iv.length);
                
                return btoa(String.fromCharCode(...combined));
            }
            
            async decrypt(encryptedText) {
                const combined = Uint8Array.from(atob(encryptedText), c => c.charCodeAt(0));
                const iv = combined.slice(0, 12);
                const encrypted = combined.slice(12);
                
                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv },
                    this.encryptionKey,
                    encrypted
                );
                
                return new TextDecoder().decode(decrypted);
            }
            
            async addEntry(entry) {
                // Add timestamp if not present
                if (!entry.timestamp) {
                    entry.timestamp = new Date().toISOString();
                }
                
                // Add to beginning of array (newest first)
                uploadHistory.unshift(entry);
                
                // Limit history size
                if (uploadHistory.length > 1000) {
                    uploadHistory = uploadHistory.slice(0, 1000);
                }
                
                // Save to file
                await this.saveToFile();
                
                // Update UI
                updateHistoryDisplay();
            }
            
            async exportHistory() {
                const data = {
                    version: '1.0',
                    exported: new Date().toISOString(),
                    history: uploadHistory
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `kaspa-upload-history-${new Date().toISOString().slice(0, 10)}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                log('Â±•Ê≠¥„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åó„Åæ„Åó„Åü', 'success');
            }
        }
        
        // Progress Manager Class
        class ProgressManager {
            constructor() {
                this.uploads = new Map();
                this.downloads = new Map();
                this.activeDownload = null;
                this.downloads = new Map();
            }
            
            // Upload progress methods
            createUpload(txid, metadata) {
                const progress = {
                    txid: txid,
                    metadata: metadata,
                    chunks: new Map(),
                    startTime: Date.now(),
                    status: 'uploading'
                };
                this.uploads.set(txid, progress);
                return progress;
            }
            
            updateChunkStatus(txid, chunkIndex, status) {
                const upload = this.uploads.get(txid);
                if (!upload) return;
                
                upload.chunks.set(chunkIndex, {
                    status: status,
                    timestamp: Date.now()
                });
            }
            
            getUploadProgress(txid) {
                const upload = this.uploads.get(txid);
                if (!upload) return null;
                
                const total = upload.metadata.totalChunks;
                const completed = Array.from(upload.chunks.values())
                    .filter(chunk => chunk.status === 'completed').length;
                
                return {
                    txid: txid,
                    fileName: upload.metadata.fileName,
                    progress: (completed / total) * 100,
                    completed: completed,
                    total: total,
                    status: upload.status,
                    elapsedTime: Date.now() - upload.startTime
                };
            }
            
            // Download progress methods
            createDownload(txid, totalChunks) {
                const id = `${txid}_${Date.now()}`;
                const progress = {
                    id: id,
                    txid: txid,
                    totalChunks: totalChunks,
                    completedChunks: 0,
                    startTime: Date.now(),
                    lastUpdate: Date.now(),
                    status: 'downloading',
                    speed: 0,
                    throughput: 0,
                    errors: []
                };
                this.downloads.set(id, progress);
                this.activeDownload = id;
                return progress;
            }
            
            updateDownloadProgress(downloadId, completed, speed = 0, throughput = 0) {
                const download = this.downloads.get(downloadId || this.activeDownload);
                if (!download) return;
                
                download.completedChunks = completed;
                download.lastUpdate = Date.now();
                download.speed = speed;
                download.throughput = throughput;
                
                if (completed >= download.totalChunks) {
                    download.status = 'completed';
                }
            }
            
            getDownloadProgress(downloadId) {
                const download = this.downloads.get(downloadId || this.activeDownload);
                if (!download) return null;
                
                const elapsed = (Date.now() - download.startTime) / 1000;
                const progress = (download.completedChunks / download.totalChunks) * 100;
                const eta = download.speed > 0 ? 
                    (download.totalChunks - download.completedChunks) / download.speed : 0;
                
                return {
                    id: download.id,
                    txid: download.txid,
                    progress: progress,
                    completed: download.completedChunks,
                    total: download.totalChunks,
                    speed: download.speed,
                    throughput: download.throughput,
                    elapsed: elapsed,
                    eta: eta,
                    status: download.status
                };
            }
        }
        
        // Fixed Parallel Downloader Class with proper synchronization
        class ParallelDownloader {
            constructor(rpcClient, concurrency = 8) {
                this.rpcClient = rpcClient;
                this.concurrency = concurrency;
                this.queue = [];
                this.active = 0;
                this.results = new Map();
                this.errors = new Map();
                this.startTime = null;
                this.completedCount = 0;
                this.totalBytes = 0;
                this.queueLock = false; // Simple mutex for queue access
                this.maxRetries = 3; // Add retry capability
            }
            
            async downloadChunks(chunksMetadata, key, kaspaMetadata, progressCallback) {
                this.startTime = Date.now();
                this.queue = chunksMetadata.map((chunk, index) => ({ 
                    chunk, 
                    index, 
                    retries: 0 
                }));
                this.results = new Map();
                this.errors = new Map();
                this.completedCount = 0;
                this.totalBytes = 0;
                this.totalChunks = chunksMetadata.length;
                
                log(`‰∏¶Âàó„ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÈñãÂßã: ${chunksMetadata.length}„ÉÅ„É£„É≥„ÇØ, ${this.concurrency}‰∏¶Âàó`, 'info');
                
                try {
                    // Start workers
                    const workers = [];
                    for (let i = 0; i < this.concurrency; i++) {
                        workers.push(this.worker(key, kaspaMetadata, progressCallback));
                    }
                    
                    // Wait for all workers
                    await Promise.all(workers);
                    
                    // Check for errors
                    if (this.errors.size > 0) {
                        const errorRate = (this.errors.size / chunksMetadata.length) * 100;
                        if (errorRate > 10) { // Allow up to 10% failure rate
                            const errorMsg = Array.from(this.errors.entries())
                                .map(([idx, err]) => `„ÉÅ„É£„É≥„ÇØ${idx}: ${err}`)
                                .join(', ');
                            throw new Error(`„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Ç®„É©„ÉºÁéá„ÅåÈ´ò„Åô„Åé„Åæ„Åô (${errorRate.toFixed(1)}%): ${errorMsg}`);
                        }
                    }
                    
                    // Sort results by index
                    const sortedChunks = [];
                    for (let i = 0; i < chunksMetadata.length; i++) {
                        if (!this.results.has(i)) {
                            if (this.errors.has(i)) {
                                throw new Error(`„ÉÅ„É£„É≥„ÇØ${i}„ÅÆ„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Å´Â§±Êïó: ${this.errors.get(i)}`);
                            } else {
                                throw new Error(`„ÉÅ„É£„É≥„ÇØ${i}„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì`);
                            }
                        }
                        sortedChunks.push(this.results.get(i));
                    }
                    
                    const elapsed = (Date.now() - this.startTime) / 1000;
                    const throughput = (this.totalBytes / 1024 / 1024) / elapsed;
                    log(`‰∏¶Âàó„ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÂÆå‰∫Ü: ${elapsed.toFixed(1)}Áßí, ${throughput.toFixed(1)} MB/Áßí`, 'success');
                    
                    return sortedChunks;
                } catch (error) {
                    log(`‰∏¶Âàó„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Ç®„É©„Éº: ${error.message}`, 'error');
                    throw error;
                }
            }
            
            async worker(key, kaspaMetadata, progressCallback) {
                while (true) {
                    // Thread-safe queue access
                    let work = null;
                    
                    // Simple mutex implementation
                    while (this.queueLock) {
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                    
                    this.queueLock = true;
                    try {
                        if (this.queue.length > 0) {
                            work = this.queue.shift();
                            this.active++;
                        }
                    } finally {
                        this.queueLock = false;
                    }
                    
                    if (!work && this.active === 0) {
                        break; // All work done
                    }
                    
                    if (!work) {
                        await new Promise(resolve => setTimeout(resolve, 50));
                        continue;
                    }
                    
                    try {
                        const { chunk: chunkMeta, index } = work;
                        
                        // Get block data with retry
                        let response = null;
                        let lastError = null;
                        
                        for (let retry = 0; retry <= this.maxRetries; retry++) {
                            try {
                                response = await this.rpcClient.getBlock({
                                    hash: chunkMeta.blockId,
                                    includeTransactions: true
                                });
                                break; // Success
                            } catch (error) {
                                lastError = error;
                                if (retry < this.maxRetries) {
                                    log(`„ÉÅ„É£„É≥„ÇØ${index}„ÅÆÂèñÂæó„Å´Â§±Êïó („É™„Éà„É©„Ç§ ${retry + 1}/${this.maxRetries})`, 'warning');
                                    await new Promise(resolve => setTimeout(resolve, 1000 * (retry + 1)));
                                }
                            }
                        }
                        
                        if (!response) {
                            throw lastError || new Error('„Éñ„É≠„ÉÉ„ÇØÂèñÂæó„Å´Â§±Êïó');
                        }
                        
                        const block = response?.block?.block || response?.block;
                        if (!block) {
                            throw new Error(`„Éñ„É≠„ÉÉ„ÇØ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì: ${chunkMeta.blockId}`);
                        }
                        
                        // Find transaction
                        let payload = null;
                        for (const tx of block.transactions || []) {
                            const txId = tx.verboseData?.transactionId || tx.id || tx.transactionId;
                            if (txId === chunkMeta.txid) {
                                if (tx.payload && tx.payload !== '') {
                                    payload = safeHexDecode(tx.payload, 'chunk payload');
                                    break;
                                }
                            }
                        }
                        
                        if (!payload) {
                            throw new Error(`„Éö„Ç§„É≠„Éº„Éâ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì`);
                        }
                        
                        // Decrypt and decompress
                        const compressed = await decryptChunk(payload, key, index);
                        const original = kaspaMetadata.compression.enabled ? 
                            lzDecompress(compressed) : compressed;
                        
                        this.results.set(index, original);
                        this.completedCount++;
                        this.totalBytes += original.length;
                        
                        // Update progress
                        const elapsed = (Date.now() - this.startTime) / 1000;
                        const speed = this.completedCount / elapsed;
                        const throughput = (this.totalBytes / 1024 / 1024) / elapsed;
                        
                        if (progressCallback) {
                            progressCallback({
                                completed: this.completedCount,
                                total: this.totalChunks,
                                speed: speed,
                                throughput: throughput
                            });
                        }
                        
                    } catch (error) {
                        work.retries++;
                        if (work.retries <= this.maxRetries) {
                            // Re-queue for retry
                            while (this.queueLock) {
                                await new Promise(resolve => setTimeout(resolve, 10));
                            }
                            this.queueLock = true;
                            try {
                                this.queue.push(work);
                            } finally {
                                this.queueLock = false;
                            }
                            log(`„ÉÅ„É£„É≥„ÇØ${work.index}„ÇíÂÜçË©¶Ë°å„Ç≠„É•„Éº„Å´ËøΩÂä† (${work.retries}/${this.maxRetries})`, 'warning');
                        } else {
                            log(`„ÉØ„Éº„Ç´„Éº„Ç®„É©„Éº („ÉÅ„É£„É≥„ÇØ${work.index}): ${error.message}`, 'error');
                            this.errors.set(work.index, error.message);
                        }
                    } finally {
                        this.active--;
                    }
                }
            }
        }
        
        // Configuration
        const config = {
            network: 'testnet-10',
            retryCount: 3,
            timeout: 30000,
            testPrivateKey: 'b7e151628aed2a6abf7158809cf4f3c762e7160f38b4da56a784d9045190cfef'
        };

        // Safe hex decode function
        function safeHexDecode(hexString, context = '') {
            try {
                if (!hexString || typeof hexString !== 'string') {
                    throw new Error('Invalid hex string: null or not a string');
                }
                
                // Remove any whitespace
                hexString = hexString.trim();
                
                if (hexString.length === 0) {
                    throw new Error('Invalid hex string: empty');
                }
                
                if (hexString.length % 2 !== 0) {
                    throw new Error(`Invalid hex string: odd length (${hexString.length})`);
                }
                
                if (!/^[0-9a-fA-F]+$/.test(hexString)) {
                    throw new Error('Invalid hex string: contains non-hex characters');
                }
                
                const matches = hexString.match(/.{1,2}/g);
                if (!matches) {
                    throw new Error('Failed to parse hex string');
                }
                
                return new Uint8Array(matches.map(byte => parseInt(byte, 16)));
            } catch (e) {
                const errorMsg = context ? `Hex decode error in ${context}: ${e.message}` : `Hex decode error: ${e.message}`;
                log(errorMsg, 'error');
                throw new Error(errorMsg);
            }
        }
        
        // Logging system
        function log(message, type = 'info') {
            const timestamp = new Date();
            const logEntry = {
                timestamp: timestamp.toISOString(),
                time: timestamp.toLocaleTimeString(),
                type: type,
                message: message
            };
            
            systemLogs.push(logEntry);
            
            const logContainer = document.getElementById('systemLog');
            if (logContainer) {
                const logElement = document.createElement('div');
                logElement.className = `log-entry log-${type}`;
                logElement.textContent = `[${logEntry.time}] ${message}`;
                logContainer.appendChild(logElement);
                logContainer.scrollTop = logContainer.scrollHeight;
            }
            
            // Keep only last 1000 logs
            if (systemLogs.length > 1000) {
                systemLogs = systemLogs.slice(-1000);
            }
        }
        
        // Tab switching
        window.switchTab = function(tabName) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(`${tabName}-tab`).classList.add('active');
            
            if (tabName === 'history') {
                updateHistoryDisplay();
            }
        };
        
        // File handling
        const dropArea = document.getElementById('dropArea');
        const fileInput = document.getElementById('fileInput');
        
        dropArea.addEventListener('click', () => fileInput.click());
        dropArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropArea.classList.add('dragover');
        });
        dropArea.addEventListener('dragleave', () => {
            dropArea.classList.remove('dragover');
        });
        dropArea.addEventListener('drop', (e) => {
            e.preventDefault();
            dropArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) handleFileSelect(file);
        });
        
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) handleFileSelect(file);
        });
        
        function handleFileSelect(file) {
            currentFile = file;
            document.getElementById('fileName').textContent = file.name;
            document.getElementById('fileSize').textContent = formatFileSize(file.size);
            
            const chunkSize = 12 * 1024; // 12KB chunks
            const estimatedChunks = Math.ceil(file.size / chunkSize);
            document.getElementById('estimatedChunks').textContent = estimatedChunks;
            
            // Estimate cost (rough estimate)
            const estimatedCost = estimatedChunks * 0.00001;
            document.getElementById('estimatedCost').textContent = estimatedCost.toFixed(6);
            
            document.getElementById('fileInfo').style.display = 'block';
            checkUploadReady();
        }
        
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
            if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
            return (bytes / (1024 * 1024 * 1024)).toFixed(2) + ' GB';
        }
        
        // Wallet management
        window.importWallet = async function() {
            const keyInput = document.getElementById('privateKeyInput').value.trim();
            if (!keyInput || keyInput.length !== 64) {
                showToast('ÁßòÂØÜÈçµ„ÅØ64ÊñáÂ≠ó„ÅÆ16ÈÄ≤Êï∞„Åß„ÅÇ„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô', 'error');
                return;
            }
            
            try {
                await initializeKaspa();
                
                privateKey = keyInput;
                const privKey = new kaspa.PrivateKey(privateKey);
                const pubKey = privKey.toPublicKey();
                address = pubKey.toAddress(kaspa.NetworkType.Testnet).toString();
                
                document.getElementById('walletAddress').textContent = address;
                document.getElementById('walletInfo').style.display = 'block';
                
                // Initialize history manager
                if (!historyManager) {
                    historyManager = new UploadHistoryManager();
                    await historyManager.initialize(privateKey);
                }
                
                // Update balance
                await updateBalance();
                
                // Save to localStorage
                localStorage.setItem('kaspaPrivateKey', privateKey);
                
                log('„Ç¶„Ç©„É¨„ÉÉ„Éà„Çí„Ç§„É≥„Éù„Éº„Éà„Åó„Åæ„Åó„Åü', 'success');
                showToast('„Ç¶„Ç©„É¨„ÉÉ„Éà„ÅÆ„Ç§„É≥„Éù„Éº„Éà„Å´ÊàêÂäü„Åó„Åæ„Åó„Åü', 'success');
                checkUploadReady();
            } catch (error) {
                log(`„Ç¶„Ç©„É¨„ÉÉ„Éà„Ç§„É≥„Éù„Éº„Éà„Ç®„É©„Éº: ${error.message}`, 'error');
                showToast('„Ç¶„Ç©„É¨„ÉÉ„Éà„ÅÆ„Ç§„É≥„Éù„Éº„Éà„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
            }
        };
        
        window.generateNewWallet = async function() {
            try {
                await initializeKaspa();
                
                // Generate mnemonic
                const mnemonic = kaspa.Mnemonic.random();
                const seed = mnemonic.toSeed();
                
                // Derive key
                const xprv = new kaspa.XPrv(seed);
                const account = await xprv.deriveAccount(0);
                const prvKey = await account.deriveKey(0, 0);
                
                privateKey = prvKey.toString();
                const pubKey = prvKey.toPublicKey();
                address = pubKey.toAddress(kaspa.NetworkType.Testnet).toString();
                
                // Show mnemonic
                alert(`Êñ∞„Åó„ÅÑ„Ç¶„Ç©„É¨„ÉÉ„Éà„ÇíÁîüÊàê„Åó„Åæ„Åó„Åü„ÄÇ\n\nÈáçË¶Å: ‰ª•‰∏ã„ÅÆ„É™„Ç´„Éê„É™„Éº„Éï„É¨„Éº„Ç∫„ÇíÂÆâÂÖ®„Å´‰øùÁÆ°„Åó„Å¶„Åè„Å†„Åï„ÅÑ:\n${mnemonic.phrase}\n\nÁßòÂØÜÈçµ: ${privateKey}`);
                
                document.getElementById('privateKeyInput').value = privateKey;
                document.getElementById('walletAddress').textContent = address;
                document.getElementById('walletInfo').style.display = 'block';
                
                // Initialize history manager
                if (!historyManager) {
                    historyManager = new UploadHistoryManager();
                    await historyManager.initialize(privateKey);
                }
                
                await updateBalance();
                
                // Save to localStorage
                localStorage.setItem('kaspaPrivateKey', privateKey);
                
                log('Êñ∞„Åó„ÅÑ„Ç¶„Ç©„É¨„ÉÉ„Éà„ÇíÁîüÊàê„Åó„Åæ„Åó„Åü', 'success');
                showToast('Êñ∞„Åó„ÅÑ„Ç¶„Ç©„É¨„ÉÉ„Éà„ÇíÁîüÊàê„Åó„Åæ„Åó„Åü', 'success');
                checkUploadReady();
            } catch (error) {
                log(`„Ç¶„Ç©„É¨„ÉÉ„ÉàÁîüÊàê„Ç®„É©„Éº: ${error.message}`, 'error');
                showToast('„Ç¶„Ç©„É¨„ÉÉ„ÉàÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
            }
        };
        
        async function updateBalance() {
            if (!address || !rpcClient) return;
            
            try {
                const response = await rpcClient.getBalanceByAddress({ address });
                const balance = Number(response.balance) / 100000000;
                document.getElementById('walletBalance').textContent = balance.toFixed(8);
            } catch (error) {
                log(`ÊÆãÈ´òÂèñÂæó„Ç®„É©„Éº: ${error.message}`, 'error');
                document.getElementById('walletBalance').textContent = '„Ç®„É©„Éº';
            }
        }
        
        function checkUploadReady() {
            const hasFile = currentFile !== null;
            const hasWallet = privateKey !== null;
            const hasPassword = document.getElementById('passwordInput').value.length >= 8;
            const passwordMatch = document.getElementById('passwordInput').value === 
                                 document.getElementById('passwordConfirm').value;
            
            document.getElementById('uploadButton').disabled = 
                !(hasFile && hasWallet && hasPassword && passwordMatch);
        }
        
        // Password validation
        document.getElementById('passwordInput').addEventListener('input', checkUploadReady);
        document.getElementById('passwordConfirm').addEventListener('input', checkUploadReady);
        
        // Kaspa initialization
        async function initializeKaspa() {
            if (kaspa) return;
            
            try {
                const kaspaModule = await import('./kaspa-core.js');
                kaspa = kaspaModule.default || kaspaModule;
                
                if (kaspa.initWASM32Bindings) {
                    await kaspa.initWASM32Bindings();
                }
                
                log('Kaspa WASM initialized', 'success');
            } catch (error) {
                log(`KaspaÂàùÊúüÂåñ„Ç®„É©„Éº: ${error.message}`, 'error');
                throw error;
            }
        }
        
        // RPC Client initialization
        async function initializeRPC() {
            if (rpcClient && rpcClient.isConnected) return;
            
            try {
                const network = document.getElementById('networkSelect').value;
                
                rpcClient = new kaspa.RpcClient({
                    resolver: new kaspa.Resolver(),
                    networkId: network
                });
                
                await rpcClient.connect();
                log(`RPC„ÇØ„É©„Ç§„Ç¢„É≥„ÉàÊé•Á∂öÂÆå‰∫Ü (${network})`, 'success');
                
                // Update config
                config.network = network;
            } catch (error) {
                log(`RPCÊé•Á∂ö„Ç®„É©„Éº: ${error.message}`, 'error');
                throw error;
            }
        }
        
        // Encryption functions
        async function deriveKey(password, salt) {
            const encoder = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                'raw',
                encoder.encode(password),
                'PBKDF2',
                false,
                ['deriveBits', 'deriveKey']
            );
            
            return crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: 100000,
                    hash: 'SHA-256'
                },
                keyMaterial,
                { name: 'AES-GCM', length: 256 },
                false,
                ['encrypt', 'decrypt']
            );
        }
        
        async function encryptChunk(data, key, chunkIndex) {
            const iv = crypto.getRandomValues(new Uint8Array(12));
            
            // Add chunk index to additional data for authentication
            const additionalData = new Uint8Array(4);
            new DataView(additionalData.buffer).setUint32(0, chunkIndex, true);
            
            const encrypted = await crypto.subtle.encrypt(
                {
                    name: 'AES-GCM',
                    iv: iv,
                    additionalData: additionalData
                },
                key,
                data
            );
            
            // Combine IV and ciphertext
            const result = new Uint8Array(iv.length + encrypted.byteLength);
            result.set(iv);
            result.set(new Uint8Array(encrypted), iv.length);
            
            return result;
        }
        
        async function decryptChunk(data, key, chunkIndex) {
            const iv = data.slice(0, 12);
            const ciphertext = data.slice(12);
            
            // Add chunk index to additional data for authentication
            const additionalData = new Uint8Array(4);
            new DataView(additionalData.buffer).setUint32(0, chunkIndex, true);
            
            const decrypted = await crypto.subtle.decrypt(
                {
                    name: 'AES-GCM',
                    iv: iv,
                    additionalData: additionalData
                },
                key,
                ciphertext
            );
            
            return new Uint8Array(decrypted);
        }
        
        // Compression functions
        function lzCompress(data) {
            // Simple LZ77-style compression
            const result = [];
            const windowSize = 4096;
            const lookaheadSize = 15;
            
            let pos = 0;
            while (pos < data.length) {
                let bestMatch = { distance: 0, length: 0 };
                
                // Search for matches in the sliding window
                const searchStart = Math.max(0, pos - windowSize);
                for (let i = searchStart; i < pos; i++) {
                    let matchLength = 0;
                    while (matchLength < lookaheadSize && 
                           pos + matchLength < data.length &&
                           data[i + matchLength] === data[pos + matchLength]) {
                        matchLength++;
                    }
                    
                    if (matchLength > bestMatch.length) {
                        bestMatch = { distance: pos - i, length: matchLength };
                    }
                }
                
                if (bestMatch.length >= 3) {
                    // Output distance/length pair
                    result.push(0); // Marker for compressed data
                    result.push((bestMatch.distance >> 8) & 0xFF);
                    result.push(bestMatch.distance & 0xFF);
                    result.push(bestMatch.length);
                    pos += bestMatch.length;
                } else {
                    // Output literal
                    result.push(1); // Marker for literal
                    result.push(data[pos]);
                    pos++;
                }
            }
            
            return new Uint8Array(result);
        }
        
        function lzDecompress(compressed) {
            const result = [];
            let pos = 0;
            
            while (pos < compressed.length) {
                const marker = compressed[pos++];
                
                if (marker === 0) {
                    // Compressed data
                    const distance = (compressed[pos++] << 8) | compressed[pos++];
                    const length = compressed[pos++];
                    
                    for (let i = 0; i < length; i++) {
                        result.push(result[result.length - distance]);
                    }
                } else {
                    // Literal
                    result.push(compressed[pos++]);
                }
            }
            
            return new Uint8Array(result);
        }
        
        // Base64 encoding/decoding
        function toBase64(uint8Array) {
            return btoa(String.fromCharCode.apply(null, uint8Array));
        }
        
        function fromBase64(base64) {
            const binaryString = atob(base64);
            const uint8Array = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                uint8Array[i] = binaryString.charCodeAt(i);
            }
            return uint8Array;
        }
        
        // Upload functionality
        window.startUpload = async function() {
            if (!currentFile || !privateKey) return;
            
            const password = document.getElementById('passwordInput').value;
            if (password.length < 8) {
                showToast('„Éë„Çπ„ÉØ„Éº„Éâ„ÅØ8ÊñáÂ≠ó‰ª•‰∏ä„Åß„ÅÇ„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô', 'error');
                return;
            }
            
            if (password !== document.getElementById('passwordConfirm').value) {
                showToast('„Éë„Çπ„ÉØ„Éº„Éâ„Åå‰∏ÄËá¥„Åó„Åæ„Åõ„Çì', 'error');
                return;
            }
            
            currentPassword = password;
            
            try {
                await initializeRPC();
                
                document.getElementById('uploadProgress').style.display = 'block';
                document.getElementById('uploadButton').disabled = true;
                
                // Start workspace selection if not already selected
                if (!workspaceHandle) {
                    try {
                        workspaceHandle = await window.showDirectoryPicker({
                            mode: 'readwrite'
                        });
                        log('‰ΩúÊ•≠„Éá„Ç£„É¨„ÇØ„Éà„É™„ÇíÈÅ∏Êäû„Åó„Åæ„Åó„Åü', 'success');
                    } catch (error) {
                        if (error.name === 'AbortError') {
                            log('„Éá„Ç£„É¨„ÇØ„Éà„É™ÈÅ∏Êäû„Åå„Ç≠„É£„É≥„Çª„É´„Åï„Çå„Åæ„Åó„Åü', 'warning');
                        }
                    }
                }
                
                // Create metadata
                const salt = crypto.getRandomValues(new Uint8Array(16));
                const key = await deriveKey(password, salt);
                
                const fileData = await currentFile.arrayBuffer();
                const fileBytes = new Uint8Array(fileData);
                
                // Compress file
                const compressed = lzCompress(fileBytes);
                const compressionRatio = (compressed.length / fileBytes.length);
                const useCompression = compressionRatio < 0.9;
                
                const dataToChunk = useCompression ? compressed : fileBytes;
                
                // Create chunks
                const chunkSize = 12 * 1024; // 12KB
                const chunks = [];
                processedChunks = [];
                
                for (let i = 0; i < dataToChunk.length; i += chunkSize) {
                    const chunk = dataToChunk.slice(i, Math.min(i + chunkSize, dataToChunk.length));
                    chunks.push(chunk);
                }
                
                log(`„Éï„Ç°„Ç§„É´ÂàÜÂâ≤ÂÆå‰∫Ü: ${chunks.length}„ÉÅ„É£„É≥„ÇØ`, 'info');
                
                // Create metadata
                kaspaMetadata = {
                    version: '2.0',
                    file: {
                        name: currentFile.name,
                        size: currentFile.size,
                        type: currentFile.type,
                        lastModified: currentFile.lastModified
                    },
                    encryption: {
                        algorithm: 'AES-256-GCM',
                        pbkdf2: {
                            iterations: 100000,
                            salt: toBase64(salt)
                        }
                    },
                    compression: {
                        enabled: useCompression,
                        algorithm: useCompression ? 'LZ77' : 'none',
                        originalSize: fileBytes.length,
                        compressedSize: useCompression ? compressed.length : fileBytes.length
                    },
                    chunks: []
                };
                
                // Start WebSocket monitoring
                startWebSocketMonitoring();
                
                // Upload chunks
                for (let i = 0; i < chunks.length; i++) {
                    const encrypted = await encryptChunk(chunks[i], key, i);
                    
                    document.getElementById('uploadStatus').textContent = 
                        `„ÉÅ„É£„É≥„ÇØ ${i + 1}/${chunks.length} „Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ‰∏≠...`;
                    
                    const progress = ((i + 1) / chunks.length * 100).toFixed(0);
                    document.getElementById('uploadProgressBar').style.width = progress + '%';
                    document.getElementById('uploadProgressBar').textContent = progress + '%';
                    
                    const txid = await uploadChunk(encrypted, i);
                    
                    processedChunks.push({
                        index: i,
                        txid: txid,
                        size: encrypted.length
                    });
                    
                    const chunkInfo = document.createElement('div');
                    chunkInfo.className = 'chunk-info';
                    chunkInfo.innerHTML = `„ÉÅ„É£„É≥„ÇØ ${i + 1}: TxID: <code>${txid}</code> (${encrypted.length} bytes)`;
                    document.getElementById('chunkDetails').appendChild(chunkInfo);
                }
                
                // Wait for all transactions to be included in blocks
                document.getElementById('uploadStatus').textContent = 
                    '„Åô„Åπ„Å¶„ÅÆ„Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥„Åå„Éñ„É≠„ÉÉ„ÇØ„Å´Âê´„Åæ„Çå„Çã„ÅÆ„ÇíÂæÖ„Å£„Å¶„ÅÑ„Åæ„Åô...';
                
                await waitForAllTransactions();
                
                // Create final metadata with block IDs
                for (let i = 0; i < processedChunks.length; i++) {
                    const chunk = processedChunks[i];
                    const blockInfo = monitoredTransactions.get(chunk.txid);
                    
                    kaspaMetadata.chunks.push({
                        index: i,
                        txid: chunk.txid,
                        blockId: blockInfo?.blockHash || 'pending',
                        size: chunk.size
                    });
                }
                
                // Upload metadata
                document.getElementById('uploadStatus').textContent = '„É°„Çø„Éá„Éº„Çø„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ‰∏≠...';
                const metadataJson = JSON.stringify(kaspaMetadata);
                const metadataBytes = new TextEncoder().encode(metadataJson);
                const metaTxId = await uploadChunk(metadataBytes, -1);
                
                // Wait for metadata transaction
                uploadingMetaTx = true;
                await waitForTransaction(metaTxId);
                uploadingMetaTx = false;
                
                const metaBlockInfo = monitoredTransactions.get(metaTxId);
                
                // Save to history
                const historyEntry = {
                    txid: metaTxId,
                    blockId: metaBlockInfo?.blockHash || 'pending',
                    fileName: currentFile.name,
                    fileSize: currentFile.size,
                    chunks: chunks.length,
                    timestamp: new Date().toISOString(),
                    network: config.network,
                    metadata: kaspaMetadata
                };
                
                if (historyManager) {
                    await historyManager.addEntry(historyEntry);
                }
                
                // Show completion
                document.getElementById('uploadStatus').textContent = '„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂÆå‰∫ÜÔºÅ';
                document.getElementById('uploadProgressBar').style.width = '100%';
                document.getElementById('uploadProgressBar').textContent = '100%';
                
                // Create download info
                const downloadInfo = `${metaTxId}:${metaBlockInfo?.blockHash || 'pending'}:${password}`;
                
                showToast('„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂÆå‰∫ÜÔºÅ„ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÊÉÖÂ†±„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü', 'success');
                await navigator.clipboard.writeText(downloadInfo);
                
                alert(`„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂÆå‰∫ÜÔºÅ\n\n„ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÊÉÖÂ†±Ôºà„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´„Ç≥„Éî„ÉºÊ∏à„ÅøÔºâ:\n${downloadInfo}\n\n„É°„Çø„Éá„Éº„ÇøTxID: ${metaTxId}`);
                
                // Reset
                stopWebSocketMonitoring();
                currentFile = null;
                document.getElementById('fileInput').value = '';
                document.getElementById('fileInfo').style.display = 'none';
                document.getElementById('passwordInput').value = '';
                document.getElementById('passwordConfirm').value = '';
                document.getElementById('uploadButton').disabled = false;
                
            } catch (error) {
                log(`„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Ç®„É©„Éº: ${error.message}`, 'error');
                showToast('„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
                document.getElementById('uploadButton').disabled = false;
                stopWebSocketMonitoring();
            }
        };
        
        async function uploadChunk(data, chunkIndex) {
            try {
                // Create transaction
                const privKey = new kaspa.PrivateKey(privateKey);
                const pubKey = privKey.toPublicKey();
                const addr = pubKey.toAddress(kaspa.NetworkType.Testnet);
                
                // Get UTXOs
                const response = await rpcClient.getUtxosByAddresses({
                    addresses: [addr.toString()]
                });
                
                if (!response.entries || response.entries.length === 0) {
                    throw new Error('Âà©Áî®ÂèØËÉΩ„Å™UTXO„Åå„ÅÇ„Çä„Åæ„Åõ„Çì');
                }
                
                // Select UTXO
                const utxo = response.entries[0];
                const utxoAmount = Number(utxo.utxoEntry.amount);
                
                // Create transaction input
                const input = new kaspa.TransactionInput({
                    previousOutpoint: new kaspa.TransactionOutpoint({
                        transactionId: utxo.outpoint.transactionId,
                        index: utxo.outpoint.index
                    }),
                    signatureScript: new Uint8Array(0),
                    sequence: 0xffffffff,
                    sigOpCount: 1
                });
                
                // Create outputs (send back to self minus fee)
                const fee = 1000; // 0.00001 KAS
                const changeAmount = utxoAmount - fee;
                
                const output = new kaspa.TransactionOutput({
                    value: BigInt(changeAmount),
                    scriptPublicKey: new kaspa.ScriptPublicKey({
                        version: 0,
                        scriptPublicKey: addr.toScriptPublicKey().script
                    })
                });
                
                // Create transaction with payload
                const tx = new kaspa.Transaction({
                    version: 0,
                    inputs: [input],
                    outputs: [output],
                    lockTime: 0,
                    subnetworkId: new Uint8Array(20),
                    gas: 0,
                    payload: data
                });
                
                // Sign transaction
                const signature = await kaspa.signTransaction(tx, [privKey], kaspa.SighashType.All);
                tx.inputs[0].signatureScript = signature[0];
                
                // Submit transaction
                const submitResponse = await rpcClient.submitTransaction({
                    transaction: tx,
                    allowOrphan: false
                });
                
                const txid = submitResponse.transactionId;
                log(`„ÉÅ„É£„É≥„ÇØ ${chunkIndex + 1} ÈÄÅ‰ø°ÂÆå‰∫Ü: ${txid}`, 'success');
                
                return txid;
            } catch (error) {
                log(`„ÉÅ„É£„É≥„ÇØ„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Ç®„É©„Éº: ${error.message}`, 'error');
                throw error;
            }
        }
        
        // WebSocket monitoring
        function startWebSocketMonitoring() {
            if (wsMonitorActive) return;
            
            wsMonitorActive = true;
            monitoredTransactions.clear();
            uploadingChunksCount = 0;
            
            // Connect to WebSocket
            connectWebSocket();
            
            log('WebSocket„É¢„Éã„Çø„É™„É≥„Ç∞„ÇíÈñãÂßã„Åó„Åæ„Åó„Åü', 'info');
        }
        
        function stopWebSocketMonitoring() {
            wsMonitorActive = false;
            if (wsConnection) {
                wsConnection.close();
                wsConnection = null;
            }
            if (wsReconnectInterval) {
                clearInterval(wsReconnectInterval);
                wsReconnectInterval = null;
            }
            if (wsMonitorTimeout) {
                clearTimeout(wsMonitorTimeout);
                wsMonitorTimeout = null;
            }
            log('WebSocket„É¢„Éã„Çø„É™„É≥„Ç∞„ÇíÂÅúÊ≠¢„Åó„Åæ„Åó„Åü', 'info');
        }
        
        async function connectWebSocket() {
            if (!wsMonitorActive) return;
            
            try {
                const wsUrl = config.network === 'mainnet' ? 
                    'wss://kaspa-mainnet-public-ws.kaspa.stream' : 
                    'wss://kaspa-testnet-10-public-ws.kaspa.stream';
                
                wsConnection = new WebSocket(wsUrl);
                
                wsConnection.onopen = () => {
                    wsConnected = true;
                    log('WebSocketÊé•Á∂öÊàêÂäü', 'success');
                    
                    // Subscribe to blocks
                    wsConnection.send(JSON.stringify({
                        id: 1,
                        command: 'notifyBlockAdded'
                    }));
                };
                
                wsConnection.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        if (data.type === 'blockAdded' && data.blockAdded) {
                            handleNewBlock(data.blockAdded.block);
                        }
                    } catch (error) {
                        log(`WebSocket„É°„ÉÉ„Çª„Éº„Ç∏Âá¶ÁêÜ„Ç®„É©„Éº: ${error.message}`, 'error');
                    }
                };
                
                wsConnection.onerror = (error) => {
                    log('WebSocket„Ç®„É©„Éº', 'error');
                    wsConnected = false;
                };
                
                wsConnection.onclose = () => {
                    wsConnected = false;
                    log('WebSocketÊé•Á∂ö„ÅåÂàáÊñ≠„Åï„Çå„Åæ„Åó„Åü', 'warning');
                    
                    // Reconnect after 5 seconds
                    if (wsMonitorActive && !wsReconnectInterval) {
                        wsReconnectInterval = setTimeout(() => {
                            wsReconnectInterval = null;
                            connectWebSocket();
                        }, 5000);
                    }
                };
                
            } catch (error) {
                log(`WebSocketÊé•Á∂ö„Ç®„É©„Éº: ${error.message}`, 'error');
            }
        }
        
        async function handleNewBlock(block) {
            if (!block || !block.transactions) return;
            
            const blockHash = block.verboseData?.hash || block.header?.hash;
            if (!blockHash) return;
            
            for (const tx of block.transactions) {
                const txId = tx.verboseData?.transactionId || tx.id;
                if (!txId) continue;
                
                // Check if this is one of our transactions
                const isOurTx = processedChunks.some(chunk => chunk.txid === txId) || 
                               (uploadingMetaTx && monitoredTransactions.size === processedChunks.length);
                
                if (isOurTx && !monitoredTransactions.has(txId)) {
                    monitoredTransactions.set(txId, {
                        txid: txId,
                        blockHash: blockHash,
                        timestamp: Date.now()
                    });
                    
                    log(`„Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥ ${txId} „Åå„Éñ„É≠„ÉÉ„ÇØ ${blockHash} „Å´Âê´„Åæ„Çå„Åæ„Åó„Åü`, 'success');
                    
                    // Update progress if needed
                    if (progressManager) {
                        progressManager.updateChunkStatus(txId, processedChunks.findIndex(c => c.txid === txId), 'completed');
                    }
                }
            }
        }
        
        async function waitForTransaction(txid, timeout = 300000) {
            const startTime = Date.now();
            
            while (!monitoredTransactions.has(txid)) {
                if (Date.now() - startTime > timeout) {
                    throw new Error(`„Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥ ${txid} „ÅÆ„Çø„Ç§„É†„Ç¢„Ç¶„Éà`);
                }
                
                // Try to get transaction info via RPC as backup
                try {
                    const response = await rpcClient.getTransaction({
                        transactionId: txid,
                        includeBlockInfo: true
                    });
                    
                    if (response && response.block) {
                        monitoredTransactions.set(txid, {
                            txid: txid,
                            blockHash: response.block.hash,
                            timestamp: Date.now()
                        });
                        break;
                    }
                } catch (error) {
                    // Transaction not found yet
                }
                
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            return monitoredTransactions.get(txid);
        }
        
        async function waitForAllTransactions() {
            const total = processedChunks.length;
            let completed = 0;
            
            for (const chunk of processedChunks) {
                if (!monitoredTransactions.has(chunk.txid)) {
                    await waitForTransaction(chunk.txid);
                }
                completed++;
                
                const progress = (completed / total * 100).toFixed(0);
                document.getElementById('uploadProgressBar').style.width = progress + '%';
                document.getElementById('uploadProgressBar').textContent = progress + '%';
            }
        }
        
        // Download functionality
        window.startDownload = async function() {
            const inputValue = document.getElementById('downloadTxId').value.trim();
            const downloadPassword = document.getElementById('downloadPassword').value;
            
            if (!inputValue) {
                showToast('Transaction ID„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ', 'error');
                return;
            }
            
            let txid, blockId;
            
            // Parse input (supports multiple formats)
            const parts = inputValue.split(':');
            if (parts.length >= 3) {
                // Format: TxID:BlockID:Password
                txid = parts[0];
                blockId = parts[1];
                if (!downloadPassword) {
                    document.getElementById('downloadPassword').value = parts[2];
                }
            } else if (parts.length === 2) {
                // Format: TxID:BlockID
                txid = parts[0];
                blockId = parts[1];
            } else {
                // Format: TxID only
                txid = parts[0];
                blockId = document.getElementById('downloadBlockId').value.trim();
            }
            
            if (!downloadPassword && !document.getElementById('downloadPassword').value) {
                showToast('„Éë„Çπ„ÉØ„Éº„Éâ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ', 'error');
                return;
            }
            
            const password = downloadPassword || document.getElementById('downloadPassword').value;
            
            try {
                await initializeKaspa();
                await initializeRPC();
                
                document.getElementById('downloadProgress').style.display = 'block';
                
                // Get metadata
                document.getElementById('downloadStatus').textContent = '„É°„Çø„Éá„Éº„Çø„ÇíÂèñÂæó‰∏≠...';
                
                let metadataBlock;
                if (blockId) {
                    // Use provided block ID
                    metadataBlock = await getBlockData(blockId);
                } else {
                    // Search for block containing the transaction
                    document.getElementById('downloadStatus').textContent = '„Éñ„É≠„ÉÉ„ÇØ„ÇíÊ§úÁ¥¢‰∏≠...';
                    metadataBlock = await findBlockContainingTx(txid);
                }
                
                if (!metadataBlock) {
                    throw new Error('„É°„Çø„Éá„Éº„Çø„Éñ„É≠„ÉÉ„ÇØ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
                }
                
                // Extract metadata from transaction
                const metadataPayload = await extractPayloadFromBlock(metadataBlock, txid);
                if (!metadataPayload) {
                    throw new Error('„É°„Çø„Éá„Éº„Çø„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
                }
                
                const metadataJson = new TextDecoder().decode(metadataPayload);
                kaspaMetadata = JSON.parse(metadataJson);
                
                log(`„Éï„Ç°„Ç§„É´: ${kaspaMetadata.file.name} (${kaspaMetadata.chunks.length}„ÉÅ„É£„É≥„ÇØ)`, 'info');
                
                // Determine download mode based on settings and chunk count
                const useParallel = settings.parallelDownloadEnabled && 
                                   kaspaMetadata.chunks.length >= settings.parallelThreshold;
                
                if (useParallel) {
                    log(`‰∏¶Âàó„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„É¢„Éº„Éâ„Çí‰ΩøÁî®„Åó„Åæ„Åô (${settings.parallelConcurrency}‰∏¶Âàó)`, 'info');
                } else {
                    log('„Ç∑„Éº„Ç±„É≥„Ç∑„É£„É´„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„É¢„Éº„Éâ„Çí‰ΩøÁî®„Åó„Åæ„Åô', 'info');
                }
                
                // Derive key
                const salt = fromBase64(kaspaMetadata.encryption.pbkdf2.salt);
                const key = await deriveKey(password, salt);
                
                // Create progress tracker
                if (!progressManager) {
                    progressManager = new ProgressManager();
                }
                const downloadProgress = progressManager.createDownload(txid, kaspaMetadata.chunks.length);
                
                let chunks;
                
                if (useParallel) {
                    // Parallel download with fallback
                    try {
                        const downloader = new ParallelDownloader(rpcClient, settings.parallelConcurrency);
                        
                        chunks = await downloader.downloadChunks(
                            kaspaMetadata.chunks,
                            key,
                            kaspaMetadata,
                            (progress) => {
                                const percent = ((progress.completed / progress.total) * 100).toFixed(0);
                                document.getElementById('downloadProgressBar').style.width = percent + '%';
                                document.getElementById('downloadProgressBar').textContent = percent + '%';
                                document.getElementById('downloadStatus').textContent = 
                                    `${progress.completed}/${progress.total} „ÉÅ„É£„É≥„ÇØ (${progress.speed.toFixed(1)} „ÉÅ„É£„É≥„ÇØ/Áßí, ${progress.throughput.toFixed(1)} MB/Áßí)`;
                                
                                progressManager.updateDownloadProgress(
                                    downloadProgress.id, 
                                    progress.completed,
                                    progress.speed,
                                    progress.throughput
                                );
                            }
                        );
                    } catch (parallelError) {
                        log(`‰∏¶Âàó„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Ç®„É©„Éº: ${parallelError.message}`, 'error');
                        log('„Ç∑„Éº„Ç±„É≥„Ç∑„É£„É´„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Å´„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Åó„Åæ„Åô', 'warning');
                        
                        // Fallback to sequential download
                        chunks = await sequentialDownload(kaspaMetadata, key, downloadProgress);
                    }
                } else {
                    // Sequential download (v3.5.0 compatible)
                    chunks = await sequentialDownload(kaspaMetadata, key, downloadProgress);
                }
                
                // Combine chunks
                document.getElementById('downloadStatus').textContent = '„Éï„Ç°„Ç§„É´„ÇíÂæ©ÂÖÉ‰∏≠...';
                
                const combined = new Uint8Array(chunks.reduce((acc, chunk) => acc + chunk.length, 0));
                let offset = 0;
                for (const chunk of chunks) {
                    combined.set(chunk, offset);
                    offset += chunk.length;
                }
                
                // Decompress if needed
                const fileData = kaspaMetadata.compression.enabled ? 
                    lzDecompress(combined) : combined;
                
                // Create download
                const blob = new Blob([fileData], { type: kaspaMetadata.file.type });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = kaspaMetadata.file.name;
                a.click();
                URL.revokeObjectURL(url);
                
                document.getElementById('downloadStatus').textContent = '„ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÂÆå‰∫ÜÔºÅ';
                document.getElementById('downloadProgressBar').style.width = '100%';
                document.getElementById('downloadProgressBar').textContent = '100%';
                
                showToast('„ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÂÆå‰∫ÜÔºÅ', 'success');
                
            } catch (error) {
                log(`„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Ç®„É©„Éº: ${error.message}`, 'error');
                showToast('„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
            }
        };
        
        // Sequential download function (v3.5.0 compatible)
        async function sequentialDownload(kaspaMetadata, key, downloadProgress) {
            const chunks = [];
            
            for (let i = 0; i < kaspaMetadata.chunks.length; i++) {
                const chunkMeta = kaspaMetadata.chunks[i];
                
                document.getElementById('downloadStatus').textContent = 
                    `„ÉÅ„É£„É≥„ÇØ ${i + 1}/${kaspaMetadata.chunks.length} „ÇíÂèñÂæó‰∏≠...`;
                
                let success = false;
                let lastError = null;
                
                // Retry logic
                for (let retry = 0; retry <= config.retryCount; retry++) {
                    try {
                        // Get block data
                        const response = await rpcClient.getBlock({
                            hash: chunkMeta.blockId,
                            includeTransactions: true
                        });
                        
                        const block = response?.block?.block || response?.block;
                        if (!block) {
                            throw new Error(`„Éñ„É≠„ÉÉ„ÇØ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì: ${chunkMeta.blockId}`);
                        }
                        
                        // Find transaction and extract payload
                        let payload = null;
                        for (const tx of block.transactions || []) {
                            const txId = tx.verboseData?.transactionId || tx.id || tx.transactionId;
                            if (txId === chunkMeta.txid) {
                                if (tx.payload && tx.payload !== '') {
                                    payload = safeHexDecode(tx.payload, 'chunk payload');
                                    break;
                                }
                            }
                        }
                        
                        if (!payload) {
                            throw new Error(`„ÉÅ„É£„É≥„ÇØ ${i + 1} „ÅÆ„Éö„Ç§„É≠„Éº„Éâ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì`);
                        }
                        
                        // Decrypt chunk
                        const decrypted = await decryptChunk(payload, key, i);
                        chunks.push(decrypted);
                        
                        const progress = ((i + 1) / kaspaMetadata.chunks.length * 100).toFixed(0);
                        document.getElementById('downloadProgressBar').style.width = progress + '%';
                        document.getElementById('downloadProgressBar').textContent = progress + '%';
                        
                        progressManager.updateDownloadProgress(downloadProgress.id, i + 1);
                        
                        success = true;
                        break;
                    } catch (error) {
                        lastError = error;
                        if (retry < config.retryCount) {
                            log(`„ÉÅ„É£„É≥„ÇØ ${i + 1} „ÅÆÂèñÂæó„Å´Â§±Êïó („É™„Éà„É©„Ç§ ${retry + 1}/${config.retryCount})`, 'warning');
                            await new Promise(resolve => setTimeout(resolve, 1000 * (retry + 1)));
                        }
                    }
                }
                
                if (!success) {
                    throw lastError || new Error(`„ÉÅ„É£„É≥„ÇØ ${i + 1} „ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü`);
                }
            }
            
            return chunks;
        }
        
        async function getBlockData(blockId) {
            try {
                const response = await rpcClient.getBlock({
                    hash: blockId,
                    includeTransactions: true
                });
                
                return response?.block?.block || response?.block;
            } catch (error) {
                log(`„Éñ„É≠„ÉÉ„ÇØÂèñÂæó„Ç®„É©„Éº: ${error.message}`, 'error');
                return null;
            }
        }
        
        async function findBlockContainingTx(txid) {
            try {
                // First try WebSocket monitoring if active
                if (monitoredTransactions.has(txid)) {
                    const blockInfo = monitoredTransactions.get(txid);
                    return await getBlockData(blockInfo.blockHash);
                }
                
                // Try to get transaction info
                const txResponse = await rpcClient.getTransaction({
                    transactionId: txid,
                    includeBlockInfo: true
                });
                
                if (txResponse && txResponse.block) {
                    return await getBlockData(txResponse.block.hash);
                }
                
                // Fallback: search recent blocks
                log('„Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥„ÅÆ„Éñ„É≠„ÉÉ„ÇØ„ÇíÊ§úÁ¥¢‰∏≠...', 'info');
                
                const virtualSelectedParentBlueScoreResponse = await rpcClient.getVirtualSelectedParentBlueScore();
                const currentBlueScore = virtualSelectedParentBlueScoreResponse.blueScore;
                
                // Search last 1000 blocks
                for (let i = 0; i < 1000; i += 10) {
                    const blocksResponse = await rpcClient.getBlocksByLowHash({
                        lowHash: '0000000000000000000000000000000000000000000000000000000000000000',
                        includeBlocks: true,
                        includeTransactions: true
                    });
                    
                    if (blocksResponse && blocksResponse.blocks) {
                        for (const blockData of blocksResponse.blocks) {
                            const block = blockData.block;
                            if (block && block.transactions) {
                                for (const tx of block.transactions) {
                                    const foundTxId = tx.verboseData?.transactionId || tx.id;
                                    if (foundTxId === txid) {
                                        return block;
                                    }
                                }
                            }
                        }
                    }
                    
                    // Wait before next batch
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                throw new Error('„Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥„ÇíÂê´„ÇÄ„Éñ„É≠„ÉÉ„ÇØ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
            } catch (error) {
                log(`„Éñ„É≠„ÉÉ„ÇØÊ§úÁ¥¢„Ç®„É©„Éº: ${error.message}`, 'error');
                throw error;
            }
        }
        
        async function extractPayloadFromBlock(block, txid) {
            if (!block || !block.transactions) return null;
            
            for (const tx of block.transactions) {
                const foundTxId = tx.verboseData?.transactionId || tx.id || tx.transactionId;
                if (foundTxId === txid) {
                    if (tx.payload && tx.payload !== '') {
                        return safeHexDecode(tx.payload, 'metadata payload');
                    }
                }
            }
            
            return null;
        }
        
        // History display
        function updateHistoryDisplay() {
            const historyContent = document.getElementById('historyContent');
            
            if (uploadHistory.length === 0) {
                historyContent.innerHTML = '<p style="color: #999;">„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂ±•Ê≠¥„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</p>';
                return;
            }
            
            historyContent.innerHTML = '';
            
            uploadHistory.forEach((entry, index) => {
                const uploadDiv = document.createElement('div');
                uploadDiv.className = 'upload-item';
                
                const date = new Date(entry.timestamp);
                const downloadInfo = `${entry.txid}:${entry.blockId}`;
                
                uploadDiv.innerHTML = `
                    <div class="upload-title">${entry.fileName}</div>
                    <div class="upload-meta">
                        Êó•ÊôÇ: ${date.toLocaleString()}<br>
                        „Çµ„Ç§„Ç∫: ${formatFileSize(entry.fileSize)}<br>
                        „ÉÅ„É£„É≥„ÇØÊï∞: ${entry.chunks}<br>
                        „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ: ${entry.network}<br>
                        TxID: <code>${entry.txid}</code>
                    </div>
                    <div class="history-tab-buttons">
                        <button class="history-small-btn" onclick="downloadWithPassword('${entry.txid}', '${entry.blockId}', ${index})">üîê .kaspa („Éë„Çπ„ÉØ„Éº„Éâ‰ªò„Åç)</button>
                        <button class="history-small-btn" onclick="downloadWithoutPassword('${entry.txid}', '${entry.blockId}', ${index})">üîì .kaspa („Éë„Çπ„ÉØ„Éº„Éâ„Å™„Åó)</button>
                        <button class="history-small-btn" onclick="copyDownloadInfo('${downloadInfo}', true)">üìã TxID („Éë„Çπ„ÉØ„Éº„Éâ‰ªò„Åç)</button>
                        <button class="history-small-btn" onclick="copyDownloadInfo('${downloadInfo}', false)">üìã TxID („Éë„Çπ„ÉØ„Éº„Éâ„Å™„Åó)</button>
                        <button class="history-small-btn" onclick="copyPasswordOnly(${index})">üîë „Éë„Çπ„ÉØ„Éº„Éâ„ÅÆ„Åø</button>
                    </div>
                `;
                
                historyContent.appendChild(uploadDiv);
            });
        }
        
        // History actions
        window.downloadWithPassword = async function(txid, blockId, index) {
            const password = prompt('„Åì„ÅÆ„Éï„Ç°„Ç§„É´„ÅÆ„Éë„Çπ„ÉØ„Éº„Éâ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ:');
            if (!password) return;
            
            const entry = uploadHistory[index];
            const fileData = {
                version: '1.0',
                type: 'kaspa-encrypted-file',
                txid: txid,
                blockId: blockId,
                metadata: entry.metadata,
                requiresPassword: true
            };
            
            const blob = new Blob([JSON.stringify(fileData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = entry.fileName + '.kaspa';
            a.click();
            URL.revokeObjectURL(url);
            
            showToast('.kaspa„Éï„Ç°„Ç§„É´„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Åó„Åæ„Åó„ÅüÔºà„Éë„Çπ„ÉØ„Éº„Éâ‰ªò„ÅçÔºâ', 'success');
        };
        
        window.downloadWithoutPassword = async function(txid, blockId, index) {
            const password = prompt('„Åì„ÅÆ„Éï„Ç°„Ç§„É´„ÅÆ„Éë„Çπ„ÉØ„Éº„Éâ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ:');
            if (!password) return;
            
            const entry = uploadHistory[index];
            const fileData = {
                version: '1.0',
                type: 'kaspa-encrypted-file',
                txid: txid,
                blockId: blockId,
                metadata: entry.metadata,
                password: password,
                requiresPassword: false
            };
            
            const blob = new Blob([JSON.stringify(fileData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = entry.fileName + '.kaspa';
            a.click();
            URL.revokeObjectURL(url);
            
            showToast('.kaspa„Éï„Ç°„Ç§„É´„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Åó„Åæ„Åó„ÅüÔºà„Éë„Çπ„ÉØ„Éº„ÉâÂüã„ÇÅËæº„ÅøÔºâ', 'success');
        };
        
        window.copyDownloadInfo = async function(info, withPasswordPrompt) {
            if (withPasswordPrompt) {
                const password = prompt('„Åì„ÅÆ„Éï„Ç°„Ç§„É´„ÅÆ„Éë„Çπ„ÉØ„Éº„Éâ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ:');
                if (password) {
                    await navigator.clipboard.writeText(`${info}:${password}`);
                    showToast('„ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÊÉÖÂ†±„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„ÅüÔºà„Éë„Çπ„ÉØ„Éº„Éâ‰ªò„ÅçÔºâ', 'success');
                }
            } else {
                await navigator.clipboard.writeText(info);
                showToast('„ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÊÉÖÂ†±„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„ÅüÔºà„Éë„Çπ„ÉØ„Éº„Éâ„Å™„ÅóÔºâ', 'success');
            }
        };
        
        window.copyPasswordOnly = async function(index) {
            const password = prompt('„Åì„ÅÆ„Éï„Ç°„Ç§„É´„ÅÆ„Éë„Çπ„ÉØ„Éº„Éâ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ:');
            if (password) {
                await navigator.clipboard.writeText(password);
                showToast('„Éë„Çπ„ÉØ„Éº„Éâ„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü', 'success');
            }
        };
        
        // Settings functions
        window.exportLogs = function() {
            const data = {
                version: '1.0',
                exported: new Date().toISOString(),
                logs: systemLogs,
                settings: {
                    network: config.network,
                    retryCount: config.retryCount,
                    timeout: config.timeout
                }
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `kaspa-logs-${new Date().toISOString().slice(0, 10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            showToast('„É≠„Ç∞„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åó„Åæ„Åó„Åü', 'success');
        };
        
        window.clearLogs = function() {
            if (confirm('„Åô„Åπ„Å¶„ÅÆ„É≠„Ç∞„Çí„ÇØ„É™„Ç¢„Åó„Åæ„Åô„ÅãÔºü')) {
                systemLogs = [];
                document.getElementById('systemLog').innerHTML = '';
                showToast('„É≠„Ç∞„Çí„ÇØ„É™„Ç¢„Åó„Åæ„Åó„Åü', 'success');
            }
        };
        
        window.copyLog = async function() {
            const logText = systemLogs.map(log => 
                `[${log.time}] [${log.type.toUpperCase()}] ${log.message}`
            ).join('\n');
            
            await navigator.clipboard.writeText(logText);
            showToast('„É≠„Ç∞„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü', 'success');
        };
        
        // Performance test
        window.testParallelPerformance = async function() {
            if (!rpcClient || !rpcClient.isConnected) {
                await initializeRPC();
            }
            
            document.getElementById('performanceResults').style.display = 'block';
            const chartDiv = document.getElementById('performanceChart');
            chartDiv.innerHTML = '„ÉÜ„Çπ„ÉàÂÆüË°å‰∏≠...\n\n';
            
            const testConfigs = [2, 4, 8, 12, 16];
            const results = [];
            
            for (const concurrency of testConfigs) {
                chartDiv.innerHTML += `‰∏¶ÂàóÂ∫¶ ${concurrency} „Çí„ÉÜ„Çπ„Éà‰∏≠...\n`;
                
                try {
                    const startTime = Date.now();
                    const testBlocks = 100;
                    let completed = 0;
                    
                    // Create test workers
                    const workers = [];
                    const queue = [];
                    
                    // Get recent blocks for testing
                    const response = await rpcClient.getVirtualChainFromBlock({
                        startHash: '0000000000000000000000000000000000000000000000000000000000000000',
                        includeAcceptedTransactionIds: false
                    });
                    
                    if (response && response.removedChainBlockHashes) {
                        for (let i = 0; i < Math.min(testBlocks, response.removedChainBlockHashes.length); i++) {
                            queue.push(response.removedChainBlockHashes[i]);
                        }
                    }
                    
                    // Test parallel fetching
                    const workerFunc = async () => {
                        while (queue.length > 0) {
                            const blockHash = queue.shift();
                            if (!blockHash) continue;
                            
                            try {
                                await rpcClient.getBlock({
                                    hash: blockHash,
                                    includeTransactions: false
                                });
                                completed++;
                            } catch (error) {
                                // Ignore errors in test
                            }
                        }
                    };
                    
                    for (let i = 0; i < concurrency; i++) {
                        workers.push(workerFunc());
                    }
                    
                    await Promise.all(workers);
                    
                    const elapsed = (Date.now() - startTime) / 1000;
                    const speed = completed / elapsed;
                    
                    results.push({
                        concurrency: concurrency,
                        speed: speed,
                        elapsed: elapsed
                    });
                    
                    chartDiv.innerHTML += `ÂÆå‰∫Ü: ${speed.toFixed(1)} „Éñ„É≠„ÉÉ„ÇØ/Áßí\n`;
                    
                } catch (error) {
                    chartDiv.innerHTML += `„Ç®„É©„Éº: ${error.message}\n`;
                }
                
                chartDiv.innerHTML += '\n';
            }
            
            // Show results
            chartDiv.innerHTML += '=== „ÉÜ„Çπ„ÉàÁµêÊûú ===\n\n';
            results.forEach(result => {
                const bar = '‚ñà'.repeat(Math.round(result.speed / 5));
                chartDiv.innerHTML += `${result.concurrency}‰∏¶Âàó: ${bar} ${result.speed.toFixed(1)} blocks/s\n`;
            });
            
            const best = results.reduce((a, b) => a.speed > b.speed ? a : b);
            chartDiv.innerHTML += `\nÊúÄÈÅ©„Å™‰∏¶ÂàóÂ∫¶: ${best.concurrency} (${best.speed.toFixed(1)} blocks/s)`;
            
            showToast('„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÉÜ„Çπ„ÉàÂÆå‰∫Ü', 'success');
        };
        
        // Toast notification
        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = 'success-toast';
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.remove();
            }, 3000);
        }
        
        // Initialize on load
        window.addEventListener('load', async () => {
            log('Kaspa P2P File Storage v3.6.1 Ëµ∑Âãï', 'info');
            
            // Load settings
            loadSettings();
            
            // Try to load saved private key
            const savedKey = localStorage.getItem('kaspaPrivateKey');
            if (savedKey) {
                document.getElementById('privateKeyInput').value = savedKey;
                await importWallet();
            }
            
            // Update network settings
            document.getElementById('networkSelect').addEventListener('change', (e) => {
                config.network = e.target.value;
                if (rpcClient) {
                    rpcClient.disconnect();
                    rpcClient = null;
                }
            });
            
            document.getElementById('retryCount').addEventListener('change', (e) => {
                config.retryCount = parseInt(e.target.value);
            });
            
            document.getElementById('timeout').addEventListener('change', (e) => {
                config.timeout = parseInt(e.target.value) * 1000;
            });
            
            // Initialize progress manager
            progressManager = new ProgressManager();
        });
    </script>
</body>
</html>